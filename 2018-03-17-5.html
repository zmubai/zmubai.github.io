<!DOCTYPE html>
<html>
  <head>
      <script>
  var _hmt = _hmt || []
  ;(function() {
    var hm = document.createElement('script')
    hm.src = 'https://hm.baidu.com/hm.js?5a0acc897fd96474a2c8f4deac84611a'
    var s = document.getElementsByTagName('script')[0]
    s.parentNode.insertBefore(hm, s)
  })()
</script> 
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="keywords" content="" />
    <meta name="description" content="知行合一" />
    
    <title>
      iOS m3u8本地缓存播放(控制下载并发、暂停恢复) - liang&#39;s blog
    </title>
    <link rel="manifest" href="/manifest.json" />
    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="/style/style.css">
  </head>
  <body>
    
    <div id="post-toc" class="animated hiddenToc hide">
      <span class="title">Toc</span>
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、m3u8缓存播放的整个流程"><span class="toc-text">一、m3u8缓存播放的整个流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、控制媒体下载的并发数"><span class="toc-text">二、控制媒体下载的并发数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、控制单个媒体的切片下载并发数"><span class="toc-text">三、控制单个媒体的切片下载并发数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、下载的中断和恢复"><span class="toc-text">四、下载的中断和恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#总结下任务生命周期中的任务状态变化："><span class="toc-text">总结下任务生命周期中的任务状态变化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#回归正题："><span class="toc-text">回归正题：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、注意的问题与思路延伸"><span class="toc-text">五、注意的问题与思路延伸</span></a></li></ol>
    </div>
    
    <div id="fixed-menu-wrap">
      <span class="iconfont icon-sousuo search-box menu-reset"></span>
      <span class="icon-toc menu-reset">Toc</span>
      <span class="iconfont icon-arrowup menu-reset"></span>
    </div>
    <div id="fixed-menu">
      <span class="iconfont icon-menu-"></span>
    </div>
    <div id="progress">
      <div class="line"></div>
    </div>
    <div id="search-shade" class="animated hiddenSearch hide">
      <div class="input-wrap">
        <span class="iconfont icon-sousuo search-box"></span>
        <input type="text" placeholder="Search" />
        <span class="iconfont icon-close"></span>
      </div>
      <div class="search-result">
        <div class="meta">
          <span><b id="result-count">0</b> results found</span>
          <img src="/images/logo.jpeg" />
        </div>
        <ul id="result-box"></ul>
      </div>
    </div>
    <div id="menu-mask" class="animated hideMenuMask hide">
      <span class="iconfont icon-close"></span>
      <div class="nav">
        
        <a href="/" class="">
          Home
        </a>
        
        <a href="/archives" class="">
          Archives
        </a>
        
        <a href="/categories" class="">
          Categories
        </a>
        
        <a href="/tags" class="">
          Tags
        </a>
        
        <a href="/friends" class="">
          Friends
        </a>
        
        <a href="/about" class="">
          About
        </a>
        
      </div>
    </div>
    <div id="header">
      <div class="intro">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        <div class="author">liang</div>
      </div>
      <div class="nav">
        <span class="iconfont icon-menu menu-icon"></span>
        <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a>
      </div>
    </div>
    <div id="side" class="animated bounceInLeft">
      <div class="shrink">
        <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        <span class="iconfont icon-menu toggle-icon"></span>
        <a href="#" class="search-box">
          <span class="iconfont icon-sousuo"></span>
        </a>
      </div>
      <div class="magnify">
        <div class="about">
          <div class="author">liang</div>
          <a href="/" class="logo" style="background-image: url('/images/logo.jpeg')"></a>
        </div>

        <div class="nav">
          
          <a href="/" class="">
            Home
          </a>
          
          <a href="/archives" class="">
            Archives
          </a>
          
          <a href="/categories" class="">
            Categories
          </a>
          
          <a href="/tags" class="">
            Tags
          </a>
          
          <a href="/friends" class="">
            Friends
          </a>
          
          <a href="/about" class="">
            About
          </a>
          
          <a href="#" class="search-box">
            <span class="iconfont icon-sousuo"></span>
          </a>
        </div>
        <div class="bottom">
          <div class="follow">
            
            <a href="https://github.com/zmubai" target="_block">
              <span class="iconfont icon-github"></span>
            </a>
             
            <a href="/atom.xml" target="_block">
              <span class="iconfont icon-rss"></span>
            </a>
            
          </div>
        </div>
      </div>
    </div>
    <div id="container">
      <div class="main animated bounceInRight delay-0.7s">
        <article class="post-entry">
    <div class="header">
      
      <div class="title">iOS m3u8本地缓存播放(控制下载并发、暂停恢复)</div>
      <div class="meta">
        <span class="item">
          <span class="iconfont icon-time-circle"></span>
          <span>2017/10/11</span>
        </span>

        

         
        <span class="item">
          <span class="iconfont icon-folder"></span>
          <span>
              
                
                  <a href="/categories/m3u8">m3u8</a>
                
              
          </span>
        </span>
        
        
         
          <span class="item">
            <span class="iconfont icon-tag1"></span>
            <span>
                
                  
                    <a href="/tags/m3u8">m3u8</a>
                  
                
            </span>
          </span>
         
      </div>
      <div>
      </div>
    </div>
    <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">目录</span><br><span class="line">一、<span class="name">m3</span>u<span class="number">8</span>缓存播放的整个流程</span><br><span class="line">二、控制媒体下载的并发数</span><br><span class="line">三、控制单个媒体的切片下载并发数</span><br><span class="line">四、下载的中断和恢复</span><br><span class="line">五、注意的问题与思路延伸</span><br></pre></td></tr></table></figure>
<h3 id="一、m3u8缓存播放的整个流程">一、m3u8缓存播放的整个流程<a class="post-anchor" href="#一、m3u8缓存播放的整个流程"></a></h3><ol>
<li>下载m3u8文件</li>
<li>解析m3u8文件获取视频切片单元的信息。</li>
<li>根据2.获取的视频切片信息中的切片链接下载切片并保持到本地。</li>
<li>根据获取的切片信息与本地服务器的配置信息，拼接出切片的本地地址、生成新的m3u8文件并保存到本地。</li>
<li>开启本地服务器，使用本地url播放本地m3u8文件。</li>
</ol>
<p>附上：时序图，具体可看demo</p>
<p><a href="http://upload-images.jianshu.io/upload_images/1690665-3f245e01576dfac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-caption="image.png" data-fancybox="images"><img src="http://upload-images.jianshu.io/upload_images/1690665-3f245e01576dfac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></a></p>
<h3 id="二、控制媒体下载的并发数">二、控制媒体下载的并发数<a class="post-anchor" href="#二、控制媒体下载的并发数"></a></h3><pre><code>这里使用信号量来控制并发数
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadVideoWithUrlString:(<span class="built_in">NSString</span> *)urlStr downloadProgressHandler:(ZBLM3u8ManagerDownloadProgressHandler)downloadProgressHandler downloadSuccessBlock:(ZBLM3u8ManagerDownloadSuccessBlock) downloadSuccessBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(_downloadQueue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(_movieSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line">        [[<span class="keyword">self</span> downloadContainerWithUrlString:urlStr] startDownloadWithUrlString:urlStr  downloadProgressHandler:^(<span class="keyword">float</span> progress) &#123;</span><br><span class="line">            downloadProgressHandler(progress);</span><br><span class="line">        &#125; completaionHandler:^(<span class="built_in">NSString</span> *locaLUrl, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                [weakself.downloadContainerDictionary removeObjectForKey:[ZBLM3u8Setting uuidWithUrl:urlStr]];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"下载完成:%@"</span>,urlStr);</span><br><span class="line">                downloadSuccessBlock(locaLUrl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"下载失败:%@"</span>,error);</span><br><span class="line">                [<span class="keyword">self</span> resumeDownload];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,weakself.downloadContainerDictionary.allKeys);</span><br><span class="line">            dispatch_semaphore_signal(_movieSemaphore);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>//这里可以设置_movieSemaphore的的初始值为具体的可同时下载数。Example:_movieSemaphore = dispatch_semaphore_create(1),意味着同一时间只允许下载一个视频，等同于视频的串行下载。
</code></pre><h3 id="三、控制单个媒体的切片下载并发数">三、控制单个媒体的切片下载并发数<a class="post-anchor" href="#三、控制单个媒体的切片下载并发数"></a></h3><pre><code>开始的时候，考虑使用AFURLSessionManager中的operationQueue.maxConcurrentOperationCount来控制并发。但这是行不通的。因为这个queue是用于回调而不是用于下载队列。
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The operation queue on which delegate callbacks are run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> *operationQueue;</span><br></pre></td></tr></table></figure>
<p>再看AF中初始化<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<pre><code>这个queue确实是用于回调，而我是需要控制下载并发。这似乎不满足。而且实测中也发现确实不行。那么，只能在任务发起哪里做并发控制，同样，这里还是采用信号量。这里的控制相对复杂一点、因为后面的任务恢复、失败任务重新创建也要做控制。
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startDownload</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为这是外部调用的方法，操作的执行要放到异步线程中。避免因为并发控制中的等待而堵塞外部线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.downloadQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (!_fileDownloadInfos.count) &#123;</span><br><span class="line">            _completaionHandler(<span class="literal">nil</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"downloadInfoCount:%ld"</span>,(<span class="keyword">long</span>)_fileDownloadInfos.count);</span><br><span class="line">        </span><br><span class="line">        [_fileDownloadInfos enumerateObjectsUsingBlock:^(ZBLM3u8FileDownloadInfo * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            <span class="comment">//控制切片下载并发</span></span><br><span class="line">            dispatch_semaphore_wait(<span class="keyword">self</span>.tsSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">            <span class="keyword">if</span> ([ZBLM3u8FileManager exitItemWithPath:obj.filePath]) &#123;</span><br><span class="line">                obj.success = <span class="literal">YES</span>;</span><br><span class="line">                [<span class="keyword">self</span> verifyDownloadCountAndCallbackByDownloadSuccess:<span class="literal">YES</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果收到中断信号，中断下载流程释放信号量并返回</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.suspend) &#123;</span><br><span class="line">                    obj.beStopCreateTask = <span class="literal">YES</span>;</span><br><span class="line">                    dispatch_semaphore_signal(<span class="keyword">self</span>.tsSemaphore);</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"suspend and return! don not createDownloadTask!"</span>);</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//真正的创建下载任务</span></span><br><span class="line">                    [<span class="keyword">self</span> createDownloadTaskWithIndex:idx];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量在每个任务的回调后都会释放一次</span></span><br><span class="line">- (<span class="keyword">void</span>)verifyDownloadCountAndCallbackByDownloadSuccess:(<span class="built_in">BOOL</span>) isSuccess</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_signal(<span class="keyword">self</span>.tsSemaphore);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里也看到信号量的控制问题，必须理清信号量的获得和释放时机，一次获得必须有一次释放。不释放或者重复释放，都会导致并发的控制不准。如果这样，那这里的并发控制就没有意义了。</p>
</li>
<li><p>要做到准确获取和释放，重点在于理清程序的执行路径。在每一条执行路径中都必须释放信号量。这个跟锁的使用也是一样的。</p>
</li>
<li>调试现象：如果程序不像预料中运行，又没有什么错误，那很有可能就是堵塞了。锁没有释放或者信号量的处理有问题。<br>处理步骤：点击xcode调试栏的暂停按钮，查看程序的调用栈，分析每个线程的运行情况，找到堵塞具体执行代码。根据具体的逻辑修正问题。</li>
</ul>
<h3 id="四、下载的中断和恢复">四、下载的中断和恢复<a class="post-anchor" href="#四、下载的中断和恢复"></a></h3><pre><code>这里有几个小问题：根据判断NSURLSessionTask 提供的3个方法可以做一些中断和恢复处理
</code></pre><ul>
<li><p>(void)suspend;</p>
<pre><code>挂起任务，但只能挂起执行中的任务。对于已经创建而且执行resum方法但并没真正执行的任务无效（这里非常坑）。
</code></pre><p>通常我们使用这个方法的时候会判断下任务的具体状态，如果是task.state == NSURLSessionTaskStateRunning采取执行 [task suspend]。但这个判断是不准确的。如果一个任务创建并执行resume但并没真正执行，它的状态也是为NSURLSessionTaskStateRunning。如果这个时候程序收到中断消息，对状态为NSURLSessionTaskStateRunning 的任务全部执行suspend操作，你会发现有些任务不听话，继续执行。到底什么搞鬼…<br>我的理解是这样的，这些不听话的任务正是那些添加到下载队列中等待执行的任务，而在等待状态下收到suspend消息是不管用的。但它接收cannel消息是管用的。那么问题的解决就是找出这些等待的任务。<br>处理办法：通过判断接收字节数来区分状态。现在我只面向你接收的字节数，而不管你真开启还是假开启了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (obj.downloadTask.state) &#123;</span><br><span class="line">                <span class="keyword">case</span> NSURLSessionTaskStateRunning:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//等待中，假开启状态，</span></span><br><span class="line">                    <span class="keyword">if</span> (obj.downloadTask.countOfBytesReceived &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        [<span class="meta">obj.downloadTask cancel</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                    <span class="comment">//正在下载，真开启状态，</span></span><br><span class="line">                        [<span class="meta">obj.downloadTask suspend</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>(void)resume;<br>官方文档是这么说明的：Resumes the task, if it is suspended.意思是指只能发起被挂起的任务。<br>存在两种情况：<br>1.新创建的任务并没有执行resume，此时状态为：NSURLSessionTaskStateSuspended<br>2.执行suspend方法后被手动挂起的任务，状态同为NSURLSessionTaskStateSuspended。<br>同时这里提供了额外信息：状态为NSURLSessionTaskStateCompleted的任务是不能通过resume重新发起的。而在某些情况下我们需要对这种状态的任务重新发起，包括手动cannel的、执行失败的。这种情况下只能根据具体的情况，重新创建任务并发起。<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (obj.downloadTask.error &amp;&amp; </span><br><span class="line">    obj.downloadTask.<span class="keyword">state</span> == NSURLSessionTaskStateCompleted)</span><br><span class="line">&#123;</span><br><span class="line">              //下载失败的任务重新创建</span><br><span class="line">                [<span class="literal">self</span> createDownloadTaskWithIndex:idx];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(void)cancel;<br>官方文档说明：</p>
<blockquote>
<p>This method returns immediately, marking the task as being canceled. Once a task is marked as being canceled, URLSession:task:didCompleteWithError: will be sent to the task delegate, passing an error in the domain NSURLErrorDomain with the code NSURLErrorCancelled. A task may, under some circumstances, send messages to its delegate before the cancelation is acknowledged.<br>This method may be called on a task that is suspended.</p>
</blockquote>
<p>简而言之：调用这个方法可以cannel任意状态的任务包括挂起的任务。并执行didCompleteWithError回调（AF中会执行回调并返回错误NSURLErrorCancelled），状态被标记为NSURLSessionTaskStateCompleted。故上面恢复失败任务的时候，通过task.state和task.error共同判断。</p>
</li>
</ul>
<h5 id="总结下任务生命周期中的任务状态变化：">总结下任务生命周期中的任务状态变化：<a class="post-anchor" href="#总结下任务生命周期中的任务状态变化："></a></h5><ol>
<li>创建成功：…Suspended</li>
<li>执行resume:…Running（可以通过判断countOfBytesReceived来区分任务处于等待还是下载中）</li>
<li>执行suspend：…Suspended</li>
<li>执行cannel：(中间状态…Canceling）-&gt;…Completed（可以结合task.error判断任务执行结果）</li>
</ol>
<h5 id="回归正题：">回归正题：<a class="post-anchor" href="#回归正题："></a></h5><pre><code>视频单元的中断和恢复，中断就是调用suspend方法挂起正在执行的任务，cannel掉等待的任务，代码跟上面说明方法的时候非常雷同。这里着重说明下恢复。如果单单恢复其实很简单，恢复挂起的任务和重新创建错误的任务。这只是从程序的角度看待，要使一个程序有更高的可用性，应在功能实现的同时做的更加的合理。应优先恢复挂起的任务、然后重新创建错误的任务。这样做都是为了承前启后更快的把一个下载任务完成。而且这个视频切片是讲究有序的，所以我们恢复的时候也要遵从FIFO的原则。
</code></pre><h3 id="五、注意的问题与思路延伸">五、注意的问题与思路延伸<a class="post-anchor" href="#五、注意的问题与思路延伸"></a></h3><ol>
<li><p>解析m3u8注意的问题<br>   这里的解析格式太多，很容易出现问题，应使用try/catch来保证程序的健壮性。</p>
</li>
<li><p>根据url获取原始m3u8文件信息，这个操作太耗时了。为了提高程序的效率，获取到原始m3u8文件后应做本地持久化并用于二次下载。如果整个流程下载成功，可以选择删除该文件，或者不操作。由于是纯文本文件，少量的文件冗余是允许的。</p>
</li>
<li><p>文件的操作通过开启一个同步队列来处。可以设定low优先级避免占用太高的cpu资源。其实高cpu占用会伴随着另外一个问题，手机的发热量。</p>
</li>
<li><p>key的处理问题<br>   如果存在key的下载，需要把key下载到本地，约定好key的名称和新建m3u8文件中的key链接。这样本地播放就能正常加解密。<br>例如下载到本地的key保存为…/key。那么链接应该是http:localhost:port/…/key</p>
</li>
<li><p>中断的优先级<br>   程序的中断操作拥有最高优先级的，因为要任何状态下都能中断下载。无论是为了程序的流畅性、网络变为移动信号避免使用用户的移动流量等发出中断命令，都必须立即响应。</p>
</li>
<li><p>切片数量的全局分配<br>   多个视频同时下载，多个切片同时并发。如果要做到控制全局的切片并发数而不是单个视频的切片并发数。这就要设计一个算法在全局Manger哪里做分配和回收。</p>
</li>
<li><p>保证app流程，监控网速开启和中断下载<br>   下载视频的功能应该要保证app本身网络请求的正常运行。<br>app如何获取到网络的带宽，好像只能通过下载文件方式来推算。可在应用请求空闲时通过短时间下载一个可用源来计算带宽，同时监控app 实时网络吞吐，适当的开关下载。虽然很难做到实时，但是在切换网络的时候进行带宽重测、又或者地理位置变化一定距离后进行带宽重测、又或者定时作带宽重测。还有就是考虑wifi状态下才进行下载。</p>
</li>
<li><p>切换网络后请求失去连接，恢复下载的问题<br>   因为网络切换本地ip变化，发起的请求会失去连接。如果通过downloadTask是没办法做到恢复下载的。虽然可以用resumeData来恢复下载，但是这个只能在cannel操作的时候获取，至于失去连接的情况下是没办法获取到的（系统提供的api中没有在失败回调哪里返回resumeData的）。这个时候需要自己创建文件句柄，使用dataTask做到文件续下。初始化dataTask的时候设定请求头’Accept-Ranges’参数为文件的已下载字节数（需要服务器支持），就可以获取到未下载的部分数据。</p>
</li>
<li><p>并发中锁的处理<br>   要理清那些代码可能存在并发，那些操作要保证原子性。难就难在一个方法中会存在部分代码块是并发执行的，这有利于效率的提高；部分些代码要原子操作。最优的做法就是对原子操作用锁来保证，没有任何多余的代码加入到同步操作中，这样也是效率最高的。而拿捏不准的情况下，可以锁定更多的代码，至少这样不会因为并发而导致问题，但这样就牺牲了效率和及时性。当一个简单的系统，要做到最优好像并不难，但是一个复杂的系统做到最优就非常难了或者是要花费非常大的精力。</p>
</li>
<li><p>是否需要全部切片下载完成才能播放<br>  其实并不需要全部下载完成就能播放的。一个车子开起来只要保证后面的能源供应充足就能一直正常运作。首先保证key 先下载下来，而且要保证有序下载，然后下载一定量的切片文件，这个时候就可以组装m3u8文件到本地，发起播放。只要后面下载的切片能满足播放器的播放，就不会出现问题。但如果供应不足视频就会停了，播放不了，尽管后面文件下载下来了，还是不能自动恢复，仿佛失去了缓冲功能。这里就是跟直接请求服务器的差别了，直接请求服务器，因为文件本身是存在的，发起的请求是存在的，如果网速慢，播放器的反应是缓冲；而本地服务播放就不同了，如果文件在播放前没有下载下来，发起的请求立马就挂了，这个请求不存在，当然就不存在缓冲。</p>
</li>
<li><p>线程多开占用资源，每个线程占用512K到1M空间。建议使用单线程下载，且稳定性高。</p>
</li>
</ol>
<p>dome链接：<a href="https://github.com/zmubai/ZBLM3U8DownLoadTest" target="_blank" rel="noopener">https://github.com/zmubai/ZBLM3U8DownLoadTest</a></p>


  
    <div class="post-reward">
    <div id="reward-button">打赏</div>
      <div id="qr">
        <div class="wrap">
            
            <div class="bg-wrap">
              <a href="/images/zhifubao.png" target="_block" class="bg" style="background-image:url('/images/zhifubao.png')"></a>
              支付宝
            </div>
            
            
            <div class="bg-wrap">
                <a href="/images/weixin.png" target="_block" class="bg" style="background-image:url('/images/weixin.png')"></a>
              微信
            </div>
            
        </div>
      </div>
    </div>
  
  <div class="post-guide">
    <div class="item left">
        
          <a href="/2018-03-17-3.html">iOS 网络数据处理技巧，提高程序健壮性</a>
        
    </div>
    <div class="item right">
        
    </div>
  </div>

  

  <div class="post-copyright">
    <div class="auth">
      本文作者：<a href="https://zengbailiang.cn">liang</a>
    </div>
    <div class="link">
      永久链接：<a href="https://zengbailiang.cn/2018-03-17-5.html">https://zengbailiang.cn/2018-03-17-5.html</a>
    </div>
    <div class="declare">
      版权声明：本文首发于<a href="https://zengbailiang.cn">liang</a>的博客，转载请注明出处！
    </div>
  </div>

  <div id="comment"></div>

  
  
</article>
        <footer>
          <div class="copyright">
            ©2019
            <a href="https://zengbailiang.cn">liang</a> Powered by <a href="https://hexo.io">Hexo</a> |
            <a href="https://github.com/shixiaohu2206/hexo-theme-huhu">hexo-theme-huhu</a>
          </div>
          
        </footer>
      </div>
    </div>
  </body>
  
</html>
<script type="text/javascript">
                  window.HUHU_CONFIG = JSON.parse("{\"share\":[\"weibo\",\"weixin\",\"qqkongjian\",\"QQ\",\"douban\",\"facebook\",\"twitter\",\"google\"],\"service_worker\":{\"open\":false}}")
                </script> <script type="text/javascript">window.addEventListener('load', function() {
    
    window.loadJs = function(d, m, a) {
      var c = document.getElementsByTagName('head')[0] || document.head || document.documentElement
      var b = document.createElement('script')
      b.defer = true
      b.setAttribute('type', 'text/javascript')
      b.setAttribute('charset', 'UTF-8')
      b.setAttribute('async', 'true')
      b.setAttribute('src', d)
      m && b.setAttribute('data-main', '/scripts/app-built')
      if (typeof a === 'function') {
        if (window.attachEvent) {
          b.onreadystatechange = function() {
            var e = b.readyState
            if (e === 'loaded' || e === 'complete') {
              b.onreadystatechange = null
              a()
            }
          }
        } else {
          b.onload = a
        }
      }
      c.appendChild(b)
    }
    window.loadJs && window.loadJs('https://cdn.bootcss.com/require.js/2.3.6/require.min.js', true, function() {require.config({"paths":{"util":"util","share":"share","search":"search","registerSW":"registerSW","valine":"cdn/Valine.min","av":["https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min"],"pjax":["https://cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min"],"jquery":["https://cdn.bootcss.com/jquery/3.4.1/jquery.min"],"confirm":["https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min"],"fancybox":["https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min"],"chart":["https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.bundle.min"]},"map":{"*":{"css":"https://cdn.bootcss.com/require-css/0.1.10/css.min.js"}},"shim":{"fancybox":{"deps":["css!https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css"]},"confirm":{"deps":["css!https://cdn.bootcss.com/jquery-confirm/3.3.4/jquery-confirm.min.css"]},"chart":{"deps":["css!https://cdn.bootcss.com/Chart.js/2.8.0-rc.1/Chart.min.css"]}},"waitSeconds":3})})
  })</script> <script type="text/javascript">
                  ;(function() {
                    var bp = document.createElement('script')
                    var curProtocol = window.location.protocol.split(':')[0]
                    if (curProtocol === 'https') {
                      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'
                    } else {
                      bp.src = 'http://push.zhanzhang.baidu.com/push.js'
                    }
                    var s = document.getElementsByTagName('script')[0]
                    s.parentNode.insertBefore(bp, s)
                  })()
                </script> 
