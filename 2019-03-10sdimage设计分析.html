<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="SDWebImage设计思路分析"><meta name="keywords" content="源码阅读,设计分析"><meta name="author" content="liang"><meta name="copyright" content="liang"><title>SDWebImage设计思路分析 | liang's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、库功能"><span class="toc-number">1.</span> <span class="toc-text">一、库功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、整体需求"><span class="toc-number">2.</span> <span class="toc-text">二、整体需求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、-技术的实现"><span class="toc-number">3.</span> <span class="toc-text">三、 技术的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#四、使用的设计模式"><span class="toc-number">4.</span> <span class="toc-text">四、使用的设计模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#五、利用语言特性的相关技巧"><span class="toc-number">5.</span> <span class="toc-text">五、利用语言特性的相关技巧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#六、SDWebImage官方类图"><span class="toc-number">6.</span> <span class="toc-text">六、SDWebImage官方类图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#七、SDWebImage官方时序图"><span class="toc-number">7.</span> <span class="toc-text">七、SDWebImage官方时序图</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">liang</div><div class="author-info__description text-center">知行合一</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">50</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">14</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/personImg/topimg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">liang's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">about</a></span></div><div id="post-info"><div id="post-title">SDWebImage设计思路分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/源码阅读/">源码阅读</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3,516</span><span class="post-meta__separator">|</span><span>阅读时长: 19 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h5 id="一、库功能"><a href="#一、库功能" class="headerlink" title="一、库功能"></a>一、库功能</h5><p>主要提供了网络图片异步下载的功能。使ui展示大量网络图片的时候，能不堵塞主线程，保存界面流畅；同时，能有策略的异步下载图片，并正确的赋值到对应的控件上。sd库在异步下载的基础上，提供了磁盘缓存，提供了图片异步解压，尽可能的提高界面的体验。<br>官方地址:<a href="https://github.com/SDWebImage/SDWebImage" target="_blank" rel="noopener">https://github.com/SDWebImage/SDWebImage</a></p>
<h5 id="二、整体需求"><a href="#二、整体需求" class="headerlink" title="二、整体需求"></a>二、整体需求</h5><ul>
<li><p>需求：imageview 把url作为入参，发起图片异步下载并在下载完毕后回调显示。</p>
</li>
<li><p>功能细分</p>
<ol>
<li>图片完成下载后要正确的赋值给调用的控件，也即两者中要建立一个一对一的绑定关系。</li>
<li>图片异步下载的实现<ol>
<li>包括单个下载的请求组装，状态控制，回调处理，图片预解压等。</li>
<li>请求并发控制。</li>
</ol>
</li>
<li>图片缓存机制的实现<ol>
<li>磁盘读写io的安全控制。</li>
<li>磁盘管理的安全策略设计。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h5 id="三、-技术的实现"><a href="#三、-技术的实现" class="headerlink" title="三、 技术的实现"></a>三、 技术的实现</h5><ul>
<li>通过创建对应的id <sdwebimageoperation> operation,回调中对imageView赋值。<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</span><br><span class="line">             internalSetImageBlock:(<span class="keyword">nullable</span> SDInternalSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)context &#123;</span><br><span class="line">  SDWebImageManager *manager = [context objectForKey:SDWebImageExternalCustomManagerKey];</span><br><span class="line">        <span class="keyword">if</span> (!manager) &#123;</span><br><span class="line">        <span class="comment">///通过单例创建全局的SDWebImageManager</span></span><br><span class="line">            manager = [SDWebImageManager sharedManager];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">///每一个imageView的setImage操作对应的生成一个实现了SDWebImageOperation协议的operation. SDWebImageOperation中有一个cannel方法，用于cannel下载行为。</span></span><br><span class="line"> <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line">            <span class="keyword">if</span> (!sself) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///省略</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">UIImage</span> *targetImage = <span class="literal">nil</span>;</span><br><span class="line">            <span class="built_in">NSData</span> *targetData = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="comment">// case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set</span></span><br><span class="line">                targetImage = image;</span><br><span class="line">                targetData = data;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">                <span class="comment">// case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set</span></span><br><span class="line">                targetImage = placeholder;</span><br><span class="line">                targetData = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dispatch_main_async_safe(^&#123;</span><br><span class="line">                <span class="keyword">if</span> (group) &#123;</span><br><span class="line">                    dispatch_group_enter(group);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">///进行赋值</span></span><br><span class="line">                [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:cacheType imageURL:imageURL];</span><br><span class="line">                <span class="keyword">if</span> (group) &#123;</span><br><span class="line">                    <span class="comment">// compatible code for FLAnimatedImage, because we assume completedBlock called after image was set. This will be removed in 5.x</span></span><br><span class="line">                    <span class="built_in">BOOL</span> shouldUseGroup = [objc_getAssociatedObject(group, &amp;SDWebImageInternalSetImageGroupKey) boolValue];</span><br><span class="line">                    <span class="keyword">if</span> (shouldUseGroup) &#123;</span><br><span class="line">                        dispatch_group_notify(group, dispatch_get_main_queue(), callCompletedBlockClojure);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        callCompletedBlockClojure();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    callCompletedBlockClojure();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</sdwebimageoperation></li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">///这个方法内部包含缓存获取和发起下载的相关逻辑</span></span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)<span class="string">loadImageWithURL:</span>(nullable NSURL *)url</span><br><span class="line"><span class="symbol">                                     options:</span>(SDWebImageOptions)options</span><br><span class="line"><span class="symbol">                                    progress:</span>(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line"><span class="symbol">                                   completed:</span>(nullable SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">// Invoking this method without a completedBlock is pointless</span></span><br><span class="line">    NSAssert(completedBlock != nil, @<span class="string">"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won't</span></span><br><span class="line">    <span class="comment">// throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span></span><br><span class="line">    <span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString<span class="class">.<span class="keyword">class</span>]) &#123;</span></span><br><span class="line">        url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span></span><br><span class="line">    <span class="keyword">if</span> (![url <span class="string">isKindOfClass:</span>NSURL<span class="class">.<span class="keyword">class</span>]) &#123;</span></span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation <span class="keyword">new</span>];</span><br><span class="line">    operation.manager = self;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        LOCK(self.failedURLsLock);</span><br><span class="line">        isFailedUrl = [self.failedURLs <span class="string">containsObject:</span>url];</span><br><span class="line">        UNLOCK(self.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        [self <span class="string">callCompletionBlockForOperation:</span>operation <span class="string">completion:</span>completedBlock <span class="string">error:</span>[NSError <span class="string">errorWithDomain:</span>NSURLErrorDomain <span class="string">code:</span>NSURLErrorFileDoesNotExist <span class="string">userInfo:</span>nil] <span class="string">url:</span>url];</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations <span class="string">addObject:</span>operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    <span class="comment">///根据规则生成缓存key</span></span><br><span class="line">    NSString *key = [self <span class="string">cacheKeyForURL:</span>url];</span><br><span class="line">    </span><br><span class="line">    SDImageCacheOptions cacheOptions = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line">    </span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line">    <span class="comment">///去获取缓存，并在内部根据option参数判断后续的缓存处理和下载行为</span></span><br><span class="line">    operation.cacheOperation = [self.imageCache <span class="string">queryCacheOperationForKey:</span>key <span class="string">options:</span>cacheOptions <span class="string">done:</span>^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check whether we should download image from network</span></span><br><span class="line">        BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))</span><br><span class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</span><br><span class="line">            &amp;&amp; (![self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">shouldDownloadImageForURL:</span>)] || [self.delegate <span class="string">imageManager:</span>self <span class="string">shouldDownloadImageForURL:</span>url]);</span><br><span class="line">        <span class="keyword">if</span> (shouldDownload) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></span><br><span class="line">                <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></span><br><span class="line">                [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// download if no image or requested to refresh anyway, and download allowed by delegate</span></span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            <span class="keyword">if</span> (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                <span class="comment">// force progressive off if image already cached but forced refreshing</span></span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle</span></span><br><span class="line">            __weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            <span class="comment">///发起下载，并保存downloadToken值，以便能找到对应的dowanLoadOperation，去执行cannel操作等。这个会在cannel操作方法中很直观的看到。</span></span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader <span class="string">downloadImageWithURL:</span>url <span class="string">options:</span>downloaderOptions <span class="string">progress:</span>progressBlock <span class="string">completed:</span>^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;</span><br><span class="line">                <span class="keyword">if</span> (!strongSubOperation || strongSubOperation.isCancelled) &#123;</span><br><span class="line">                    <span class="comment">// Do nothing if the operation was cancelled</span></span><br><span class="line">                    <span class="comment">// See #699 for more details</span></span><br><span class="line">                    <span class="comment">// if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">error:</span>error <span class="string">url:</span>url];</span><br><span class="line">                    BOOL shouldBlockFailedURL;</span><br><span class="line">                    <span class="comment">// Check whether we should block failed url</span></span><br><span class="line">                    <span class="keyword">if</span> ([self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">shouldBlockFailedURL:</span><span class="string">withError:</span>)]) &#123;</span><br><span class="line">                        shouldBlockFailedURL = [self.delegate <span class="string">imageManager:</span>self <span class="string">shouldBlockFailedURL:</span>url <span class="string">withError:</span>error];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotConnectToHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorNetworkConnectionLost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (shouldBlockFailedURL) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs <span class="string">addObject:</span>url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs <span class="string">removeObject:</span>url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// We've done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.</span></span><br><span class="line">                    <span class="keyword">if</span> (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</span><br><span class="line">                        downloadedImage = [self <span class="string">scaledImageForKey:</span>key <span class="string">image:</span>downloadedImage];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">transformDownloadedImage:</span><span class="string">withURL:</span>)]) &#123;</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                            <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">                                UIImage *transformedImage = [self.delegate <span class="string">imageManager:</span>self <span class="string">transformDownloadedImage:</span>downloadedImage <span class="string">withURL:</span>url];</span><br><span class="line">                                </span><br><span class="line">                                <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                    BOOL imageWasTransformed = ![transformedImage <span class="string">isEqual:</span>downloadedImage];</span><br><span class="line">                                    NSData *cacheData;</span><br><span class="line">                                    <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></span><br><span class="line">                                    <span class="keyword">if</span> (self.cacheSerializer) &#123;</span><br><span class="line">                                        cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    [self.imageCache <span class="string">storeImage:</span>transformedImage <span class="string">imageData:</span>cacheData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                                &#125;</span><br><span class="line">                                </span><br><span class="line">                                [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>transformedImage <span class="string">data:</span>downloadedData <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>finished <span class="string">url:</span>url];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (self.cacheSerializer) &#123;</span><br><span class="line">                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                                    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">                                        NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);</span><br><span class="line">                                        [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">imageData:</span>cacheData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">imageData:</span>downloadedData <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk <span class="string">completion:</span>nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        [self <span class="string">callCompletionBlockForOperation:</span>strongSubOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>downloadedImage <span class="string">data:</span>downloadedData <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>finished <span class="string">url:</span>url];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                    [self <span class="string">safelyRemoveOperationFromRunning:</span>strongSubOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">            [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>cachedImage <span class="string">data:</span>cachedData <span class="string">error:</span>nil <span class="string">cacheType:</span>cacheType <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Image not in cache and download disallowed by delegate</span></span><br><span class="line">            [self <span class="string">callCompletionBlockForOperation:</span>strongOperation <span class="string">completion:</span>completedBlock <span class="string">image:</span>nil <span class="string">data:</span>nil <span class="string">error:</span>nil <span class="string">cacheType:</span>SDImageCacheTypeNone <span class="string">finished:</span>YES <span class="string">url:</span>url];</span><br><span class="line">            [self <span class="string">safelyRemoveOperationFromRunning:</span>strongOperation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SDWebImageOperation协议</span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageOperation</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///SDWebImageCombinedOperation的实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageCombinedOperation</span></span></span><br><span class="line">- (<span class="keyword">void</span>)cancel &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.cacheOperation) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.cacheOperation cancel];</span><br><span class="line">            <span class="keyword">self</span>.cacheOperation = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadToken) &#123;</span><br><span class="line">        <span class="comment">///根据downloadToke，对应的operation取消下载.[imageDownloader,是一个全局单例..sd里面单例模式用的很多]</span></span><br><span class="line">            [<span class="keyword">self</span>.manager.imageDownloader cancel:<span class="keyword">self</span>.downloadToken];</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span>.manager safelyRemoveOperationFromRunning:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///相关单列</span></span><br><span class="line"><span class="comment">///SDWebImageManager 自身是一个单列的实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageManager</span></span></span><br><span class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">        instance = [<span class="keyword">self</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="comment">///其内部cache和downloader，分别是两个单例。</span></span><br><span class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</span><br><span class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithCache:cache downloader:downloader];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>下载流程<br>SDWebImageManager(单例) -&gt; SDWebImageCombinedOperation<sdwebimageoperation>-&gt; {SDImageCache(单例)-&gt;queryCache-&gt;if no -&gt;SDWebImageDownloader(单例)-&gt;downloadImage}</sdwebimageoperation></p>
</li>
<li><p>图片异步下载的实现（包括单个下载的请求组装，状态控制，回调处理，图片预解压等）</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">///sd里面实现了一个SDWebImageDownloaderOperation的具体类。是命令模式的一种应用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///这里实现了二个协议，第一个协议实际上是包含了urlsession的两个系统协议。后面贴上。这里比较重要的是，如果你看SDWebImageDownloader的实现文件，你会发现，也实现了&lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;协议。</span></span><br><span class="line"><span class="comment">////@interface SDWebImageDownloader () &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;，并在SDWebImageDownloader中统一把事情回调到SDWebImageDownloaderOperation类中。这样能使类的职责更清晰，图片解压后续等处理能封装到具体的SDWebImageDownloaderOperation类中，更合适而更内聚。</span></span><br><span class="line">例如</span><br><span class="line">===========</span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    <span class="built_in">NSOperation</span>&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = [<span class="keyword">self</span> operationWithTask:task];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation respondsToSelector:<span class="keyword">@selector</span>(URLSession:task:didCompleteWithError:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session task:task didCompleteWithError:error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===========</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageDownloaderOperation</span> : <span class="title">NSOperation</span> &lt;<span class="title">SDWebImageDownloaderOperationInterface</span>, <span class="title">SDWebImageOperation</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The request used by the operation's task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLRequest</span> *request;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The operation's task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSessionTask</span> *dataTask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Was used to determine whether the URL connection should consult the credential storage for authenticating the connection.</span></span><br><span class="line"><span class="comment"> *  @deprecated Not used for a couple of versions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> shouldUseCredentialStorage __deprecated_msg(<span class="string">"Property deprecated. Does nothing. Kept only for backwards compatibility"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The credential used for authentication challenges in `-URLSession:task:didReceiveChallenge:completionHandler:`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This will be overridden by any shared credentials that exist for the username or password of the request URL, if present.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLCredential</span> *credential;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The SDWebImageDownloaderOptions for the receiver.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDWebImageDownloaderOptions options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The expected size of data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> expectedSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The response returned by the operation's task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLResponse</span> *response;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Initializes a `SDWebImageDownloaderOperation` object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @see SDWebImageDownloaderOperation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param request        the URL request</span></span><br><span class="line"><span class="comment"> *  @param session        the URL session in which this operation will run</span></span><br><span class="line"><span class="comment"> *  @param options        downloader options</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return the initialized instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                              inSession:(<span class="keyword">nullable</span> <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Adds handlers for progress and completion. Returns a tokent that can be passed to -cancel: to cancel this set of</span></span><br><span class="line"><span class="comment"> *  callbacks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param progressBlock  the block executed when a new chunk of data arrives.</span></span><br><span class="line"><span class="comment"> *                        @note the progress block is executed on a background queue</span></span><br><span class="line"><span class="comment"> *  @param completedBlock the block executed when the download is done.</span></span><br><span class="line"><span class="comment"> *                        @note the completed block is executed on the main queue for success. If errors are found, there is a chance the block will be executed on a background queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return the token to use to cancel this set of handlers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Cancels a set of callbacks. Once all callbacks are canceled, the operation is cancelled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param token the token representing a set of callbacks to cancel</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return YES if the operation was stopped because this was the last token to be canceled. NO otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">///取消操作</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)cancel:(<span class="keyword">nullable</span> <span class="keyword">id</span>)token;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SDWebImageDownloaderOperationInterface继承了&lt;<span class="built_in">NSURLSessionTaskDelegate</span>, <span class="built_in">NSURLSessionDataDelegate</span>&gt;协议。</span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageDownloaderOperationInterface</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>, <span class="title">NSURLSessionDataDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                              inSession:(<span class="keyword">nullable</span> <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldDecompressImages;</span><br><span class="line">- (<span class="keyword">void</span>)setShouldDecompressImages:(<span class="built_in">BOOL</span>)value;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLCredential</span> *)credential;</span><br><span class="line">- (<span class="keyword">void</span>)setCredential:(<span class="keyword">nullable</span> <span class="built_in">NSURLCredential</span> *)value;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)cancel:(<span class="keyword">nullable</span> <span class="keyword">id</span>)token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionTask</span> *)dataTask;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">图片解压部分，使用了面相协议的方式把多个类型的图片解压方法分散到各个具体类中。贴近于工厂模式，创建多个产品。并使用统一的一套接口，使调用者只面向抽象接口调用，不面向具体的类接口调用，利于具体类的切换。</span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageCoder</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"><span class="meta">#pragma mark - Decoding</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canDecodeFromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decodedImageWithData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decompressedImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">                                            data:(<span class="built_in">NSData</span> * _Nullable * _Nonnull)data</span><br><span class="line">                                         options:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span>*, <span class="built_in">NSObject</span>*&gt;*)optionsDict;</span><br><span class="line"><span class="meta">#pragma mark - Encoding</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canEncodeToFormat:(SDImageFormat)format;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encodedDataWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image format:(SDImageFormat)format;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">实现协议的具体类</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageGIFCoder</span> : <span class="title">NSObject</span> &lt;<span class="title">SDWebImageCoder</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageCodersManager</span> : <span class="title">NSObject</span>&lt;<span class="title">SDWebImageCoder</span>&gt;</span></span><br></pre></td></tr></table></figure>


<ul>
<li><p>请求并发控制。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation <span class="keyword">class</span>];</span><br><span class="line">        _shouldDecompressImages = <span class="literal">YES</span>;</span><br><span class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</span><br><span class="line">        _downloadQueue = [<span class="built_in">NSOperationQueue</span> new];</span><br><span class="line">        <span class="comment">///并发控制，利用了苹果封装的queue提供的功能</span></span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = <span class="number">6</span>;</span><br><span class="line">        _downloadQueue.name = <span class="string">@"com.hackemist.SDWebImageDownloader"</span>;</span><br><span class="line">        _URLOperations = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        SDHTTPHeadersMutableDictionary *headerDictionary = [SDHTTPHeadersMutableDictionary dictionary];</span><br><span class="line">        <span class="built_in">NSString</span> *userAgent = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">///组装userAgent头</span></span><br><span class="line"><span class="meta">#if SD_UIKIT</span></span><br><span class="line">        <span class="comment">// User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43</span></span><br><span class="line">        userAgent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/%@ (%@; iOS %@; Scale/%0.2f)"</span>, [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleExecutableKey] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleIdentifierKey], [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"CFBundleShortVersionString"</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleVersionKey], [[<span class="built_in">UIDevice</span> currentDevice] model], [[<span class="built_in">UIDevice</span> currentDevice] systemVersion], [[<span class="built_in">UIScreen</span> mainScreen] scale]];</span><br><span class="line"><span class="meta">#elif SD_WATCH</span></span><br><span class="line">        <span class="comment">// User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43</span></span><br><span class="line">        userAgent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/%@ (%@; watchOS %@; Scale/%0.2f)"</span>, [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleExecutableKey] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleIdentifierKey], [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"CFBundleShortVersionString"</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleVersionKey], [[<span class="built_in">WKInterfaceDevice</span> currentDevice] model], [[<span class="built_in">WKInterfaceDevice</span> currentDevice] systemVersion], [[<span class="built_in">WKInterfaceDevice</span> currentDevice] screenScale]];</span><br><span class="line"><span class="meta">#elif SD_MAC</span></span><br><span class="line">        userAgent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/%@ (Mac OS X %@)"</span>, [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleExecutableKey] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleIdentifierKey], [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"CFBundleShortVersionString"</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleVersionKey], [[<span class="built_in">NSProcessInfo</span> processInfo] operatingSystemVersionString]];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        <span class="keyword">if</span> (userAgent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (![userAgent canBeConvertedToEncoding:<span class="built_in">NSASCIIStringEncoding</span>]) &#123;</span><br><span class="line">                <span class="built_in">NSMutableString</span> *mutableUserAgent = [userAgent mutableCopy];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">CFStringTransform</span>((__bridge <span class="built_in">CFMutableStringRef</span>)(mutableUserAgent), <span class="literal">NULL</span>, (__bridge <span class="built_in">CFStringRef</span>)<span class="string">@"Any-Latin; Latin-ASCII; [:^ASCII:] Remove"</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                    userAgent = mutableUserAgent;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            headerDictionary[<span class="string">@"User-Agent"</span>] = userAgent;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#ifdef SD_WEBP</span></span><br><span class="line">        headerDictionary[<span class="string">@"Accept"</span>] = <span class="string">@"image/webp,image/*;q=0.8"</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">        headerDictionary[<span class="string">@"Accept"</span>] = <span class="string">@"image/*;q=0.8"</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">        _HTTPHeaders = headerDictionary;</span><br><span class="line">        _operationsLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _headersLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _downloadTimeout = <span class="number">15.0</span>;</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> createNewSessionWithConfiguration:sessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片缓存机制的实现</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns</span><br><span class="line">                       diskCacheDirectory:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)directory &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *fullNamespace = [<span class="string">@"com.hackemist.SDWebImageCache."</span> stringByAppendingString:ns];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Create IO serial queue</span></span><br><span class="line">        <span class="comment">///串行队列,保证读写安全</span></span><br><span class="line">        _ioQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageCache"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        </span><br><span class="line">        _config = [[SDImageCacheConfig alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Init the memory cache</span></span><br><span class="line">        <span class="comment">///内存缓存管理</span></span><br><span class="line">        _memCache = [[SDMemoryCache alloc] initWithConfig:_config];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Init the disk cache</span></span><br><span class="line">        <span class="keyword">if</span> (directory != <span class="literal">nil</span>) &#123;</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(_ioQueue, ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.fileManager = [<span class="built_in">NSFileManager</span> new];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="meta">#if SD_UIKIT</span></span><br><span class="line">        <span class="comment">// Subscribe to app events</span></span><br><span class="line">        <span class="comment">////deleteOldFiles 与 backgroundDeleteOldFiles是内存和磁盘安全管理策略的执行方法</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(deleteOldFiles)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationWillTerminateNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(backgroundDeleteOldFiles)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>磁盘管理的安全策略</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)deleteOldFiles &#123;</span><br><span class="line">    [<span class="keyword">self</span> deleteOldFilesWithCompletionBlock:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)deleteOldFilesWithCompletionBlock:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute content date key to be used for tests</span></span><br><span class="line">        <span class="built_in">NSURLResourceKey</span> cacheContentDateKey = <span class="built_in">NSURLContentModificationDateKey</span>;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.config.diskCacheExpireType) &#123;</span><br><span class="line">            <span class="keyword">case</span> SDImageCacheConfigExpireTypeAccessDate:</span><br><span class="line">                cacheContentDateKey = <span class="built_in">NSURLContentAccessDateKey</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SDImageCacheConfigExpireTypeModificationDate:</span><br><span class="line">                cacheContentDateKey = <span class="built_in">NSURLContentModificationDateKey</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, cacheContentDateKey, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This enumerator prefetches useful properties for our cache files.</span></span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [<span class="keyword">self</span>.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></span><br><span class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span>.config.maxCacheAge];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *&gt; *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enumerate all of the files in the cache directory.  This loop has two purposes:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  1. Removing files that are older than the expiration date.</span></span><br><span class="line">        <span class="comment">//  2. Storing file attributes for the size-based cleanup pass.</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error;</span><br><span class="line">            <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Skip directories and errors.</span></span><br><span class="line">            <span class="keyword">if</span> (error || !resourceValues || [resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove files that are older than the expiration date;</span></span><br><span class="line">            <span class="built_in">NSDate</span> *modifiedDate = resourceValues[cacheContentDateKey];</span><br><span class="line">            <span class="keyword">if</span> ([[modifiedDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Store a reference to this file and account for its total size.</span></span><br><span class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">            cacheFiles[fileURL] = resourceValues;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If our remaining disk cache exceeds a configured maximum size, perform a second</span></span><br><span class="line">        <span class="comment">// size-based cleanup pass.  We delete the oldest files first.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.config.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.config.maxCacheSize) &#123;</span><br><span class="line">            <span class="comment">// Target half of our maximum cache size for this cleanup pass.</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.config.maxCacheSize / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sort the remaining cache files by their last modification time or last access time (oldest first).</span></span><br><span class="line">            <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></span><br><span class="line">                                                                     usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">                                                                         <span class="keyword">return</span> [obj1[cacheContentDateKey] compare:obj2[cacheContentDateKey]];</span><br><span class="line">                                                                     &#125;];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Delete files until we fall below our desired cache size.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">                    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他线程安全的处理，锁的应用</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">LOCK(<span class="params">lock</span>)</span> dispatch<span class="constructor">_semaphore_wait(<span class="params">lock</span>, DISPATCH_TIME_FOREVER)</span>;</span><br><span class="line">#define <span class="constructor">UNLOCK(<span class="params">lock</span>)</span> dispatch<span class="constructor">_semaphore_signal(<span class="params">lock</span>)</span>;</span><br><span class="line"><span class="comment">///多线程中读写安全，通过锁保证，主要是数组和字典的读写操作安全；并包含其操作的整个代码段都要通过加锁保证其原子性。</span></span><br><span class="line">例子</span><br><span class="line">  <span class="constructor">LOCK(<span class="params">self</span>.<span class="params">weakCacheLock</span>)</span>;</span><br><span class="line">        <span class="comment">// Do the real copy of the key and only let NSMapTable manage the key's lifetime</span></span><br><span class="line">        <span class="comment">// Fixes issue #2507 https://github.com/SDWebImage/SDWebImage/issues/2507</span></span><br><span class="line">        <span class="literal">[<span class="identifier">self</span>.<span class="identifier">weakCache</span> <span class="identifier">setObject</span>:<span class="identifier">obj</span> <span class="identifier">forKey</span>:[[<span class="identifier">key</span> <span class="identifier">mutableCopy</span>]</span> copy]];</span><br><span class="line">        <span class="constructor">UNLOCK(<span class="params">self</span>.<span class="params">weakCacheLock</span>)</span>;</span><br><span class="line">=====</span><br><span class="line">  <span class="constructor">LOCK(<span class="params">self</span>.<span class="params">headersLock</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        self.HTTPHeaders<span class="literal">[<span class="identifier">field</span>]</span> = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">[<span class="identifier">self</span>.HTTPH<span class="identifier">eaders</span> <span class="identifier">removeObjectForKey</span>:<span class="identifier">field</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">UNLOCK(<span class="params">self</span>.<span class="params">headersLock</span>)</span>;</span><br><span class="line">    </span><br><span class="line">======</span><br><span class="line">    <span class="constructor">LOCK(<span class="params">self</span>.<span class="params">callbacksLock</span>)</span>;</span><br><span class="line">    NSMutableArray&lt;id&gt; *callbacks = <span class="literal">[[<span class="identifier">self</span>.<span class="identifier">callbackBlocks</span> <span class="identifier">valueForKey</span>:<span class="identifier">key</span>]</span> mutableCopy];</span><br><span class="line">    <span class="constructor">UNLOCK(<span class="params">self</span>.<span class="params">callbacksLock</span>)</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">///外观模式(通过face层去调用，内部调用更高级的子系统接口。)</span></span><br><span class="line">提供多个外部接口，内部通过调用一个更高级的子接口来现实。</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIImageView</span> (<span class="title">WebCache</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br><span class="line">          </span><br><span class="line">=======</span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line"><span class="comment">///多级调用</span></span><br><span class="line">    [<span class="keyword">self</span> sd_setImageWithURL:url placeholderImage:<span class="literal">nil</span> options:<span class="number">0</span> progress:<span class="literal">nil</span> completed:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder &#123;</span><br><span class="line">    [<span class="keyword">self</span> sd_setImageWithURL:url placeholderImage:placeholder options:<span class="number">0</span> progress:<span class="literal">nil</span> completed:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、使用的设计模式"><a href="#四、使用的设计模式" class="headerlink" title="四、使用的设计模式"></a>四、使用的设计模式</h5><p>单例模式、命令模式、工厂模式、外观模式</p>
<h5 id="五、利用语言特性的相关技巧"><a href="#五、利用语言特性的相关技巧" class="headerlink" title="五、利用语言特性的相关技巧"></a>五、利用语言特性的相关技巧</h5><ul>
<li>runtime关联对象</li>
<li>信号量作为锁的使用</li>
</ul>
<h5 id="六、SDWebImage官方类图"><a href="#六、SDWebImage官方类图" class="headerlink" title="六、SDWebImage官方类图"></a>六、SDWebImage官方类图</h5><p><img src="/personImg/SDWebImageClassDiagram.png" alt="SDWebImageClassDiagram.png"></p>
<h5 id="七、SDWebImage官方时序图"><a href="#七、SDWebImage官方时序图" class="headerlink" title="七、SDWebImage官方时序图"></a>七、SDWebImage官方时序图</h5><p><img src="/personImg/SDWebImageSequenceDiagram.png" alt="SDWebImageSequenceDiagram.png"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">liang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zengbailiang.cn/2019-03-10sdimage设计分析.html">https://zengbailiang.cn/2019-03-10sdimage设计分析.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zengbailiang.cn">liang's blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/源码阅读/">源码阅读</a><a class="post-meta__tags" href="/tags/设计分析/">设计分析</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019-07-14安全思考.html"><i class="fa fa-chevron-left">  </i><span>iOS 移动端 安全思考与总结</span></a></div><div class="next-post pull-right"><a href="/2019-01-01-2018总结泛篇.html"><span>2018年终总结泛篇</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/personImg/topimg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By liang</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>