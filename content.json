{"meta":{"title":"liang's blog","subtitle":null,"description":"知行合一","author":"liang","url":"https://zengbailiang.cn","root":"/"},"pages":[{"title":"404","date":"2018-07-18T15:19:00.000Z","updated":"2018-07-18T15:19:00.542Z","comments":true,"path":"404/index.html","permalink":"https://zengbailiang.cn/404/index.html","excerpt":"","text":""},{"title":"about","date":"2018-07-18T15:18:31.000Z","updated":"2019-12-15T04:56:27.733Z","comments":true,"path":"about/index.html","permalink":"https://zengbailiang.cn/about/index.html","excerpt":"","text":"iOS developer To contact me： wechat:liang22years e-mail:634825162@qq.com github:https://github.com/zmubai Best wishes and Best regardsPLAN DO CHECK ADJUST. DO AS YOU TRY TO KNOW."},{"title":"categories","date":"2019-12-15T03:32:32.000Z","updated":"2019-12-15T04:52:06.495Z","comments":true,"path":"categories/index.html","permalink":"https://zengbailiang.cn/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-12-08T04:46:05.000Z","updated":"2019-12-08T04:46:05.715Z","comments":true,"path":"friends/index.html","permalink":"https://zengbailiang.cn/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-04T16:00:00.000Z","updated":"2019-12-15T01:16:29.164Z","comments":true,"path":"tags/index.html","permalink":"https://zengbailiang.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"仙湖植物园一游","slug":"xianhuzhiwuyuan","date":"2019-12-20T16:00:00.000Z","updated":"2019-12-26T14:17:21.844Z","comments":true,"path":"xianhuzhiwuyuan.html","link":"","permalink":"https://zengbailiang.cn/xianhuzhiwuyuan.html","excerpt":"仙湖植物园一游冬日里，游园有一番趣味。有一种安逸恬静的感觉。特别是天气冷的刚好，与友人一起慢慢的漫步干净的泊油路上，呼吸清新的空气，无论谈笑风生，或者静静的欣赏风景，都是一大乐事。还有这种美好的体验，会留在我们的记忆中成为了回忆。","text":"仙湖植物园一游冬日里，游园有一番趣味。有一种安逸恬静的感觉。特别是天气冷的刚好，与友人一起慢慢的漫步干净的泊油路上，呼吸清新的空气，无论谈笑风生，或者静静的欣赏风景，都是一大乐事。还有这种美好的体验，会留在我们的记忆中成为了回忆。 这里帮一家人拍照，感觉生涩和开心。那是一家人，两个老人家，还有他们的女儿和双胞胎外孙女，小孩子的妈妈说“快点过来，哥哥帮我们拍照了。” 哈哈，听到还能被叫哥哥，好开心。可惜等了片刻，小孩子好像被什么好玩的吸引了，玩得不亦乐乎，没有过来拍照。 感觉这个画面好美，有天空的蓝，湖水的青，水杉的红，人和景色融合得很美。 冬日恬静 冬日恬静 正在上阶梯的女孩，一种冬日恬静的美感。","categories":[{"name":"记事","slug":"记事","permalink":"https://zengbailiang.cn/categories/记事/"}],"tags":[{"name":"散文","slug":"散文","permalink":"https://zengbailiang.cn/tags/散文/"}]},{"title":"124. 二叉树中的最大路径和","slug":"124. 二叉树中的最大路径和","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-16T14:57:04.034Z","comments":true,"path":"124. 二叉树中的最大路径和.html","link":"","permalink":"https://zengbailiang.cn/124. 二叉树中的最大路径和.html","excerpt":"","text":"124. 二叉树中的最大路径和给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。示例 1:输入: [1,2,3] 1 / \\ 2 3输出: 6示例 2:输入: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7输出: 42 解：使用dfs递归遍历树。 A / \\B C 拿一个完整的最简单的二叉树结构单元进行分析。使用dsp遍历回到根节点的时候，存在3种情况的路径，分别是 A + left A + right A 那么对于节点A , 其最大路径取三者中最大值。然后继续递归返回。这种情况是作为一个大的路径的部分返回到父节点，继续递归返回。 如果 但最大路径有可能在遍历的任意一次产生，分4种情况 只取root root + left root + right root + left + right 取较大者。要存储和更新这个值，可能通过全局变量，或把指针作为函数参数传入。 int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int maxExitPathSum;int pathSum(TreeNode* root) &#123; if (root == NULL) &#123; return 0; &#125; int l = pathSum(root -&gt; left); int r = pathSum(root -&gt; right); int pathSum = max(max(root -&gt; val,root -&gt; val + max(l,r)),root -&gt; val + l + r); maxExitPathSum = max(maxExitPathSum,pathSum); return max(root -&gt; val, max(l,r) + root -&gt; val);&#125;int maxPathSum(TreeNode* root) &#123; maxExitPathSum = INT_MIN; pathSum(root); return maxExitPathSum;&#125; 这道题，开始想就是这种思路，但看错题目了，把可以不包含根节点，看成允许存在路径和 left + right。导致了很多没必要的考虑和没用的代码判断。记录下！！！！ 审题很重要！！！！","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"236. 二叉树的最近公共祖先","slug":"236. 二叉树的最近公共祖先","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-16T14:57:02.440Z","comments":true,"path":"236. 二叉树的最近公共祖先.html","link":"","permalink":"https://zengbailiang.cn/236. 二叉树的最近公共祖先.html","excerpt":"","text":"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 解：p ,q 分别为两个的子节点。使用bsf。在遍历的过程值，函数设定返回一个节点。可以这样设定： 如果仅仅找到p 或q，那么把其返回。 那么如果 left 和right 都有值返回，代表两个节点，分别在两边找到，此时的父节点就是他们的最近公共祖先。 如果仅仅一边有值，那么继续把值为p或q向上传递。 具体代码注释如下： // 如果找到其中一个那么返回找到的那个，如果两个都找不到返回null， 如果两个都找到返回最近公共祖先TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == NULL) &#123; return NULL; &#125; else if (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &#123; return root; &#125; else&#123; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if(left != NULL &amp;&amp; right != NULL)&#123; //如果left right 分别有值，那么必然是左右分别找到两个节点。 return root; &#125; else if(left != NULL)&#123; return left; &#125; else&#123; // right有值 或为NULL return right; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"148. 排序链表","slug":"148. 排序链表","date":"2019-12-09T16:00:00.000Z","updated":"2019-12-11T15:00:42.276Z","comments":true,"path":"148. 排序链表.html","link":"","permalink":"https://zengbailiang.cn/148. 排序链表.html","excerpt":"","text":"在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。示例 1:输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4示例 2:输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解1：自底向上的分析过程，局部排序到整体排序。1-》2-》4-》x （x&gt;=size） 描述下主要过程： 获取链长度，从而能确定循环的结束条件。当size == len -1的时候为循环的最后一次。 循环过程：size属于[1,len -1]。内循环对链表以size进行分割成长度为size的left right ，已经剩下部分的cur，并用tail拼接left、right合并后的部分。cur继续以size切换进行内内循环，直到以size为大小的局部排序结束，同时tail指向dummyHead的地址，因此获取dummyHead.next为上次局部排序后的链表，继续外内循环，直到结束。最后返回dummyHead.next。（代码中使用preHead,表示dummyHead，dummyHead感觉是个很炫酷的技巧，能通过.next获取头指针，又能通过 tail = &amp;dummyHead，让dummyHead.next一直都是新的表头）。 此方法重点是思路，dummyHead等。 ListNode* sortList(ListNode* head) &#123; ListNode preHead(0); preHead.next = head; auto p = head; int len = 0; while (p != NULL &amp;&amp; ++len) &#123; p = p -&gt; next; &#125; for (int size = 1; size &lt; len; size &lt;&lt;= 1) &#123; auto cur = preHead.next; auto tail = &amp;preHead; while (cur != NULL) &#123; auto left = cur; auto right = cut(cur, size); cur = cut(right, size); auto p = merge(left,right); while (p) &#123; tail -&gt; next = p; //偏移到当前节点 tail = p; p = p -&gt; next; &#125; &#125; &#125; return preHead.next;&#125; 解2：自顶而下，使用递归归并排序。 使用快慢指针来，切分链表。 涉及操作： low fast 指针二分。 cut ，切断链表。 赋NULL操作 merge 。合并链表，dummyHead，尾指针别忘记指向最后的元素。 ListNode* sortList(ListNode* head) &#123; if (head == NULL || head -&gt; next == NULL) &#123; return head; &#125; ListNode *low = head; //fast 要使用head -&gt; next。使用不当，会导致临界情况出现死循环。如果 left = [1,2] ----&gt; left = [1,2]--&gt;....。 //要保证两个元素的时候正确切分成 left 1 right 2。因此这里的快慢指针写法是有很严谨的逻辑要求的。 ListNode *fast = head -&gt; next; while (fast != NULL) &#123; fast = fast -&gt; next; if (fast == NULL) &#123; break; &#125; fast = fast -&gt; next; low = low -&gt; next; &#125; ListNode *right = low -&gt; next; ListNode *left = head; low -&gt; next = NULL; // left = sortList(left); // right = sortList(right); return merge(sortList(left),sortList(right));&#125; //comm funListNode* cut(ListNode* list,int gap)&#123; while (list != NULL &amp;&amp; --gap) &#123; list = list -&gt;next; &#125; if (list == NULL ) &#123; return NULL;&#125; auto p = list -&gt; next; //赋NULL，切断链表 list -&gt; next = NULL; return p;&#125;///双指针合并ListNode* merge(ListNode* h1,ListNode* h2)&#123; ListNode prehead(0); auto res = &amp;prehead; while (h1 != NULL &amp;&amp; h2 != NULL) &#123; if (h1 -&gt; val &lt; h2 -&gt; val)&#123; res -&gt; next = h1; //偏移到当前节点 res = h1; h1 = h1 -&gt; next; &#125; else &#123; res -&gt; next = h2; //偏移到当前节点 res = h2; h2 = h2 -&gt; next; &#125; &#125; res -&gt; next = h1 != NULL ? h1 : h2 ; return prehead.next;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"146. LRU缓存机制","slug":"146. LRU缓存机制","date":"2019-12-07T16:00:00.000Z","updated":"2019-12-16T14:06:38.776Z","comments":true,"path":"146. LRU缓存机制.html","link":"","permalink":"https://zengbailiang.cn/146. LRU缓存机制.html","excerpt":"","text":"运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 解：使用双向链表来快速处理和调整，最近使用的元素. put 分两种情况，如果存在，那么把已有元素调整到链头（拿出，删除，在插入）；如果不存在，直接插入。 获取元素类似，存在，那么调整到头并返回。不存在那么返回-1； class LRUCache &#123;public: LRUCache(int capacity) &#123; maxSize = capacity; &#125; int get(int key) &#123; if (m.find(key) != m.end())&#123; //iterator通过*获取当前元素 pair&lt;int, int&gt; p = *m[key]; llist.erase(m[key]); llist.push_front(p); //赋值新的iterator m[key] = llist.begin(); return p.second; &#125; return -1; &#125; void put(int key, int value) &#123; if (m.find(key) != m.end()) &#123; llist.erase(m[key]); llist.push_front(make_pair(key, value)); m[key] = llist.begin(); &#125; else &#123; if (m.size() == maxSize) &#123; m.erase(m.find(llist.back().first)); llist.pop_back(); &#125; llist.push_front(make_pair(key, value)); m[key] = llist.begin(); &#125; &#125; private: //pair &lt;key,value&gt; list&lt;pair&lt;int, int&gt;&gt; llist; //unordered_map unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; m; int maxSize; /** list 的方法 最后元素.back() 弹出元素pop_back pop_front() 删除erase(const *type vale) 插入 push_back()、push_front() 获取iterator 对于的元素 可以解引用 本题 pair&lt;int, int&gt; p = *m[key]; //m[key] 为iterator */&#125;; 主要用到双向链表，使插入查找的时间复杂度达到了O（1）。对于iterator 作为元素的相关操作不熟悉，记录下。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"238. 除自身以外数组的乘积","slug":"238. 除自身以外数组的乘积","date":"2019-12-02T16:00:00.000Z","updated":"2019-12-09T13:10:32.852Z","comments":true,"path":"238. 除自身以外数组的乘积.html","link":"","permalink":"https://zengbailiang.cn/238. 除自身以外数组的乘积.html","excerpt":"","text":"给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。示例:输入: [1,2,3,4]输出: [24,12,8,6]说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 解： 暴力法。两层循环。 时间复杂度为O(n^2)。 除自身外的乘积，等于其左边元素的乘积 和 其右边元素的乘积 的 乘积。使用两个临时数组分别保存对应下标其左边的元素积和右边元素的积。由于只是遍历两次，并没有循环嵌套，所以时间复杂度为O(n)。 vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res (nums.size() ,1); int temp = 1; for (int i = 0; i &lt; nums.size(); ++ i) &#123; res[i] = temp; temp *= nums[i]; &#125; temp = 1; for (int i = (int)nums.size() - 1; i &gt;= 0; -- i) &#123; res[i] *= temp; temp *= nums[i]; &#125; return res;&#125; //优化版本，使用一个循环即可vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int size = (int)nums.size(); vector&lt;int&gt; res (size, 1); int left = 1; int right = 1; for (int i = 0; i &lt; size; i ++) &#123; res[i] *= left; left *= nums[i]; int j = size - 1 - i; res[j] *= right; right *= nums[j]; &#125; return res;&#125; 上面此思路不太好想到。我的初始思路是这样的，最后一个测试案例超时了，O(n^2)。顺便记录一下，作为一个对比的参照。 vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt;= 0) &#123; return nums; &#125; vector&lt;int&gt; res (nums.size() , 0); if (nums.size() &lt; 2) &#123; res[0] = nums[0]; return res; &#125; res[0] = 1; res[1] = nums[0]; for (int i = 1; i &lt; nums.size(); i ++) &#123; for (int j = 0; j &lt;= i; j ++) &#123; if(i == j &amp;&amp; i &lt; nums.size()) &#123; if(j + 1 &lt; nums.size()) &#123; res[j+1] = res[j] * nums[i]; &#125; continue; &#125; else &#123; res[j] *= nums[i]; &#125; &#125; &#125; return res;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"33. 搜索旋转排序数组","slug":"33. 搜索旋转排序数组","date":"2019-11-25T16:00:00.000Z","updated":"2019-11-26T16:11:41.657Z","comments":true,"path":"33. 搜索旋转排序数组.html","link":"","permalink":"https://zengbailiang.cn/33. 搜索旋转排序数组.html","excerpt":"","text":"假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解：由于题目说道数组是有序的，虽然做了旋转，且要求时间复杂度为logN，那么很容易会想到二分。 思路：存在旋转的分界点，其实就是数组旋转之前的起点。分界点的左边大于分界点，但分界点的左边和右边（包含分界点）都是两个有序的子数组。通过二分很容易确定这个分界点，然后根据target值与数组最后一个元素比较确定查找的子数组，如果小于最后元素，那么target只可能存在于右边子数组，相反存在与右边子数组，设计一个子函数二分查找并返回target在子数组的下标，如果找不到则返回-1. 另外查找分界点的时候可以做下剪枝，如果这个子数组没有旋转，也即是起点少于终点，那么直接使用子函数查找。 int indexInRange(vector&lt;int&gt;&amp; nums,int left,int right,int target)&#123; while (left&lt;=right) &#123; int mid = left + ((right - left) &gt;&gt;1); if (target == nums[mid]) &#123; return mid; &#125; else if(target &lt; nums[mid])&#123; right --; &#125; else&#123; left ++; &#125; &#125; return -1;&#125;int search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.size() == 0) &#123; return -1; &#125; if (nums[nums.size() -1] &gt;= nums[0]) &#123; //没有旋转 return indexInRange(nums,0,(int)nums.size() - 1,target); &#125; else&#123; //查找分界线， a,b a &gt;b； int left = 1; int right = (int)nums.size() - 1; while (left &lt;= right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if(nums[mid]&lt;nums[mid-1])&#123; //find cout &lt;&lt; mid&lt;&lt;\"\"; if (target &lt;= nums[nums.size() - 1]) &#123; return indexInRange(nums,mid,(int)nums.size()-1,target); &#125; else&#123; return indexInRange(nums,0,mid - 1,target); &#125; &#125; else&#123; if(nums[mid] &gt; nums[right])&#123; left = mid + 1; &#125; else&#123; right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125; 题目给出了提示，有序，longN，容易想到二分。可论证正确思路，二分查找分界点，然后子数组在二分查找，返回结果。考验二分法的熟练度。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"16. 最接近的三数之和","slug":"16. 最接近的三数之和","date":"2019-11-24T16:00:00.000Z","updated":"2019-11-25T16:00:43.090Z","comments":true,"path":"16. 最接近的三数之和.html","link":"","permalink":"https://zengbailiang.cn/16. 最接近的三数之和.html","excerpt":"","text":"给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解1：比暴力法好一点，在最内层做了二分。时间复杂度依然很高 n2 *longn。 int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(),nums.end()); ///这个初始化是有问题的,对于lastBiger和smaller没有问题，但对于res是可能存在问题，有可能他是最大值的三倍，但刚好是最接近target的，如果这样程序就会错误。这里大概可以设置为MAX_INT 或 MIN_INT。 int undefine = nums[nums.size() - 1] * 3; int res = undefine; for (int i = 0 ; i &lt; nums.size() - 2; ++ i) &#123; for (int j = i+1; j &lt; nums.size() - 1; ++j) &#123; int dstValue = target - nums[i] - nums[j]; int left = j + 1; int right = (int)nums.size() - 1; int lastBigger = undefine; int lastSmaller = undefine; while (left &lt;= right) &#123; int mid = left + (right - left)/2; if (nums[mid] == dstValue) &#123; cout&lt;&lt;i&lt;&lt;\"*\"; cout&lt;&lt;j&lt;&lt;\"*\"; cout&lt;&lt;mid&lt;&lt;\"*\"; return target; &#125; else if(nums[mid] &gt; dstValue)&#123; lastBigger = nums[mid]; right --; &#125; else&#123; lastSmaller = nums[mid]; left++; &#125; &#125; int v3; if(lastBigger != undefine &amp;&amp; lastSmaller != undefine)&#123; int v0 = nums[i] + nums[j] + lastBigger; int v1 = nums[i] + nums[j] + lastSmaller; v3 = abs(target - v0) &lt; abs(target- v1) ? v0:v1; &#125; else if (lastSmaller == undefine)&#123; v3 = nums[i] + nums[j] + lastBigger; &#125; else if(lastBigger == undefine)&#123; v3 = nums[i] + nums[j] + lastSmaller; &#125; if (res == undefine) &#123; res = v3; &#125; else&#123; res = abs(target - res) &lt; abs(target- v3) ? res:v3; &#125; // cout &lt;&lt;res &lt;&lt;\"\"; &#125; &#125; return res;&#125;&#125; 解2首先排序是肯定需要的，思考解决方法的时候，比较重要的就是提供更多有利的假设，同时这些假设是能实现的，在各种条件能够被满足的情况下，探索题解，如果依然找不到方法，可见是思路不对或被卡主了。言归正传，在建立排序后，执行循环遍历，然后使用前后下标比较，获取更接近目标值的解。其中前后下标的移动依据和与目标值得大小关系，由于数组已经排序，所以如果比tager大，那么后下标左移，相反左下标右移动，这样和的大小才能更靠近tager。 int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for (int i = 0; i &lt; nums.size() - 2; ++ i) &#123; int left = i + 1; int right = (int)nums.size() - 1; while (left &lt; right) &#123; int r = nums[i] + nums[left] + nums[right]; res = abs(target - res) &lt; abs(target - r)?res:r; if (r &gt; target) &#123; --right; &#125; else if(r &lt; target)&#123; ++left; &#125; else&#123; return target; &#125; &#125; &#125; return res;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"15. 三数之和","slug":"15. 三数之和","date":"2019-11-22T16:00:00.000Z","updated":"2019-11-23T13:03:01.378Z","comments":true,"path":"15. 三数之和.html","link":"","permalink":"https://zengbailiang.cn/15. 三数之和.html","excerpt":"","text":"给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解：根据题目和例子，结果集是不允许重复的解，但数组中的元素可以重复利用。首先把问题由三个数和为0 转化为,求两个数和为第三个数相反数的问题，并在处理过程中，跳过重复的情况。 步骤：排序数组，从左边i遍历数组，左边i作为最小值。再开启两个下标left,right从两边查找，查找和为nums[i]的相反数。其中如果nums[i]&gt;0,那么就代表右边不可能存在解的可能，可以退出遍历。 而对于每一此遍历，会去查找以num[i]做为最小值的所有非重复解。当找到其中一个解后，做一些处理避免重复后，继续移动两个下标，查找下一组解。所以遍历结束后，可得所有解。 重复处理： 比较重要的去重处理是由两个部分组成。首先循环外判断num[i] 与num[i-1]，由于每一次遍历都会求得以num[i]作为最小值的全部解，所以这里相等就代表重复，跳过。 同理对于同一个num[i]，因为a +b +c = 0,任意两个数确定都代表第三个数确定，所以循环内跳过所有相同的nums[left]和nums[right]。 vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); if (nums.size() &lt; 3) &#123; return res; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; int v = nums[i]; if(v &gt; 0)&#123; break; &#125; else&#123; int target = 0 - nums[i]; if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) &#123;continue;&#125; int left = i + 1; int right = (int)nums.size() - 1; while (left &gt; i &amp;&amp; left&lt; right) &#123; if (nums[left] + nums[right] == target) &#123; vector&lt;int&gt; r; r.push_back(nums[i]); r.push_back(nums[left]); r.push_back(nums[right]); res.push_back(r); while (left&lt;right) &#123; if(nums[left + 1] == nums[left])&#123;left++;&#125; else&#123;break;&#125; &#125; while (left&lt;right) &#123; if(nums[right - 1] == nums[right])&#123;right --;&#125; else&#123;break;&#125; &#125; ++left;--right; &#125; else if(nums[left] + nums[right] &lt; target)&#123; left ++; &#125; else&#123; right --; &#125; &#125; &#125; &#125; return res;&#125; 关键： 排序。a +b +c = 0； 转化为 a+b = -c ; 去重处理。如何实现有效的去重并保证逻辑的正确。 两点都不难想到，但遍历一次查找以num[i]为最小值的全部解，并有效去重，不好想到（可能和会卡在每次查找一组解里）。里面有严谨的逻辑关系。也就是说因为是这样的遍历思路，才能配合这样的去重处理（跳过重复i,left,right）。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"1262. 可被三整除的最大和","slug":"435. 无重叠区间","date":"2019-11-20T16:00:00.000Z","updated":"2019-11-20T16:51:32.084Z","comments":true,"path":"435. 无重叠区间.html","link":"","permalink":"https://zengbailiang.cn/435. 无重叠区间.html","excerpt":"","text":"给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。 示例 1：输入：nums = [3,6,5,1,8]输出：18解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。示例 2：输入：nums = [4]输出：0解释：4 不能被 3 整除，所以无法选出数字，返回 0。 解:1.用sum累加所有数。同时使用两个数组，把余数为2和1的分别填充到其中，并对这两数组降序排序（因为要和最大，大的优先使用）。那么有了这两个基础上，结合问题，这个时候计算sum的余数，存在3中情况： 余数为0,直接返回sum. 余数为1，那么又存在两种情况，分别为减去余数为1数组中的最后一个或余数为2数组的最后两个，使sum最大，前提是其他们元素数量满足。 余数为2，那么又存在两种情况，分别为减去余数为2数组中的最后一个或余数为1数组的最后两个，使sum最大，前提是其他们元素数量满足。 static bool compDesc(int a,int b)&#123; return a &gt; b;&#125;int adjustSum(int rem ,int sum,vector&lt;int&gt; v1,vector&lt;int&gt; v2)&#123; if (rem == 1) &#123; if (v1.size() == 0) &#123; return sum - v2[v2.size() - 1] - v2[v2.size() - 2]; &#125; else if(v2.size()&lt;2)&#123; return sum - v1[v1.size() - 1]; &#125; else&#123; int del = min(v2[v2.size() - 1] + v2[v2.size() - 2], v1[v1.size() - 1]); return sum - del; &#125; &#125; else if(rem == 2)&#123; if (v1.size()&lt;2) &#123; return sum - v2[v2.size() - 1]; &#125; else if (v2.size() == 0)&#123; return sum - v1[v1.size() - 1] - v1[v1.size() - 2]; &#125; else&#123; int del = min(v2[v2.size() - 1],v1[v1.size() - 1] + v1[v1.size() - 2]); return sum - del; &#125; &#125; return 0;&#125;int maxSumDivThree(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; int sum =0; for (int i = 0; i &lt; nums.size(); ++i) &#123; sum += nums[i]; int r = nums[i] % 3; if(r == 1)&#123; v1.push_back(nums[i]); &#125; else if (r == 2)&#123; v2.push_back(nums[i]); &#125; &#125; sort(v1.begin(), v1.end(), compDesc); sort(v2.begin(), v2.end(), compDesc); if (sum % 3 == 1) &#123; return adjustSum(1,sum, v1, v2); &#125; else if (sum % 3 == 2)&#123; return adjustSum(2,sum, v1, v2); &#125; return sum; &#125; 难点思路的思考，如何使值最大。就会涉及到最后几个元素的取舍问题。我的想法是，用两个数组存储余1和余2，那么最后可能余1数组可能存在两种情况一个1 或两个1，因为满足3个1就可以加入到和中，余2数组也一样，剩下一个2或两个2.但这里就存在很多种组合了，而且余2和余1中的元素没有直接的大小关系，有可能还要退回去拿出之前加入的元素，这又把情况变得很复杂，最后也没想出解决的办法。这大概跟思维的方式和习惯有关系。如果发现死胡同后，这是后换个思路很重要。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"435. 无重叠区间","slug":"435. 无重叠区间的副本","date":"2019-11-20T16:00:00.000Z","updated":"2019-11-20T16:35:12.297Z","comments":true,"path":"435. 无重叠区间的副本.html","link":"","permalink":"https://zengbailiang.cn/435. 无重叠区间的副本.html","excerpt":"","text":"给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。注意:可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。示例 1:输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。示例 2:输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 解:步骤： 根据上限，进行升序排序。 遍历，选择一个区间a，与当前区间b（指向当前遍历的index）检测是否存在重叠。如果重叠重叠，那么选择上限较小的区间，并把其下标保存（更新区间a）,舍弃数+1。遍历结束返回结果。 static bool intervalsCompAsc(vector&lt;int&gt;a,vector&lt;int&gt;b)&#123; if (a[0]&lt;b[0]) &#123; return true; &#125; return false;&#125;int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; if (intervals.size() &lt;= 0) &#123; return 0; &#125; int len = 0; sort(intervals.begin(), intervals.end(), intervalsComp); /*贪心策略，选择区间上限更小的，为后面提供更多的空间。 1.没有重叠，继续下一轮循环。 2.如果有重叠，那么舍弃上限大的，选择上限小的。 **/ int last = 0; // cout&lt;&lt;intervals[0][0]&lt;&lt;\"\"; for (int i = 1 ; i &lt; intervals.size(); ++i) &#123; if (intervals[last][1]&lt;=intervals[i][0]) &#123; last = i; continue; &#125; else&#123; // cout&lt;&lt;intervals[i][0]&lt;&lt;\"\"; len ++; last = intervals[last][1] &lt;= intervals[i][1] ? last : i; &#125; &#125; return len;&#125; 这里用到了贪心思想，选择较小的上限，可以理解为为后面腾出更多的空间，这样就能容纳更多的区间。而问题来了，这贪心思想并不直观，内部逻辑的正确性，并不能直观感知，需要通过数学归纳证明。只有完全理解题解的思路，论证正确性，才能算是真正的完事。找了很多文章找到一遍较好的文章，先记录下来。区间调度问题详解 小结下，算法解题的几个阶段： 审题阶段。有些题目不好看懂，结合例子，需要花费片刻，理清题意。 寻找思路阶段。理清题意的前提下，去思考思路。有些题目，并不容易找到解题的关键，就会卡住。但如果没有一个可论证的思路，很难进入编码阶段，通常的暴露解法，至少也是一个可论证思路。所以这个阶段，是很重要的。练习的目的，很大程度是提高这个阶段的的能力。 编码阶段 。有了思路，考验编码能力，考验抽象逻辑代码化的能力，特别有些递归等思路不好实现，有些需要依赖合适的数据结构才能实现。例如用循环实现完全二叉树的后续遍历。 检查修正测试阶段 。检测代码的健壮性，正确性。 优化阶段 。优化时间，优化空间。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"1249. 移除无效的括号","slug":"1249. 移除无效的括号","date":"2019-11-18T16:00:00.000Z","updated":"2019-11-18T16:59:18.987Z","comments":true,"path":"1249. 移除无效的括号.html","link":"","permalink":"https://zengbailiang.cn/1249. 移除无效的括号.html","excerpt":"","text":"给你一个由 '('、')' 和小写字母组成的字符串 s。你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。请返回任意一个合法字符串。有效「括号字符串」应当符合以下 任意一条 要求：空字符串或只包含小写字母的字符串可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」 示例 1：输入：s = \"lee(t(c)o)de)\"输出：\"lee(t(c)o)de\"解释：\"lee(t(co)de)\" , \"lee(t(c)ode)\" 也是一个可行答案。 解1：利用栈来处理括号的匹配问题。遍历字符串，遇到”(“入栈，遇到”)”,那么需要查看栈里面是否为空，分两种情况： 如果栈不为空，那么存在匹配的”(“，那么出栈，继续遍历。 如果栈为空，那么此”)”找不到匹配，此”)”，必然是需要删除的，把其标记到map中。可能不同的思路处理的方式不一样，有些处理方式可能把其放入栈中，最后的时候在拿出来，删除。 最后获取到需要删除的map集合，创建临时字符串res，用于返回，遍历原字符串，并对比map是否存在，不存在的话，拼接到res中，遍历结束后返回res. map是为了提高对比的效率，空间换时间。看到有些题解，在第一次遍历的时候用特殊字符串例如*替换对应位置的字符，最后遍历的时候通过对比来判定，这样就不需要额外map来处理了。 string minRemoveToMakeValid(string s) &#123; stack&lt;int&gt; st; map&lt;int,int&gt; map; for (int i = 0; i &lt; s.length(); i ++) &#123; char c = s[i]; if (c == '(') &#123; st.push(i); &#125; else if(c == ')')&#123; if (!st.empty()) &#123; st.pop(); &#125; else&#123; map[i] = 1; &#125; &#125; &#125; while (!st.empty()) &#123; int i = st.top(); st.pop(); map[i] = 1; &#125; string res; for (int i = 0; i &lt; s.length(); i ++) &#123; if(map.find(i) == map.end())&#123; res.append(s[i],1); &#125; &#125; return res;&#125; 括号匹配，利用了栈，是此题关键。有时候某些问题，使用合适的数据结构，队列，栈、树等等，能很好的处理。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"807. 保持城市天际线","slug":"807. 保持城市天际线","date":"2019-11-18T16:00:00.000Z","updated":"2019-11-18T16:58:28.790Z","comments":true,"path":"807. 保持城市天际线.html","link":"","permalink":"https://zengbailiang.cn/807. 保持城市天际线.html","excerpt":"","text":"在二维数组grid中，grid[i][j]代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。 请看下面的例子。建筑物高度可以增加的最大总和是多少？例子：输入： grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]输出： 35解释： The grid is:[ [3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0] ]从数组竖直方向（即顶部，底部）看“天际线”是：[9, 4, 8, 7]从水平水平方向（即左侧，右侧）看“天际线”是：[8, 7, 9, 3]在不影响天际线的情况下对建筑物进行增高后，新数组如下：gridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] 解法一：对于每一行或每一列都存在一个边际值，而对于每一个做坐标点，它必须同时满足小于等于它所在的列和行的两个边际值，即其必须小于等于，所在行和列的边界值的最小值&lt;=min(边际值row,边际值col)，而增加的部分累计就是题目所求。基于这个思路，可得以下步骤: 定义两个临时数组用于存储行和列的边际值，通过遍历坐标点，更新这些值.一次遍历就可以获取到所有的边际值，[i]相同对比更新hSize，[j]相同对比更新vMaxArr。 再次遍历，累计增加值。 int maxIncreaseKeepingSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; long hSize = grid.size(); long vSize = grid[0].size(); vector&lt;int&gt; hMaxArr (hSize,0); vector&lt;int&gt; vMaxArr (vSize,0); //先获取 hMaxArr vMaxArr for (int i = 0; i &lt; hSize ; i ++) &#123; for (int j = 0 ; j &lt; vSize; j ++) &#123; if(grid[i][j]&gt;hMaxArr[i])&#123; hMaxArr[i] = grid[i][j]; &#125; if (grid[i][j]&gt;vMaxArr[j]) &#123; vMaxArr[j] = grid[i][j]; &#125; &#125; &#125; int res = 0; for (int i = 0; i &lt; hSize ; i ++) &#123; for (int j=0 ; j &lt; vSize; j ++) &#123; int minLimit = hMaxArr[i] &gt; vMaxArr[j] ? vMaxArr[j] : hMaxArr[i]; int mayAdd = minLimit - grid[i][j]; if(mayAdd)&#123; res += mayAdd; &#125; &#125; &#125; return res; &#125; 这道题的问题思路比较直观。不能超过边际线–》那么要知道每个坐标能到达的上限，其上限是什么？-》其上限就是其所在的行列边际值得最小值。 ==》解题开始，获取边际点，累计高，返回。 这种能有清晰的求解思路的题，相对好解。而有些题目，理清题目，并不容易想到可论证的正确思路（也即是可行思路），例如贪心算法之类的（435. 无重叠区间）。so解题前要尽量快速思考出思路，不断假设，提供条件，换思路等，找到可行思路。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"744. 寻找比目标字母大的最小字母","slug":"744. 寻找比目标字母大的最小字母","date":"2019-11-18T16:00:00.000Z","updated":"2019-11-18T16:57:17.817Z","comments":true,"path":"744. 寻找比目标字母大的最小字母.html","link":"","permalink":"https://zengbailiang.cn/744. 寻找比目标字母大的最小字母.html","excerpt":"","text":"给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。数组里字母的顺序是循环的。举个例子，如果目标字母target = 'z' 并且有序数组为 letters = ['a', 'b']，则答案返回 'a'。 解1:遍历，然后对比target,记录比target大且差值最小的元素的下标bigIndex，如果存在那么返回letters[bigIndex]。如果没有比traget大的元素，那么根据题意，字母是循环的，那么返回letters[0]。 char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123; int big = -1; int bigIndex = -1; for(int i = 0; i &lt; letters.size(); i ++)&#123; int len = letters[i] - target; if(len &gt;= 0) &#123; if(len &lt; big|| big == -1)&#123; big = len; bigIndex = i; &#125; &#125; &#125; if(big)&#123; return letters[big]; &#125; else&#123; return letters[0]; &#125;&#125; 解2由于输入是有序数组，那么可能会想到二分。二分就查找比target大的元素。 char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123; int left = 0; int right = (int)letters.size(); while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (mid&gt; 0 &amp;&amp; letters[mid - 1] &lt;= target &amp;&amp; letters[mid]&gt; target) &#123; return letters[mid]; &#125; else&#123; if (letters[mid]&lt;=target) &#123; //注意这里的条件，已经明确的判断出mid不符合要求。所以left = mid + 1; //mid，不符合要求，调整下限 left = mid + 1; &#125; else&#123; //此分支代表, letters[mid]&gt;target,需要调整上限，但mid依然有可能符合要求。 //mid有可能符合要求，调整上限 right = mid; &#125; &#125; &#125; return letters[0];&#125; 二分条件判断后，调整上下限时候是有非常严谨的逻辑的，例如+1还是-1，是否= mid等。另外有时候，二分是调整区间找坐标，有时候是给出特定的目标值，来查找坐标，情况很多。甚至二分的判断条件是一个函数，是一个以mid为入参的函数。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"leetcode 1123 最深叶节点的最近公共祖先","slug":"1123最深叶节点的最近公共祖先191115","date":"2019-11-14T16:00:00.000Z","updated":"2019-11-14T17:03:04.526Z","comments":true,"path":"1123最深叶节点的最近公共祖先191115.html","link":"","permalink":"https://zengbailiang.cn/1123最深叶节点的最近公共祖先191115.html","excerpt":"","text":"给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。回想一下：叶节点 是二叉树中没有子节点的节点树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1如果我们假定 A 是一组节点 S 的 最近公共祖先，&lt;font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"&gt;S&lt;/font&gt; 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。 示例 1：输入：root = [1,2,3]输出：[1,2,3]示例 2：输入：root = [1,2,3,4]输出：[4]示例 3：输入：root = [1,2,3,4,5]输出：[2,4,5] 提示：给你的树中将有 1 到 1000 个节点。树中每个节点的值都在 1 到 1000 之间。 解法一：最近公共祖先，是指，其下面的节点全部都是他的孩子。那么对应题目,有一种情况比较刺手，当存在不止一个分支的深度都等于树的最大深度，此时，就需要返回他们的共同祖先，而一般使用递归实现的时候，这个好像不好处理，开始这里卡了好久。正如代码所示，使用两个int指针记录分支的深度，当子递归返回时，对比两变量决定是否返回当前的root。 其他情况：1.root为空，返回root。2.存在一个分支的最深叶子，2.1叶子无兄弟节点，返回本身，2.2存在兄弟节点，返回其父节点。3.存在多分支最深叶子，就需要根据深度指针对比，判断和返回。（这个上面单独已经说明） struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;TreeNode* findDeepComm(TreeNode* root,int *deep)&#123; if (root != nullptr) &#123; *deep += 1; &#125; int *dL = (int*)malloc(sizeof(int)); int *dR = (int*)malloc(sizeof(int)); *dL = *deep; *dR = *deep; TreeNode *nl = root; if(root-&gt;left)&#123; nl = findDeepComm(root-&gt;left, dL); &#125; TreeNode *nr = root; if (root-&gt;right) &#123; nr = findDeepComm(root-&gt;right, dR); &#125; if (*dL == *dR) &#123; *deep = *dL; return root; &#125; else&#123; *deep = *dL &gt; *dR ? *dL:*dR; return *dL &gt; *dR ? nl : nr; &#125;&#125;TreeNode* lcaDeepestLeaves(TreeNode* root) &#123; int *deep = (int*)malloc(sizeof(int));; *deep = 0; return findDeepComm(root,deep);&#125; 后记：其实，根据题目给的例子，把我搞懵了。审题很重要，另外就是对递归的理解，小技巧，深度指针跟踪，递归中常用的小技巧。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"leetcode 887. 鸡蛋掉落","slug":"887. 鸡蛋掉落 191112","date":"2019-11-11T16:00:00.000Z","updated":"2019-11-12T15:24:35.257Z","comments":true,"path":"887. 鸡蛋掉落 191112.html","link":"","permalink":"https://zengbailiang.cn/887. 鸡蛋掉落 191112.html","excerpt":"","text":"887. 鸡蛋掉落你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。你的目标是确切地知道 F 的值是多少。无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？示例 1：输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。 解法一：动态规划。dp[i][j]表示i个鸡蛋 ,j层需要的次数。当某个时刻楼层为x,仍下鸡蛋，会出现两种情况1.鸡蛋碎了，那么调整范围dp[i-1][x-1]。2.鸡蛋没碎，那么调整范围dp[i][j-x]。 那么dp方程为:dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x]))(+1是因为计算上这本次扔鸡蛋)主要步骤： dp[i][j] 赋值保险值。例如100层，保险值就是100。等于j。 计算dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x]))。 返回dp[K][N]。 // Time Limit Exceededint superEggDrop(int K, int N) &#123; vector&lt;vector&lt;int&gt;&gt; dp(K + 1, vector&lt;int&gt;(N + 1)); for (int i = 1; i &lt;= N; i ++) &#123; dp[1][i] = i; &#125; //2 - K 个鸡蛋 for (int i = 2;i &lt;= K; ++i)&#123; // 1 - N 层 for (int j = 1; j &lt;= N; ++j) &#123; //赋值最大次数 dp[i][j] = j; //鸡蛋有可能在任何一层砸碎 for (int x = 1; x &lt; j; ++x) &#123; dp[i][j] = min(dp[i][j], 1 + max(dp[i][j - x], dp[i -1][x -1])); &#125; &#125; &#125; return dp[K][N];&#125; 此方法会超时，需要优化。下面采取二分优化。 解法二:int superEggDrop(int K, int N) &#123; vector&lt;vector&lt;int&gt;&gt; dp (K+1,vector&lt;int&gt;(N+1)); //赋基础值 for (int i = 1 ; i &lt;= N; ++i) &#123; dp[1][i] = i; &#125; //2 - K egg for (int i = 2; i &lt;= K; ++i) &#123; // 1 - N floor for (int j = 1; j &lt;= N; ++j) &#123; //赋保险值 dp[i][j] = j; int left = 1; int right = j; //二分查找临界点 while (left&lt;right) &#123; int mid = left + (right - left)/2; if (dp[i - 1][mid -1] &lt; dp[i][j - mid]) &#123; //mid 过小 向右偏移 left = mid + 1; &#125; else&#123; //mid 过大，向左偏移 right = mid; &#125; &#125; ///为什么最后right是临界点呢（ring保留mid,不让某些值缺失，但临界值为什么不能发生在left。。。；根据判断条件left&lt;right。可以理解为left一直增大，直到=&gt;right，那么退出循环，此时right就是临界值。这个过程如何一定保证right为临界值！！！），这里有点没想通。 dp[i][j] = min(dp[i][j], 1 + max(dp[i-1][right-1],dp[i][j-right])); &#125; &#125; return dp[K][N];&#125; 解法三再次优化，理论上楼层越多临界点越大，so临界点是一致递增的。 int superEggDrop(int K, int N) &#123; vector&lt;vector&lt;int&gt;&gt; dp (K+1,vector&lt;int&gt;(N+1)); //赋基础值 for (int i = 1 ; i &lt;= N; ++i) &#123; dp[1][i] = i; &#125; //2 - K egg for (int i = 2; i &lt;= K; ++i) &#123; // 1 - N floor int s = 1; for (int j = 1; j &lt;= N; ++j) &#123; //赋保险值 dp[i][j] = j; //随着楼层的增加 s会变大。（使用s递增，比解法二的临界值好理解很多，且很容易确定准确性） while (dp[i - 1][s -1] &lt; dp[i][j - s]) &#123; s++; &#125; dp[i][j] = min(dp[i][j], 1 + max(dp[i-1][s-1],dp[i][j-s])); &#125; &#125; return dp[K][N];&#125; 这种类型的题目，求最值得问题，很可能用到动态规划。且随着变量的递增，后面的结果依赖于之前的过程。抽象出dp方程比较重要。例如本题就比较难抽象，要完全理清题意，准确无误的抽象不容易： dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x])) dp[i][j],i egg ;j floor dp[i][j],保险值等于j 每次扔鸡蛋分两种情况，所以有max(dp[i-1][x-1],dp[i][j-x])，max是为了取最坏情况次数。加上当次扔鸡蛋， 所以有1 + max(dp[i-1][x-1],dp[i][j-x]) 最终有dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x])) 一般来说，有了初步的解题思路，再一步一步优化。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"leetcode 715. Range 模块","slug":"715. Range 模块191109","date":"2019-11-08T16:00:00.000Z","updated":"2019-11-10T08:03:55.929Z","comments":true,"path":"715. Range 模块191109.html","link":"","permalink":"https://zengbailiang.cn/715. Range 模块191109.html","excerpt":"","text":"715. Range 模块Range 模块是跟踪数字范围的模块。你的任务是以一种有效的方式设计和实现以下接口。addRange(int left, int right) 添加半开区间 [left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 [left, right) 中尚未跟踪的任何数字到该区间中。queryRange(int left, int right) 只有在当前正在跟踪区间 [left, right) 中的每一个实数时，才返回 true。removeRange(int left, int right) 停止跟踪区间 [left, right) 中当前正在跟踪的每个实数。addRange(10, 20): nullremoveRange(14, 16): nullqueryRange(10, 14): true （区间 [10, 14) 中的每个数都正在被跟踪）queryRange(13, 15): false （未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）queryRange(16, 17): true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪） 解法一：使用一个全局数组来存储已有的范围。对于添加，遍历数组，分两种情况判断，1.范围之间不存在交集，那么把rangs[i]加入到临时数组中；2.如果包含（被包含或包含）或者两者存在交集，那么更新left,right,值。重复该过程，直到遍历结束，此时把合成的left,right范围插入到临时数组中，赋值给全局数组，更新范围成功。对于删除，遍历数组，分三种情况判断，1.范围之间没有交集，那么把rangs[i]加入到临时数组中；2.如果存在交集（包括包含/被包含），这个时候，对范围进行拆分,那部分依然包含的范围加入到临时数组中，如果是包含的情况情况，要把两边的范围加入，如果是部分交集，只需把原范围不相交的一侧加入。在编码的时候，通过两个if处理了交集的情况。对于查询，就是遍历范围，判断边界，返回结果。 vector&lt;pair&lt;int,int&gt;&gt; rangs; void addRange(int left, int right) &#123; vector&lt;pair&lt;int, int&gt;&gt; res; int size = (int)rangs.size(); for(int i = 0; i &lt; size; i ++)&#123; if(rangs[i].first &gt;= right || left &gt;= rangs[i].second)&#123; //不包含，且没有交集 res.push_back(rangs[i]); &#125; else&#123; //包含或存在交集 left = min(left, rangs[i].first); right = max(right, rangs[i].second); &#125; &#125; res.insert(res.begin(), &#123;left,right&#125;); rangs = res; &#125; bool queryRange(int left, int right) &#123; int size = (int)rangs.size(); for(int i = 0; i &lt; size; i ++)&#123; if(rangs[i].first &lt;= left &amp;&amp; rangs[i].second &gt;= right)&#123; return true; &#125; &#125; return false; &#125; void removeRange(int left, int right) &#123; vector&lt;pair&lt;int, int&gt;&gt; res; int size = (int)rangs.size(); for(int i = 0; i &lt; size; i ++)&#123; if(rangs[i].first &gt; right || left &gt; rangs[i].second)&#123; //不包含 并且不连续(如果 &gt;= || &gt;=的话，对与相连的区间就少了合成的机会。某些情况下会导致边界的重复，如果发生，那么会导致删除函数的不准确) res.push_back(rangs[i]); &#125; else&#123; //存在交集 或者 包含 if (rangs[i].first &lt; left) &#123; res.push_back(&#123;rangs[i].first,left&#125;); &#125; if (rangs[i].second &gt; right) &#123; res.push_back(&#123;right,rangs[i].second&#125;); &#125; &#125; &#125; rangs = res; &#125; 后记：这种方法没太大的技巧。情况较多和边界处理，是这道题的难点所在。 解法二:map&lt;int,int&gt; m; /* 查找所在的范围。 1.add. 如果不存在，直接返回原范围。否则，返回需要更新的范围 2.remove 如果不存在，直接返回原范围。否则，返回交集的范围。 */ pair&lt;int, int&gt; find(int left,int right)&#123; auto l = m.upper_bound(left); auto r = m.upper_bound(right); if (l != m.begin() &amp;&amp; (--l)-&gt;second &lt; left) &#123; //不存在交集 l++; &#125; if (l==r) &#123; return &#123;left,right&#125;; &#125; int i = min(left,l-&gt;first); int j = max(right,(--r)-&gt;second); m.erase(l, ++r); return &#123;i,j&#125;; &#125; void addRange(int left, int right) &#123; pair&lt;int, int&gt; p = find(left,right); //插入或调整范围 m[p.first] = p.second; &#125; bool queryRange(int left, int right) &#123; //获取第一个大于left的pair,如果不是第一个，那么必然存在firs&lt;left的pair，如果这个pair的second大于等于right,那么返回true。 auto p = m.upper_bound(left); return p != m.begin() &amp;&amp; (--p)-&gt;second &gt;= right; &#125; void removeRange(int left, int right) &#123; pair&lt;int, int&gt; p = find(left,right); //去除，[left,right)。更新范围，要保留左侧或右侧的相交的部分。 if(p.first &lt; left) m[p.first] = left; if(p.second &gt; right) m[right] = p.second; &#125; 后记：使用map这样的有序的结构，从而使用二分提高查找效率。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"719. 找出第 k 小的距离对","slug":"2019-11-4leetcode719. 找出第 k 小的距离对","date":"2019-11-03T16:00:00.000Z","updated":"2019-11-04T16:13:45.554Z","comments":true,"path":"2019-11-4leetcode719. 找出第 k 小的距离对.html","link":"","permalink":"https://zengbailiang.cn/2019-11-4leetcode719. 找出第 k 小的距离对.html","excerpt":"","text":"给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。示例 1:输入：nums = [1,3,1]k = 1输出：0解释：所有数对如下：(1,3) -&gt; 2(1,1) -&gt; 0(3,1) -&gt; 2因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。提示:2 &lt;= len(nums) &lt;= 10000.0 &lt;= nums[i] &lt; 1000000.1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2. 解法一：非常规的思路。如果对数组排序后，可以得出绝对值的区间范围。这是一个有序的区间范围,对于有序的范围，就可以考虑二分法去缩小范围。设定一个目标值，然后根据目标值在子函数中查找符合题目的条件，本题在子函数中计算小于等于目标值的绝对值个数，以作为二分的判断依据和获取答案的第K个最小距离。 int smallOrEquarK(vector&lt;int&gt;&amp; nums,long mid)&#123; int res = 0; for (int right = 0; right &lt; nums.size(); right ++) &#123; int left = 0; ///滑动窗口，计算个数 while (nums[right] - nums[left] &gt; mid) &#123; left ++; &#125; res += right - left; &#125; return res;&#125;int smallestDistancePair(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); long left = 0; long right = nums[nums.size() - 1] - nums[0]; while (left&lt; right) &#123; long mid = left + (right - left)/2; int count = smallOrEquarK(nums,mid); if(count &gt;= k)&#123; ///如果大于等于mid,那么有可能mid是题解，所以right = mid,作为最新的右边界。 right = mid; &#125; else &#123; //如果小于，那边mid一定不是题解，所以left = mid + 1,作为左边界。 left = mid + 1; &#125; &#125; return right;&#125; 后记：如果不是熟悉二分法的解题特征，应该比较难想到这种方法吧。这不是一种正向思路的常规解法。包括子函数中使用的滑动窗口，都是优化的技巧。另外二分的，while的条件，边界的重新赋值都是有所依据的。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"778. 水位上升的泳池中游泳","slug":"2019-11-3leetcode778水位上升的泳池中游泳本","date":"2019-11-02T16:00:00.000Z","updated":"2019-11-04T15:40:40.221Z","comments":true,"path":"2019-11-3leetcode778水位上升的泳池中游泳本.html","link":"","permalink":"https://zengbailiang.cn/2019-11-3leetcode778水位上升的泳池中游泳本.html","excerpt":"","text":"在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？示例 1:输入: [[0,2],[1,3]]输出: 3解释:时间为0时，你位于坐标方格的位置为 (0, 0)。此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置 解法一解读问题可知，要求的是能到达右下角的所有路径的每条路径的最大值，这个最大值集合的最小值。目标值是一个已知的范围，[格子中的最小值，格子中的最大值]。那么可以通过二分在目标区间查找目标值。根据目标值值，进行dfs或bfs来获取是否存在此路径来调整二分区间，逼近目标值。 后记：已知有限区间，不妨考虑下二分是否可行，关键字（有限区间、有序）。dfs一般涉及到递归,可以使用栈来实现。而bfs，需要队列来实现。 void dfs(int t,vector&lt;vector&lt;int&gt;&gt;&amp; grid,int i , int j ,vector&lt;vector&lt;bool&gt;&gt; &amp;visit)&#123; long size = grid.size(); //超出范围，或者不符合条件，或者已经访问。返回。 if(i &lt; 0 ||i &gt; size - 1 ||j &lt; 0 ||j &gt; size - 1 ||grid[i][j] &gt; t ||visit[i][j])&#123; return; &#125; visit[i][j] = true; dfs(t, grid, i + 1, j, visit); dfs(t, grid, i, j + 1, visit); dfs(t, grid, i - 1, j, visit); dfs(t, grid, i, j - 1, visit);&#125;int swimInWater(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int left = 0; int right = 0; //left,right分别获取方块中最小和最大的水的深度。 for (int r = 0; r &lt; grid.size(); ++r) &#123; for (int c = 0; c &lt; grid.size(); ++c) &#123; right = max(right, grid[r][c]); left = min(left, grid[r][c]); &#125; &#125; long size = grid.size(); int res = right; //此条件为什么是&lt;=。 因为是查找点，而非查找区间 while (left &lt;= right) &#123; int mid = left + (right - left)/2; vector&lt;vector&lt;bool&gt;&gt; visit(size,vector&lt;bool&gt;(size,false)); dfs(mid, grid, 0, 0, visit); if(visit[size-1][size-1])&#123; res = mid; right = mid - 1; &#125; else&#123; left = mid + 1; &#125; &#125; return res;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"658. 找到 K 个最接近的元素","slug":"2019-10-31leetcode658找到 K 个最接近的元素","date":"2019-10-30T16:00:00.000Z","updated":"2019-10-31T15:54:59.570Z","comments":true,"path":"2019-10-31leetcode658找到 K 个最接近的元素.html","link":"","permalink":"https://zengbailiang.cn/2019-10-31leetcode658找到 K 个最接近的元素.html","excerpt":"","text":"给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。 示例 1: 输入: [1,2,3,4,5], k=4, x=3输出: [1,2,3,4] 解法一：找到k个最接近的元素，实际上是返回原数组的一个子数组。那么可以通过两头向中间获取原数组的元素，然后跟x对比，舍弃差值较大的。直到舍弃size - k 个元素为止。然后通过一个数组返回这些帅选过后的元素。 vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123; vector&lt;int&gt; res(k,0); int len = arr.size(); int left = 0; int right = len - 1; while(len &gt; k)&#123; if(abs(arr[left] - x) &gt; abs(arr[right] - x))&#123; left ++; &#125; else&#123; right --; &#125; len --; &#125; ///新数值index从0开始 int index = 0; for(int i = left; i &lt;= right; i ++)&#123; res[index++] = arr[i]; &#125; return res;&#125; 后记：1.把问题转化为查找子数组。确定了这一点，然后想到解法一的思路。分析题目，对信息进行有效的解读，非常有利于思路的推进，或者找到新的思路。例如此题转化为查找子数组。 解法二：采用二分法，查找最合适的子数组的起始坐标。二分开始的范围为(0,size - k),保证右边只至少存在k个元素。然后二分，获取arr[mid] - x,arr[mid + k ] -x 的值来比较，判断arr[mid]是否被舍弃，如果舍弃那么 left = mid +1,反之right = mid.最后达到临界条件left = right。然后获取 left .. left + k(不包含)下标的元素集合返回。 比较难理解的点分析：当abs(arr[mid] - x) &gt; abs(arr[mid + k] - x)时，舍弃mid这个点,start = mid + 1，这个很好理解。但当abs(arr[mid] - x) &gt;= abs(arr[mid + k] - x)是，end = mid，这个就不太好理解了。根据对比条件可得，要舍弃[mid+k]这个点。那么就算end作为start，那么返回的区间就是[mid, mid + k -1]。从个角度来看，这个二分的过程，实际上是确定start的过程，由始至终目标start都在[start,end]这个区间中，然后不断二分，逼近最合适的start。这样好像就理解了这个解法的关键点了。 vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123; vector&lt;int&gt; res(k,0); int start = 0; //end的初始值，设定二分开始区间为(0,size -k),所以下面用到mid + k 是不会越界的; int end = arr.size() - k; int mid; while (start &lt; end) &#123; mid = start + (end - start)/2; if(abs(arr[mid] - x) &gt; abs(arr[mid + k] - x))&#123; ///这里是mid这个点已经不符合要求，舍弃，调整start start = mid + 1; &#125; else&#123; ///这是是 end = mid; &#125; &#125; int index = 0; for (int i = start; i &lt; start + k; i ++) &#123; res[index++] = arr[i]; &#125; return res;&#125; 后记：二分法并不是想象中的那么简单。某些场景下并不是那么好理解。就如此题的，目的是获取目标起始坐标，二分的区间也是起始坐标所在的区间。而比较的条件是能确定区间移动方向的两个边界值的比较。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zengbailiang.cn/tags/leetcode/"}]},{"title":"iOS  证书校验的几种嵌入方式，公钥证书pem的读取","slug":"2019-07-20iOS  证书校验的几种嵌入方式，公钥证书pem的读取","date":"2019-07-19T16:00:00.000Z","updated":"2019-07-20T01:07:03.060Z","comments":true,"path":"2019-07-20iOS  证书校验的几种嵌入方式，公钥证书pem的读取.html","link":"","permalink":"https://zengbailiang.cn/2019-07-20iOS  证书校验的几种嵌入方式，公钥证书pem的读取.html","excerpt":"","text":"嵌入的几种方式使用公有协议https进行网络传输，为了避免数据被抓包，需要实现客户端的证书校验功能。而证书校验可能存在几种实现的方式。分别如下：A. 直接把客户端证书cer,嵌入到bundle中。B. 提取客户端证书的公钥，生成pem格式文件，嵌入到bundle中。C. 把cer证书pem格式的文本硬编码到代码中。D. 把pem格式公钥硬编码到代码中。 差别分析实际上，以上的实现方式都能实现证书校验的功能，只是对应的证书数据解析哪一步的代码处理有点差异。让我感到疑惑的是，为什么会存在这几种方式，特别是A和B。 使用B而不使用A的原因猜测： 开发团队可能不愿意泄漏过多的证书信息，只是为了实现功能必要的嵌入公钥信息。 证书信息不常驻内存，存在频繁读取的场景，此时考虑效率，只使用必要的公钥信息。 而C,D与A，B没有多大区别，主要是转成了base64硬编码到代码中。从安全性的角度来说，可能比直接把文件嵌入安全一点。文件直接砸壳就能拿到，很直接。而硬编码需要分析二进制，并且还要在一堆字符串查找，不那么直接。 公钥证书pem的读取// 从公钥证书文件中获取到公钥的SecKeyRef指针。 Base64String-&gt;NSData+ (id)publicSecKeyFromKeyBits:(NSData *)givenData &#123; NSMutableDictionary *options = [NSMutableDictionary dictionary]; options[(__bridge id)kSecAttrKeyType] = (__bridge id) kSecAttrKeyTypeRSA; options[(__bridge id)kSecAttrKeyClass] = (__bridge id) kSecAttrKeyClassPublic; NSError *error = nil; CFErrorRef ee = (__bridge CFErrorRef)error; ///但这个方法在iOS10才支持。 id ret = (__bridge_transfer id)SecKeyCreateWithData((__bridge CFDataRef)givenData, (__bridge CFDictionaryRef)options, &amp;ee); if (error) &#123; return nil; &#125; return ret;&#125; 此方法存在一个比较明显的缺点，只支持iOS10及其以上。我看到一些嵌入pem格式的公钥证书的app是支持到8.0的，但没能找到能支持低版本的生成SecKeyRef的方法，也许其作用并不是用来做证书校验的。 小技巧在后台不能提供客户端证书的情况下，可以在浏览器使用对应的域名下得网址进行请求，把证书拿到。macOS可以这么操作：1.请求相应的地址，2点击地址栏左边的小锁头，3点击证书，4出现证书详情的时候，点击拖动证书图标保存到本地。","categories":[{"name":"安全","slug":"安全","permalink":"https://zengbailiang.cn/categories/安全/"}],"tags":[{"name":"安全","slug":"安全","permalink":"https://zengbailiang.cn/tags/安全/"}]},{"title":"回了一趟校园","slug":"2019-07-17回了一趟学校","date":"2019-07-13T16:00:00.000Z","updated":"2020-01-01T01:33:22.270Z","comments":true,"path":"2019-07-17回了一趟学校.html","link":"","permalink":"https://zengbailiang.cn/2019-07-17回了一趟学校.html","excerpt":"回了一趟学校大概是五月份的时候回了趟学校。再次回去还是比较感慨，想去的地方很多，但时间却有限，就选了几个比较有回忆又比较便捷的地方走走。也许是因为值得回忆的事情太多了，又或者是怀念作为学生的那份心情和青春，总之很难说清。但每每想到这些，总会非常感叹，有些事情，有些年纪只能经历一次，心态会伴随着年纪而变化，又或者其他的一些原因，总之过去的那个特定的阶段，特定的事情和那份特定的心情，是后面阶段无法再重新获取的。这确实是个比较无奈的事情，但这应该是合理的，人生就应该要有不同的阶段。","text":"回了一趟学校大概是五月份的时候回了趟学校。再次回去还是比较感慨，想去的地方很多，但时间却有限，就选了几个比较有回忆又比较便捷的地方走走。也许是因为值得回忆的事情太多了，又或者是怀念作为学生的那份心情和青春，总之很难说清。但每每想到这些，总会非常感叹，有些事情，有些年纪只能经历一次，心态会伴随着年纪而变化，又或者其他的一些原因，总之过去的那个特定的阶段，特定的事情和那份特定的心情，是后面阶段无法再重新获取的。这确实是个比较无奈的事情，但这应该是合理的，人生就应该要有不同的阶段。 13路车有些事情还是没变，但变化总是在不断的发生。熟悉的13路车还在，还是要从东区开过20分钟才到尧山校区，我很享受在车上坐窗旁、吹着风，看着窗外风景的那种感受。但13路好像已经都变成了空调车，没了那种想开就开的车窗了。 尧山再次上尧山， 还是爬着上。记得大一第一次爬的时候，好像是中秋节，那个时候人很多，而当天爬的人很少，就只有我和朋友，其他人坐的缆车，感觉比较冷清，可能是时间的问题吧，也许周末的时候会有爬的人。山上景区也有了不少变化，山顶走向盘山公路的路变了，中间有电视塔的那一部分被围起来了，堵住了去盘山公路的路，还好旁边又开辟了一条小路。下山的时候走的盘山公路。我同样很喜欢尧山的盘山公路，有很长的一段泊油路，干净美丽。这里也是小年轻，小情侣骑着小电瓶，快意驰骋的好地方。 尧山校区傍晚回到了尧山校区，发现食堂不允许使用现金了，其实早在第一天逛东区的时候，就发现这个问题了，略感无奈，无法再尝一遍食堂的味道，但同时发现了一个事情，因为学校的数字校园毕业了依然可以用，而且还能通过支付宝充值，我尝试充了一块钱，还真可以，但我没把我的校园卡带过来，还有我也不知道我的校园卡是否还能用了，也许我的校园卡还没消磁，还有就是学校系统确实还支持，这留给了我一个待挖掘的事情。因为这样，晚上和朋友就打算去商业街吃饭了，比较随性，但商业街已经变得不那么热闹了。以前，热闹的场景不复存在。大学那几年，最开始有男生宿舍那边的阳光商业街，有靠近女生宿舍的职工宿舍楼下的店铺。特别是教职工楼下的奶茶店之类的店铺，那时候那些地方就有一些特殊的气氛，仿佛有一种爱情的荷尔蒙，是谈情说爱的地方。如今，阳光商业街没了，有了新商业街，现在新商业街又被搞萧条，职工楼下的小店也都禁止了营业，另外又在原阳光商业街哪里搞了一个新阳光商业街。对比这些吃吃喝喝的，仿佛当年更气氛更好，但现在的学弟学妹们没有经历过当年，所以就算真的如我所说的那个样子，对于他们来说最丰富有趣的依然是他们现在所感受到的。 花江还有的是，以前可以在学校旁的花江划竹筏，烧烤，现在由于建了新的教职工园区，在花江上搭了座桥，竹筏已经不能划了。那些年满是笑语的娱乐活动没了。另外那些天然的烧烤场地，也变得不适合烧烤了，看到这样，有点说不出味道。也许因为这些没有了，会失去一些趣味吧。不可否认可能是因为现在的娱乐方式变得跟以前不太一样了，才导致这些变化，但具体怎么样，就不太清楚了，毕竟现在已经是00后的大学了。最后，最后，让我不得不吐槽的是，学习的男女比例好像更均衡了，情侣比例好像更高了，虽然这是好事啊，但这让我失去了一种熟悉感。 当然学校的建设也变得更好了，最明显的是那个图书馆了。那个在我大一就开始建，毕业都没用上的图书馆，哈哈。这里承载了我一生仅有的一次大学时光，也是我人生中的一段美好时光，怀念、感恩。","categories":[{"name":"记事","slug":"记事","permalink":"https://zengbailiang.cn/categories/记事/"}],"tags":[{"name":"散文","slug":"散文","permalink":"https://zengbailiang.cn/tags/散文/"}]},{"title":"iOS 本地数据安全存储方案探索","slug":"2019-07-14本地加密方案","date":"2019-07-13T16:00:00.000Z","updated":"2019-07-20T01:03:38.049Z","comments":true,"path":"2019-07-14本地加密方案.html","link":"","permalink":"https://zengbailiang.cn/2019-07-14本地加密方案.html","excerpt":"","text":"前言：一般app都支持本地记录登录状态，并支持离线的情况下加载用户数据，为了满足这样的场景，就需要把相关信息保存到本地。对于iOS持久化方面，无论使用userDefault、plist文件、归档、数据库等存储方式，都需要考虑一个问题，如何安全的存储数据？对于这个问题，可以对数据加密保存，至于选择哪种持久化方式，并不是那么重要。 加密方案说到对数据进行加密，那么肯定是要有一套安全的加密方案才行。以下是一些方案例子：A. 一些摘要算法或编码处理。B. 使用特定的秘钥执行某种对称加密。C. 使用特定的公私钥执行某种非对称加密。D. 某种自定义加密算法。对于A，这只是一种把明文转为非明文的一种方式。摘要算法不可逆，但数据无法还原，不符合需求。编码处理，可以反编码还原明文，实际上数据并没有变得更安全，也是不符合需求。但采用编码的方式，还是比直接使用明文要好那么一点点。对于B.使用公开的对称算法进行加解密，只要保证秘钥的安全，是可行的。对于C.同B，但相对于对称加密，非对称加密效率较低，所以在保证秘钥安全的前提下，选择B，而不是选择C。但C的安全系数会比B高。两者都已经满足数据破解的成本超过其获取的价值的要求。对于D，自定义算法，就要具体分析了， 破解难度因算法本身设计有关，但这个一般都是比较有实力的公司才这么搞吧，但一般都安全性比较高。是最好的方案之一，但其存在一定设计成本和测试成本。 从安全范围的角度去考虑到了这里，又面临了一个秘钥安全的问题，一般来说，我们可能会把秘钥硬编码到代码中，但我们的二进制文件存在一个字符串常量区，只要这个字符串在代码中被引用了，那么编译器就会把其写进字符串常量区。如果这样，稍微的分析下二进制文件，就可能把秘钥获取。所以秘钥硬编码是比较危险的。面对这个问题，可以通过把秘钥分拆成多个字符串，再通过某些处理生成真正的秘钥，来提高安全性。这里会存在一个更值得思考的问题，为了引出这个问题，先回归到方案的探索。 到目前为止讨论到的都是本地怎么安全保存数据，到如何安全保存秘钥，都是围绕着单体方案去考虑，而没有从整体上去考虑。从安全范围的角度去考虑，如果在每一个客户端都是同样的加密算法，同样的秘钥，那么只要其中一个被破解，整个大厦立马倒塌。 为此，可以给安卓和苹果分别分配不同的秘钥，这样就能把两个平台，这块的安全性隔离。既然有了这样的想法，那么前进一步，如果每个客户端都拥有不同的秘钥，并且是一种随机秘钥（随机安全性更高，当然可能伪随机，虽然伪随机实际上是通过算法来生成的，有规律，但其破解难度很大），那么就能把这块的安全性做到客户端隔离。 最终选择的方案：使用AES对称加密算法；使用随机算法生成本地秘钥，秘钥中添加时效性信息，并保存到keyChain中。 优点：客户端隔离、对称加解密效率高，随机秘钥破解难度大。缺点：由于客户端隔离，秘钥都不一样，数据无法统一分析，因此也影响了适用场景。 demo:LocalEncryptDemo","categories":[{"name":"安全","slug":"安全","permalink":"https://zengbailiang.cn/categories/安全/"}],"tags":[{"name":"安全","slug":"安全","permalink":"https://zengbailiang.cn/tags/安全/"}]},{"title":"iOS 移动端 安全思考与总结","slug":"2019-07-14安全思考","date":"2019-05-01T16:00:00.000Z","updated":"2019-07-20T01:03:01.166Z","comments":true,"path":"2019-07-14安全思考.html","link":"","permalink":"https://zengbailiang.cn/2019-07-14安全思考.html","excerpt":"","text":"iOS 移动端 安全思考 这是一遍安全知识总结的博客，并涉及相关知识的延伸，以作知识备忘和总结。 安全相关的几个方面： 敏感数据输入安全 外部调用，和对外数据安全 本地数据存储安全 网络数据传输安全 app代码安全 以下分别对每一点展开1.敏感数据输入安全 textField密码模式与自定义键盘 敏感数据主要是指密码信息或者使用户的个人信息、交易信息等。当我们输入密码的时候一般会打开textField的密码输入模式，这时候是会强制使用系统键盘，并且密码输入后不可见。如果苹果对系统键盘没有做数据获取，那么这相对安全的，不存在数据泄漏。但这个代码不是开源的，所以也是不敢打包票的。所以我们常见的一些银行app会去实现私有键盘，同时会打乱数字字母的位置。这里面大概有两个考虑，一个是防止键盘数据监听，另一个是防止第三者通过观察用户输入手势猜测密码。 然而iOS是苹果的系统，如果苹果硬要监控数据，那么怎么都是没办法避免的，除非不用iOS系统。但这个本来就与苹果的立场相悖的。所以一些app实现私有键盘，个人认为主要是防止第三者通过观察用户输入手势的手段，猜测出密码。另外自定义键盘每个按钮点击的时候不显示视觉变化。如果在点击的时候样式发生变化，同时手机被录屏了，那么视频中就能看到密码输入的具体字符和顺序，导致密码泄露。 第三方键盘完全访问 另外使用第三方键盘，特别是在运行完全访问之后，存在安全风险。允许完全访问后，第三方键盘能把用户输入的数据发送到自家后台（就算开始不允许完全访问，后面再允许，之前的输入数据也会被上传。因为不允许完全访问的时候，第三方键盘能把输入数据保存到本地，当获取到完全访问的时候再把这部分数据上传）。收集这个数据能对键盘的输入体验进行优化，主要是自动更正功能和根据用户的习惯匹配出更高频率的词语。但风险是时刻存在的，这个需要用户对体验的优化与承受的风险之间做权衡。但保守策略，安全起见，最好还是不允许键盘的完全访问。link:iOS 8 第三方键盘“完全访问”的那些事 键盘缓存 当用户使用系统键盘，并开启自动更正功能的时候，系统就会把键盘的输入记录到系统的一个特定路径的文件中（/private/var/mobile/Library/Keyboard/dynamic-text.dat），并且该文件是明文存储。所以获取到文件内容，并加以分析，就有可能获取到用户的密码信息等。但这里有一个前提，必须是越狱手机才能获取，因为存在沙盒机制，应用是无法访问到该目录的文件的。基于这一点，使用自定义键盘就可以避免被输入被缓存。link:键盘缓存与安全键盘 安全策略： 输入密码设置textField的密码输入模式。 安全性更好的，实现私有键盘，每次打乱键值顺序，控件不实现点击效果。 不允许第三方键盘的完全访问。 2. 外部调用，和对外数据安全 外部调用是指，其他应用唤起app的行为。主要是通过scheme来唤起。通常app内部是有处理外部调用的逻辑的，并能根据scheme后面拼接的参数来跳转到不同的业务模块。那么这里就有可能存在逻辑漏洞，特别对于重要的涉及用户金钱或隐私的模块，需要有一套严谨的参数校验规则，避免漏洞发生。个人认为这种提供给外部的入口，都是app安全的一个隐患，所有必须要有一个严谨的权限校验规则。 对外数据，指通过各种途径能被外部获知的数据。这里主要是app退到后台显示的截图，因为实在不知道这个归类到哪里，就归类到对外数据。系统截图是系统为了提供用户体验的手段，但可能无意中泄漏了重要信息。故这里要进行处理，第一种可以禁止截图，那么推到后台把keyWindows隐藏，那么系统的截图就变成黑色；另外一种就是手动替换截图，一般会对截图进行模糊化。 安全策略 外部发起调用，需要有一套完善的鉴权机制。 系统截图，需要手动替换。 3. 本地数据存储安全本地数据如果明文保存的话，是不安全的。虽然有沙盒机制的保护，但如果手机被越狱了，那么数据就暴露了。所以，重要信息需要进行加密保存。可以采用aes进行加密，base64编码后进行保存。这样就算数据被获取，也无法得到有用信息。由于这里使用aes加密，那么如何安全保存加密秘钥是一个重要的问题。因为如果秘钥被破解了，那么数据就被破解了。因为本地数据加解密都在本地进行，所以秘钥作用范围也仅限于本地数据。一般可以使用两种方式提供秘钥：第一种hardCode秘钥，第二种本地生成秘钥，再保存本地。下面对安全性方案进行讨论： hanrdCode秘钥： //形如：static NSString *aesPriKey = @\"xxx0xxx0xxx0xxx0xxx0\"; 这看起来好像没什么问题，但这种hardCode的方式，很容易被获取。获取方式：使用逆向技术对app进行砸壳（例如pp助手下载的app已经砸壳），并使用使用machOViewer 查看APP的二进制文件，就能获取到字符串常量（前提是这个字符有被引用，否则编译器貌似会优化掉。但我们加密的秘钥怎么可能会不引用呢，测试的时候发现的现象，顺便记录下）。 如果写入到文件中，然后在运行过程中通过读文件的方式获取秘钥，那么也是不安全的，秘钥不能直接保存到文件中，但难道要把秘钥加密保存到文件中，那么用于加密的秘钥怎么保证安全，这就变成了鸡生蛋蛋生鸡的问题了。可以尝试直接对秘钥加盐然后编码存储到文件中，这样只要加盐规则和编码规则足够复杂也是相对安全的。 本地生成秘钥 由于这个秘钥保存的问题，个人在开发中使用的方案是，本地生成随机秘钥，并把秘钥保存到系统keychain中,同时可以设置秘钥的有效时间。这样设计有两个好处，一个生成随机秘钥，能保证每台手机的秘钥不一样，这样能缩窄影响范围，第二个是由于时效性的存在，当然这个时效性只能引用于用户登录信息等功能，但它增加了秘钥破解的难度。除非破解了代码逻辑并成功获取到keychain的秘钥，同时破解苹果的加密算法，才有可能破解整套策略，所以是相对安全的。在这个过程中，我们甚至可以对生成的秘钥加盐，但我认为这个貌似没必要，如果加盐是常量字符串，反而能从分析二进制文件常量字符中顺藤摸瓜找到相关的加密逻辑，留下多余线索。 安全策略： 不使用常量字符串定义秘钥。如果确实是固定的秘钥，那么要使用一套混淆规则混淆秘钥，使用的时候再对秘钥进行反混淆，例如 salt1 + 原始秘钥 + salt2 再两次base64生成新的字符串作为常量保存。使用的时候，base64Decode两次再获取中间的元素秘钥。规则应该多变的，不要全部一致，否则这个混淆就没有意义了。 本地秘钥随机生成（可以使用arc4random(),这里不要使用时间戳作为随机种子，因为时间戳是有规律的。但时间戳可以作为信息添加到秘钥中，作为有效时间的判断。）同时生成的秘钥以密码的形式保存到系统的keyChain中，这样苹果会对秘钥进行加密并保存到keyChain中。可采用aes128/192/256(秘钥长度分别为16/24/32byte,128/192/256bit) + base64编码的加密方案。 aes的相关说明 aes是一种分组密码算法。 以下摘录维基百科对分组密码的一些重要描述,包括分组密码的概念，还有算法的设计原则中两个重要因素扩散和扰乱。其中还谈到每一轮都使用不同的子秘钥，这样会大大增加区块之间的关联性，让破解难度变高，而几种加密模式中ecb电密码本模式并没有使用这种设计思想去实现加密，下面会谈到多种加密模式。 维基百科 在密码学中，分组加密（英语：Block cipher），又称分块加密或块密码，是一种对称密钥算法。它将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。 迭代产生的密文在每一轮加密中使用不同的子密钥，而子密钥生成自原始密钥。 设计原则:扩散（diffusion）和扰乱（confusion）是影响密码安全的主要因素。扩散的目的是让明文中的单个数字影响密文中的多个数字，从而使明文的统计特征在密文中消失，相当于明文的统计结构被扩散。扰乱是指让密钥与密文的统计信息之间的关系变得复杂，从而增加通过统计方法进行攻击的难度。扰乱可以通过各种代换算法实现。 分组密码工作模式 分组密码工作模式，常用模式有五种：电子密码本ECB、密码块链接CBC、填充密码块链接PCBC、密文反馈CFB、输出反馈OFB、计数器模式CTR。另外还有相关的很重要的几个概念，分别是加密向量IV和块填充模式PADDING。维基百科概关于分组密码工作模式的概要说的很精辟。 维基百科 -分组密码工作模式 密码学中，分组（block）密码的工作模式（mode of operation）允许使用同一个分组密码密钥对多于一块的数据进行加密，并保证其安全性。分组密码自身只能加密长度等于密码分组长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适填充方式将数据扩展到匹配密码块大小的长度。一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全[1]。 对于AES来说，块的固定长度为128bit,秘钥长度为128/192/256bit（这个涉及到编码细节，例如不知道这个，就不知道秘钥的长度，可能导致编码错误）。由于块的长度固定为128，所以就存在最后一个块填充的问题，这涉及到块的填充模式PADDING,加密解密都需要用同样的的块填充模式去处理最后的块（涉及到编程细节，块填充模式的选择）。加密的时候是对明文切分成若干组，每组长度都等于128位。aes会对每一组进行多轮加密。其过程包括若干步骤，轮秘钥加、字节替换、行位移、列混合、轮秘钥加，并且根据秘钥的位数不同分别对应不同的轮数（位数/轮数）128/10，192/12,256/14。密码学的东西不太好啃，数学渣渣表示啃不动，需要比较好的数学基础才能比较畅顺的理解其加密过程的每个步骤，但我觉得十几步的加密过程和多轮的加密，应该是围绕扩散和扰乱两点出发，来提高算法的破解难度的。 ECB模式与CBC模式 挑选ECB和CBC模式分析，加深对分组密码工作模式的理解，直观对比两模式的差异，并简要说明下使用IV的原因。 ECB模式：把明文划分为长度相等的块128bit,并对每个块独立加密，最后拼接成为完整的加密密文。由于每个块都是使用同一个秘钥独立加密，块与块之间没有关联性，对于同样的明文块（不管其在整个块集合中那个位置）加密产生的密文都是一样的，因此更有规律性，不能很好隐藏数据。 CBC模式：同样先划分块，加密的时候CBC每个明文块与前一个密文块进行异或后再进行加密。这样每个块都依赖其前面的块，内部是联动的，这样的话，存在明文系统的块，加密出来的结果也是不一样的，从这一点来看比ECB安全性更高。但这里存在一个问题，就是如果第一个块内容一样，那么对于共同的明文前缀加密出来的结果也是一样的，如果这样，反而变成了破解的一个入口。为了解决这种情况，这个时候上面提到的重要元素向量IV就派上用场了，第一个块加密加入向量的参与，主要确保每一个条消息独有的一个向量，那么就能保证密文的唯一性。缺点：由于块之间存在依赖导致其加密过程是串行的，并且消息必须被填充到块大小的整数倍。 aes的加密原理：aes支持三种秘钥长度分别是128/192/256位，对应字符串长度为16/24/32。加密的时候是对明文切分成若干组，每组长度都等于128位。aes会对每一组进行多轮加密。其过程包括若干步骤，轮秘钥加、字节替换、行位移、列混合、轮秘钥加，并且根据秘钥的位数不同分别对应不同的轮数（位数/轮数）128/10，192/12,256/14。 维基百科-AES 维基百科-分组密码工作模式 关于随机数 维基百科-随机数 根据密码学原理，随机数的随机性检验可以分为三个标准：1.统计学伪随机性。统计学伪随机性指的是在给定的随机比特流样本中，1的数量大致等于0的数量，同理，“10”“01”“00”“11”四者数量大致相等。类似的标准被称为统计学随机性。满足这类要求的数字在人类“一眼看上去”是随机的。2.密码学安全伪随机性。其定义为，给定随机样本的一部分和随机算法，不能有效的演算出随机样本的剩余部分。3.真随机性。其定义为随机样本不可重现。实际上衹要给定边界条件，真随机数并不存在，可是如果产生一个真随机数样本的边界条件十分复杂且难以捕捉（比如计算机当地的本底辐射波动值），可以认为用这个方法演算出来了真随机数。但实际上，这也只是非常接近真随机数的伪随机数，一般认为，无论是本地辐射、物理噪音、抛硬币……等都是可被观察了解的，任何基于经典力学产生的随机数，都只是伪随机数。 随机数分类： 伪随机数：满足第一个条件的随机数。 密码学安全的伪随机数：同时满足前两个条件的随机数。可以通过密码学安全伪随机数生成器计算得出。 真随机数：同时满足三个条件的随机数。 重点是：随机数在密码学中非常重要，保密通信中大量运用的会话密钥的生成即需要真随机数的参与。如果一个随机数生成算法是有缺陷的，那么会话密钥可以直接被推算出来。真正的随机数是使用物理现象产生的：比如掷钱币、骰子、转轮、使用电子组件的噪音、核裂变等等。这样的随机数生成器叫做物理性随机数生成器，它们的缺点是技术要求比较高。在实际应用中往往使用伪随机数就足够了。这些数列是“似乎”随机的数，实际上它们是通过一个固定的、可以重复的计算方法产生的。它们不真正地随机，因为它们实际上是可以计算出来的，但是它们具有类似于随机数的统计特征。这样的生成器叫做伪随机数生成器。在真正关键性的应用中，比如在密码学中，人们一般使用真正的随机数。 维基百科-随机数 关于加盐 维基百科-盐 盐（Salt），在密码学中，是指在散列之前将散列内容（例如：密码）的任意固定位置插入特定的字符串。这个在散列中加入字符串的方式称为“加盐”。其作用是让加盐后的散列结果和没有加盐的结果不相同，在不同的应用情景中，这个处理可以增加额外的安全性。 作用：提高数据安全性， 加盐后再通过散列算法得出特征值，不能直接通过彩虹表暴力破解出原数据，在验证用户密码的场景下，极大的提高了安全性。但同时因为要校验用户密码，所以需要保存这个盐值。 以下为维基百科相关描述通常情况下，当字段经过散列处理（如MD5），会生成一段散列值，而散列后的值一般是无法通过特定算法得到原始字段的。但是某些情况，比如一个大型的彩虹表，通过在表中搜索该MD5值，很有可能在极短的时间内找到该散列值对应的真实字段内容。加盐后的散列值，可以极大的降低由于用户数据被盗而带来的密码泄漏风险，即使通过彩虹表寻找到了散列后的数值所对应的原始内容，但是由于经过了加盐，插入的字符串扰乱了真正的密码，使得获得真实密码的概率大大降低。 所以在某些业务场景下可以考虑使用加盐的方式提高数据安全性。 4. 网络数据传输安全移动数据通过网络传输主要是面临几个风险：1.窃听风险。2.篡改风险。3.冒充风险。那么可以认为如果没有以上风险，传输就是安全的。s在民用领域网络通信一般都是使用http，https，又或者使用socket的tcp udp通讯，另外还有一些私有协议（微信、qq）。对于敏感数据的传输，使用http是不安全的（除非先自己加密一遍再传输），而在不使用私有协议的前提下，为了保证安全性，一般会使用https。https依赖于第三方权威机构证书认证和非对称算法，能使clien和server相互确认身份，安全生成第三个随机数，并协商出用于对称加密的会话密秘钥，进行安全的对称加密传输（https原理说明），我认为安全生成了会话秘钥后，在没有秘钥的情况下无法解开密文的，这样就能有效防止了窃听风险，篡改风险和冒充风险。首先无法解密就能避免窃听和冒充，而篡改，或者你可以把内容换掉，但这会导致解密失败，就算解密成功也是没有意义的内容，无关紧要。 但在使用https的情况下，有几个点还是需要注意一下： https可以使用自签名证书，这种情况通过浏览器请求，地址栏开头一般会出现一个✘的图标，代表这个请求是不授信的，有些浏览器会提示风险并询问是否继续访问。但如果你在系统中添加了相关的根证书并设置信任，那么这个请求就会被认为是合法的。所以，往系统中添加证书需要慎重。 客户端编码的时候，要根据服务器的证书情况（权威认证证书，还是自签名证书）设置合理的证书校验规则。编码涉及的点：1.是否校验域名；2.是否校验有效期；3.具体的校验策略。如果是使用AFNetWorking,涉及到的编码如下：//配置请求Manager是创建安全策略对象//暂时忽略PinningMode的选择AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:xxxx];//是否校验域名，3.0版本默认为YES。securityPolicy.validatesDomainName=NO;//是否允许无效证书（包括不校验证书有效期）。假设你想通过设置这里，来跳过校验有效期的话，在AFSSLPinningModeNone和AFSSLPinningModePublicKey是有效的，但AFSSLPinningModeCertificate是无效的，AFSSLPinningModeCertificate是一定会去校验证书是否有效，然后再去验证证书链，这里还是存在一定的疑惑，或许我可以给作者提一个issue。securityPolicy.allowInvalidCertificates=NO; 简述AFSecurityPolicy三种模式 AFSSLPinningModeNone选择该模式，当设置allowInvalidCertificates为YES时，会去校验证书有效期，会使用系统内置的权威机构根证书去校验客户端证书是否合法。但如果allowInvalidCertificates设置为NO，不进行合法性校验校验，方法返回值直接返回YES）。 AFSSLPinningModePublicKey读取内嵌所有cer（DER编码）文件，并提取全部publicKey,判断客户端证书的publicKey是否被包含。 AFSSLPinningModeCertificate读取内嵌所有cer（DER编码）文件，并判断端客户端证书内容是否被包含，只要证书链中其中一个证书被包含即可。因为客户端证书是由其上级证书签发的，而其上级证书是由服务器证书直接或者间接签发的，重点是上级证书能校验下级证书的合法性，换句话说如果客户端的上级证书被包含了，那么就能确认客户端证书的合法性。为了提高代码效率可以直接包含客户端证书或者客户端证书的上级证书。 小结：三种安全策略 allowInvalidCertificates = YES ;+ AFSSLPinningModeNone; + validatesDomainName = YES（必须为YES，否则不安全；这样可以防止数据被篡改，但可以被抓包，数据还是会泄漏。）; allowInvalidCertificates = NO；+ AFSSLPinningModePublicKey; + validatesDomainName = YES/NO（某些情况下，证书域名不匹配所有客户端请求，此时需要配置为NO）; AFSSLPinningModeCertificatev；+ alidatesDomainName = YES/NO（同上）; 下图为越狱版支付宝包内容展示，可见里面内嵌了pem编码格式的证书，包含了base64格式的公钥。 //命令行查看证书内容：zmubaiMacBook:AlipayWallet.app zengbailiang$ cat opensdk_public.pem -----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCtDVxvZhDT6FNaBqZ/Js2h7G7jv88UjsRlv2qDHpobSqzqe/PAbfmHZNvOOlR07l9k8GJMUp4v4z+hTy4pjypmB1Stnt5nulRHIbcUSQ3LsT3rETJGVsGBEkvIeZXHFRDK5UmeUO9IgiviwAthgvLnDM9SZOa9QCTROfibnpYWVQIDAQAB-----END PUBLIC KEY----- 参考链接：SSL/TLS协议运行机制的概述X.509公钥证书格式标准，对证书链的验证过程有很好的说明AF证书校验部分源码说明 5. app代码安全这部分主要是涉及到开发期的代码混淆、加固技术。逆向加固方面的知识了解的比较少，也就不做什么记录了。但仍然需要记录下一些主要的点。 提高代码安全，增强逆向难道的一些手段 类名、方法名、属性名混淆。（但混淆过度，可能导致审核被拒） 重要函数使用c（依然能被hood，使用fishhook等工具），内联静态函数安全性更高。 加密重要的字符串，避免砸壳后直接分析获取重要信息。（这方面有开源库） 使用加固工具，或第三方加固服务（UAObfuscatedString编译插件、爱加密、360加固等。） 相关文章参考：对 iOS app 进行安全加固 总结：孙子兵法有言知己知彼，方可百战百胜。安全攻防就是这样的一个东西，要去了解哪些攻击破解手段，才能更好的实施应对手段。","categories":[{"name":"安全","slug":"安全","permalink":"https://zengbailiang.cn/categories/安全/"}],"tags":[{"name":"安全","slug":"安全","permalink":"https://zengbailiang.cn/tags/安全/"}]},{"title":"SDWebImage设计思路分析","slug":"2019-03-10sdimage设计分析","date":"2019-03-09T16:00:00.000Z","updated":"2019-03-11T14:04:08.710Z","comments":true,"path":"2019-03-10sdimage设计分析.html","link":"","permalink":"https://zengbailiang.cn/2019-03-10sdimage设计分析.html","excerpt":"","text":"一、库功能主要提供了网络图片异步下载的功能。使ui展示大量网络图片的时候，能不堵塞主线程，保存界面流畅；同时，能有策略的异步下载图片，并正确的赋值到对应的控件上。sd库在异步下载的基础上，提供了磁盘缓存，提供了图片异步解压，尽可能的提高界面的体验。官方地址:https://github.com/SDWebImage/SDWebImage 二、整体需求 需求：imageview 把url作为入参，发起图片异步下载并在下载完毕后回调显示。 功能细分 图片完成下载后要正确的赋值给调用的控件，也即两者中要建立一个一对一的绑定关系。 图片异步下载的实现 包括单个下载的请求组装，状态控制，回调处理，图片预解压等。 请求并发控制。 图片缓存机制的实现 磁盘读写io的安全控制。 磁盘管理的安全策略设计。 三、 技术的实现 通过创建对应的id operation,回调中对imageView赋值。- (void)sd_internalSetImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options operationKey:(nullable NSString *)operationKey internalSetImageBlock:(nullable SDInternalSetImageBlock)setImageBlock progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock context:(nullable NSDictionary&lt;NSString *, id&gt; *)context &#123; SDWebImageManager *manager = [context objectForKey:SDWebImageExternalCustomManagerKey]; if (!manager) &#123; ///通过单例创建全局的SDWebImageManager manager = [SDWebImageManager sharedManager]; &#125; ///每一个imageView的setImage操作对应的生成一个实现了SDWebImageOperation协议的operation. SDWebImageOperation中有一个cannel方法，用于cannel下载行为。 id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; __strong __typeof (wself) sself = wself; if (!sself) &#123; return; &#125;///省略 UIImage *targetImage = nil; NSData *targetData = nil; if (image) &#123; // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set targetImage = image; targetData = data; &#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123; // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set targetImage = placeholder; targetData = nil; &#125; dispatch_main_async_safe(^&#123; if (group) &#123; dispatch_group_enter(group); &#125; ///进行赋值 [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:cacheType imageURL:imageURL]; if (group) &#123; // compatible code for FLAnimatedImage, because we assume completedBlock called after image was set. This will be removed in 5.x BOOL shouldUseGroup = [objc_getAssociatedObject(group, &amp;SDWebImageInternalSetImageGroupKey) boolValue]; if (shouldUseGroup) &#123; dispatch_group_notify(group, dispatch_get_main_queue(), callCompletedBlockClojure); &#125; else &#123; callCompletedBlockClojure(); &#125; &#125; else &#123; callCompletedBlockClojure(); &#125; &#125;); &#125;]; &#125; ///这个方法内部包含缓存获取和发起下载的相关逻辑- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; // Invoking this method without a completedBlock is pointless NSAssert(completedBlock != nil, @\"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead\"); // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won't // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString. if ([url isKindOfClass:NSString.class]) &#123; url = [NSURL URLWithString:(NSString *)url]; &#125; // Prevents app crashing on argument type error like sending NSNull instead of NSURL if (![url isKindOfClass:NSURL.class]) &#123; url = nil; &#125; SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new]; operation.manager = self; BOOL isFailedUrl = NO; if (url) &#123; LOCK(self.failedURLsLock); isFailedUrl = [self.failedURLs containsObject:url]; UNLOCK(self.failedURLsLock); &#125; if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123; [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url]; return operation; &#125; LOCK(self.runningOperationsLock); [self.runningOperations addObject:operation]; UNLOCK(self.runningOperationsLock); ///根据规则生成缓存key NSString *key = [self cacheKeyForURL:url]; SDImageCacheOptions cacheOptions = 0; if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory; if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync; if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages; __weak SDWebImageCombinedOperation *weakOperation = operation; ///去获取缓存，并在内部根据option参数判断后续的缓存处理和下载行为 operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key options:cacheOptions done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123; __strong __typeof(weakOperation) strongOperation = weakOperation; if (!strongOperation || strongOperation.isCancelled) &#123; [self safelyRemoveOperationFromRunning:strongOperation]; return; &#125; // Check whether we should download image from network BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly)) &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]); if (shouldDownload) &#123; if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server. [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; &#125; // download if no image or requested to refresh anyway, and download allowed by delegate SDWebImageDownloaderOptions downloaderOptions = 0; if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority; if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload; if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache; if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground; if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies; if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates; if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority; if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages; if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; // force progressive off if image already cached but forced refreshing downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload; // ignore image read from NSURLCache if image if cached but force refreshing downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse; &#125; // `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle __weak typeof(strongOperation) weakSubOperation = strongOperation; ///发起下载，并保存downloadToken值，以便能找到对应的dowanLoadOperation，去执行cannel操作等。这个会在cannel操作方法中很直观的看到。 strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation; if (!strongSubOperation || strongSubOperation.isCancelled) &#123; // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data &#125; else if (error) &#123; [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock error:error url:url]; BOOL shouldBlockFailedURL; // Check whether we should block failed url if ([self.delegate respondsToSelector:@selector(imageManager:shouldBlockFailedURL:withError:)]) &#123; shouldBlockFailedURL = [self.delegate imageManager:self shouldBlockFailedURL:url withError:error]; &#125; else &#123; shouldBlockFailedURL = ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost &amp;&amp; error.code != NSURLErrorNetworkConnectionLost); &#125; if (shouldBlockFailedURL) &#123; LOCK(self.failedURLsLock); [self.failedURLs addObject:url]; UNLOCK(self.failedURLsLock); &#125; &#125; else &#123; if ((options &amp; SDWebImageRetryFailed)) &#123; LOCK(self.failedURLsLock); [self.failedURLs removeObject:url]; UNLOCK(self.failedURLsLock); &#125; BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); // We've done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale. if (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123; downloadedImage = [self scaledImageForKey:key image:downloadedImage]; &#125; if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123; // Image refresh hit the NSURLCache cache, do not call the completion block &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; @autoreleasepool &#123; UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url]; if (transformedImage &amp;&amp; finished) &#123; BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; NSData *cacheData; // pass nil if the image was transformed, so we can recalculate the data from the image if (self.cacheSerializer) &#123; cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url); &#125; else &#123; cacheData = (imageWasTransformed ? nil : downloadedData); &#125; [self.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil]; &#125; [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125; &#125;); &#125; else &#123; if (downloadedImage &amp;&amp; finished) &#123; if (self.cacheSerializer) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; @autoreleasepool &#123; NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url); [self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil]; &#125; &#125;); &#125; else &#123; [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil]; &#125; &#125; [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125; &#125; if (finished) &#123; [self safelyRemoveOperationFromRunning:strongSubOperation]; &#125; &#125;]; &#125; else if (cachedImage) &#123; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; [self safelyRemoveOperationFromRunning:strongOperation]; &#125; else &#123; // Image not in cache and download disallowed by delegate [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url]; [self safelyRemoveOperationFromRunning:strongOperation]; &#125; &#125;]; return operation;&#125; SDWebImageOperation协议@protocol SDWebImageOperation &lt;NSObject&gt;- (void)cancel;@end///SDWebImageCombinedOperation的实现@implementation SDWebImageCombinedOperation- (void)cancel &#123; @synchronized(self) &#123; self.cancelled = YES; if (self.cacheOperation) &#123; [self.cacheOperation cancel]; self.cacheOperation = nil; &#125; if (self.downloadToken) &#123; ///根据downloadToke，对应的operation取消下载.[imageDownloader,是一个全局单例..sd里面单例模式用的很多] [self.manager.imageDownloader cancel:self.downloadToken]; &#125; [self.manager safelyRemoveOperationFromRunning:self]; &#125;&#125;///相关单列///SDWebImageManager 自身是一个单列的实现@implementation SDWebImageManager+ (nonnull instancetype)sharedManager &#123; static dispatch_once_t once; static id instance; dispatch_once(&amp;once, ^&#123; instance = [self new]; &#125;); return instance;&#125;- (nonnull instancetype)init &#123;///其内部cache和downloader，分别是两个单例。 SDImageCache *cache = [SDImageCache sharedImageCache]; SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader]; return [self initWithCache:cache downloader:downloader];&#125; 下载流程SDWebImageManager(单例) -&gt; SDWebImageCombinedOperation-&gt; {SDImageCache(单例)-&gt;queryCache-&gt;if no -&gt;SDWebImageDownloader(单例)-&gt;downloadImage} 图片异步下载的实现（包括单个下载的请求组装，状态控制，回调处理，图片预解压等） ///sd里面实现了一个SDWebImageDownloaderOperation的具体类。是命令模式的一种应用。///这里实现了二个协议，第一个协议实际上是包含了urlsession的两个系统协议。后面贴上。这里比较重要的是，如果你看SDWebImageDownloader的实现文件，你会发现，也实现了&lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;协议。////@interface SDWebImageDownloader () &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;，并在SDWebImageDownloader中统一把事情回调到SDWebImageDownloaderOperation类中。这样能使类的职责更清晰，图片解压后续等处理能封装到具体的SDWebImageDownloaderOperation类中，更合适而更内聚。例如===========- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; // Identify the operation that runs this task and pass it the delegate method NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = [self operationWithTask:task]; if ([dataOperation respondsToSelector:@selector(URLSession:task:didCompleteWithError:)]) &#123; [dataOperation URLSession:session task:task didCompleteWithError:error]; &#125;&#125;===========@interface SDWebImageDownloaderOperation : NSOperation &lt;SDWebImageDownloaderOperationInterface, SDWebImageOperation&gt;/** * The request used by the operation's task. */@property (strong, nonatomic, readonly, nullable) NSURLRequest *request;/** * The operation's task */@property (strong, nonatomic, readonly, nullable) NSURLSessionTask *dataTask;@property (assign, nonatomic) BOOL shouldDecompressImages;/** * Was used to determine whether the URL connection should consult the credential storage for authenticating the connection. * @deprecated Not used for a couple of versions */@property (nonatomic, assign) BOOL shouldUseCredentialStorage __deprecated_msg(\"Property deprecated. Does nothing. Kept only for backwards compatibility\");/** * The credential used for authentication challenges in `-URLSession:task:didReceiveChallenge:completionHandler:`. * * This will be overridden by any shared credentials that exist for the username or password of the request URL, if present. */@property (nonatomic, strong, nullable) NSURLCredential *credential;/** * The SDWebImageDownloaderOptions for the receiver. */@property (assign, nonatomic, readonly) SDWebImageDownloaderOptions options;/** * The expected size of data. */@property (assign, nonatomic) NSInteger expectedSize;/** * The response returned by the operation's task. */@property (strong, nonatomic, nullable) NSURLResponse *response;/** * Initializes a `SDWebImageDownloaderOperation` object * * @see SDWebImageDownloaderOperation * * @param request the URL request * @param session the URL session in which this operation will run * @param options downloader options * * @return the initialized instance */- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request inSession:(nullable NSURLSession *)session options:(SDWebImageDownloaderOptions)options NS_DESIGNATED_INITIALIZER;/** * Adds handlers for progress and completion. Returns a tokent that can be passed to -cancel: to cancel this set of * callbacks. * * @param progressBlock the block executed when a new chunk of data arrives. * @note the progress block is executed on a background queue * @param completedBlock the block executed when the download is done. * @note the completed block is executed on the main queue for success. If errors are found, there is a chance the block will be executed on a background queue * * @return the token to use to cancel this set of handlers */- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;/** * Cancels a set of callbacks. Once all callbacks are canceled, the operation is cancelled. * * @param token the token representing a set of callbacks to cancel * * @return YES if the operation was stopped because this was the last token to be canceled. NO otherwise. */ ///取消操作- (BOOL)cancel:(nullable id)token; SDWebImageDownloaderOperationInterface继承了&lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;协议。@protocol SDWebImageDownloaderOperationInterface &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;@required- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request inSession:(nullable NSURLSession *)session options:(SDWebImageDownloaderOptions)options;- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;- (BOOL)shouldDecompressImages;- (void)setShouldDecompressImages:(BOOL)value;- (nullable NSURLCredential *)credential;- (void)setCredential:(nullable NSURLCredential *)value;- (BOOL)cancel:(nullable id)token;@optional- (nullable NSURLSessionTask *)dataTask; 图片解压部分，使用了面相协议的方式把多个类型的图片解压方法分散到各个具体类中。贴近于工厂模式，创建多个产品。并使用统一的一套接口，使调用者只面向抽象接口调用，不面向具体的类接口调用，利于具体类的切换。@protocol SDWebImageCoder &lt;NSObject&gt;@required#pragma mark - Decoding- (BOOL)canDecodeFromData:(nullable NSData *)data;- (nullable UIImage *)decodedImageWithData:(nullable NSData *)data;- (nullable UIImage *)decompressedImageWithImage:(nullable UIImage *)image data:(NSData * _Nullable * _Nonnull)data options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict;#pragma mark - Encoding- (BOOL)canEncodeToFormat:(SDImageFormat)format;- (nullable NSData *)encodedDataWithImage:(nullable UIImage *)image format:(SDImageFormat)format;@end=====实现协议的具体类@interface SDWebImageGIFCoder : NSObject &lt;SDWebImageCoder&gt;@interface SDWebImageCodersManager : NSObject&lt;SDWebImageCoder&gt; 请求并发控制。 - (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration &#123; if ((self = [super init])) &#123; _operationClass = [SDWebImageDownloaderOperation class]; _shouldDecompressImages = YES; _executionOrder = SDWebImageDownloaderFIFOExecutionOrder; _downloadQueue = [NSOperationQueue new]; ///并发控制，利用了苹果封装的queue提供的功能 _downloadQueue.maxConcurrentOperationCount = 6; _downloadQueue.name = @\"com.hackemist.SDWebImageDownloader\"; _URLOperations = [NSMutableDictionary new]; SDHTTPHeadersMutableDictionary *headerDictionary = [SDHTTPHeadersMutableDictionary dictionary]; NSString *userAgent = nil; ///组装userAgent头#if SD_UIKIT // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43 userAgent = [NSString stringWithFormat:@\"%@/%@ (%@; iOS %@; Scale/%0.2f)\", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@\"CFBundleShortVersionString\"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];#elif SD_WATCH // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43 userAgent = [NSString stringWithFormat:@\"%@/%@ (%@; watchOS %@; Scale/%0.2f)\", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@\"CFBundleShortVersionString\"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[WKInterfaceDevice currentDevice] model], [[WKInterfaceDevice currentDevice] systemVersion], [[WKInterfaceDevice currentDevice] screenScale]];#elif SD_MAC userAgent = [NSString stringWithFormat:@\"%@/%@ (Mac OS X %@)\", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@\"CFBundleShortVersionString\"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[NSProcessInfo processInfo] operatingSystemVersionString]];#endif if (userAgent) &#123; if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) &#123; NSMutableString *mutableUserAgent = [userAgent mutableCopy]; if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@\"Any-Latin; Latin-ASCII; [:^ASCII:] Remove\", false)) &#123; userAgent = mutableUserAgent; &#125; &#125; headerDictionary[@\"User-Agent\"] = userAgent; &#125;#ifdef SD_WEBP headerDictionary[@\"Accept\"] = @\"image/webp,image/*;q=0.8\";#else headerDictionary[@\"Accept\"] = @\"image/*;q=0.8\";#endif _HTTPHeaders = headerDictionary; _operationsLock = dispatch_semaphore_create(1); _headersLock = dispatch_semaphore_create(1); _downloadTimeout = 15.0; [self createNewSessionWithConfiguration:sessionConfiguration]; &#125; return self;&#125; 图片缓存机制的实现 - (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns diskCacheDirectory:(nonnull NSString *)directory &#123; if ((self = [super init])) &#123; NSString *fullNamespace = [@\"com.hackemist.SDWebImageCache.\" stringByAppendingString:ns]; // Create IO serial queue ///串行队列,保证读写安全 _ioQueue = dispatch_queue_create(\"com.hackemist.SDWebImageCache\", DISPATCH_QUEUE_SERIAL); _config = [[SDImageCacheConfig alloc] init]; // Init the memory cache ///内存缓存管理 _memCache = [[SDMemoryCache alloc] initWithConfig:_config]; _memCache.name = fullNamespace; // Init the disk cache if (directory != nil) &#123; _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace]; &#125; else &#123; NSString *path = [self makeDiskCachePath:ns]; _diskCachePath = path; &#125; dispatch_sync(_ioQueue, ^&#123; self.fileManager = [NSFileManager new]; &#125;); #if SD_UIKIT // Subscribe to app events ////deleteOldFiles 与 backgroundDeleteOldFiles是内存和磁盘安全管理策略的执行方法 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deleteOldFiles) name:UIApplicationWillTerminateNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundDeleteOldFiles) name:UIApplicationDidEnterBackgroundNotification object:nil];#endif &#125; 磁盘管理的安全策略 - (void)deleteOldFiles &#123; [self deleteOldFilesWithCompletionBlock:nil];&#125;- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123; dispatch_async(self.ioQueue, ^&#123; NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES]; // Compute content date key to be used for tests NSURLResourceKey cacheContentDateKey = NSURLContentModificationDateKey; switch (self.config.diskCacheExpireType) &#123; case SDImageCacheConfigExpireTypeAccessDate: cacheContentDateKey = NSURLContentAccessDateKey; break; case SDImageCacheConfigExpireTypeModificationDate: cacheContentDateKey = NSURLContentModificationDateKey; break; default: break; &#125; NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, cacheContentDateKey, NSURLTotalFileAllocatedSizeKey]; // This enumerator prefetches useful properties for our cache files. NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:resourceKeys options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL]; NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge]; NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary]; NSUInteger currentCacheSize = 0; // Enumerate all of the files in the cache directory. This loop has two purposes: // // 1. Removing files that are older than the expiration date. // 2. Storing file attributes for the size-based cleanup pass. NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init]; for (NSURL *fileURL in fileEnumerator) &#123; NSError *error; NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error]; // Skip directories and errors. if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123; continue; &#125; // Remove files that are older than the expiration date; NSDate *modifiedDate = resourceValues[cacheContentDateKey]; if ([[modifiedDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123; [urlsToDelete addObject:fileURL]; continue; &#125; // Store a reference to this file and account for its total size. NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize += totalAllocatedSize.unsignedIntegerValue; cacheFiles[fileURL] = resourceValues; &#125; for (NSURL *fileURL in urlsToDelete) &#123; [self.fileManager removeItemAtURL:fileURL error:nil]; &#125; // If our remaining disk cache exceeds a configured maximum size, perform a second // size-based cleanup pass. We delete the oldest files first. if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123; // Target half of our maximum cache size for this cleanup pass. const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2; // Sort the remaining cache files by their last modification time or last access time (oldest first). NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return [obj1[cacheContentDateKey] compare:obj2[cacheContentDateKey]]; &#125;]; // Delete files until we fall below our desired cache size. for (NSURL *fileURL in sortedFiles) &#123; if ([self.fileManager removeItemAtURL:fileURL error:nil]) &#123; NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL]; NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize -= totalAllocatedSize.unsignedIntegerValue; if (currentCacheSize &lt; desiredCacheSize) &#123; break; &#125; &#125; &#125; &#125; if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;);&#125; 其他线程安全的处理，锁的应用 #define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);#define UNLOCK(lock) dispatch_semaphore_signal(lock);///多线程中读写安全，通过锁保证，主要是数组和字典的读写操作安全；并包含其操作的整个代码段都要通过加锁保证其原子性。例子 LOCK(self.weakCacheLock); // Do the real copy of the key and only let NSMapTable manage the key's lifetime // Fixes issue #2507 https://github.com/SDWebImage/SDWebImage/issues/2507 [self.weakCache setObject:obj forKey:[[key mutableCopy] copy]]; UNLOCK(self.weakCacheLock);===== LOCK(self.headersLock); if (value) &#123; self.HTTPHeaders[field] = value; &#125; else &#123; [self.HTTPHeaders removeObjectForKey:field]; &#125; UNLOCK(self.headersLock); ====== LOCK(self.callbacksLock); NSMutableArray&lt;id&gt; *callbacks = [[self.callbackBlocks valueForKey:key] mutableCopy]; UNLOCK(self.callbacksLock); ///外观模式(通过face层去调用，内部调用更高级的子系统接口。)提供多个外部接口，内部通过调用一个更高级的子接口来现实。@interface UIImageView (WebCache)- (void)sd_setImageWithURL:(nullable NSURL *)url NS_REFINED_FOR_SWIFT;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder NS_REFINED_FOR_SWIFT; =======- (void)sd_setImageWithURL:(nullable NSURL *)url &#123;///多级调用 [self sd_setImageWithURL:url placeholderImage:nil options:0 progress:nil completed:nil];&#125;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder &#123; [self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:nil];&#125; 四、使用的设计模式单例模式、命令模式、工厂模式、外观模式 五、利用语言特性的相关技巧 runtime关联对象 信号量作为锁的使用 六、SDWebImage官方类图 七、SDWebImage官方时序图","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://zengbailiang.cn/categories/源码阅读/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://zengbailiang.cn/tags/源码阅读/"},{"name":"设计分析","slug":"设计分析","permalink":"https://zengbailiang.cn/tags/设计分析/"}]},{"title":"2018年终总结泛篇","slug":"2019-01-01-2018总结泛篇","date":"2018-12-31T16:00:00.000Z","updated":"2019-01-06T13:10:21.326Z","comments":true,"path":"2019-01-01-2018总结泛篇.html","link":"","permalink":"https://zengbailiang.cn/2019-01-01-2018总结泛篇.html","excerpt":"","text":"2018年的不足2018年对自己而言是比较失意的一年，但也未尝没有收获。尽力而为，果上随缘可以概况了这一年的总基调。虽然内心如此想，但尽力真的很难，个人的劣根性，懒惰、目光不够长远，低估自己等等不足，为这一年带来了很多挫折。 就各个不足回顾下： 懒惰：也不知道是不是懒惰，就是如果让你来啃教科书，或者让你去看部电影,或者睡懒觉，那个舒服，其他人的选择尚不清楚，但我想有一部分人会选择舒服的方式去消磨掉时间，就这样舒服成为了懒惰的一大原因。另外一个是，即使深知如此，依然很难摆脱这个劣根性，很难，就算你有一定的目标，但这种长远的考虑，在短期内没有收获，意志就会被慢慢消磨。查阅网上资料，发现实坚持真的不容易，也有一些通过奖励的方式去辅助等等。总之，这方面，自己做的很差，一定程度上的原因有贪图安逸、目标不够坚定、缺乏长期规划、实际可行的执行方案等。 目光短浅：虽然我试图想象，我把这些要做的事情全部做完，会变成怎么样，是否与自己的初衷相符，或者是否达到自己目标的预期，等等。但未来是很不明显的，当所掌握的信息极其的有限，很有可能会在这极其有限的信息中做出不那么正确的判断，在基于这样的判断下预期很难想象。这样就导致，中途可能会变换目标，或者使本来执行的事情搁置或放弃。另外目标短浅，就当前比较突出的是缺乏短期计划、中期计划、长期计划。 低估自己：如果没有上面两大缺点，或者上面两大缺点没有那么大，可能就不会过分的低估自己。这里面实际是存在些矛盾。客观来说，一些看似遥不可及的东西，也许通过一些努力，慢慢靠近也并非所想的难以靠近，通常来说这些东西本来就是需要努力去获取的，而差距和鸿沟需要努力去一步一步填补的。一个一直努力的人，和一个吊儿郎当的人差距是很大的，即使两个人的资质相差不大。当你有想法的时候，却发现能力不够，是悔恨浪费的时光，还是坦然面对过去，努力迎接未来?就算此刻努力，却有更多的患得患失，因为最好的时机已经错过，你没有在最该走这条路的时候走好，是挣扎还是要放弃呢？如果一些你本来能做到的事情，到最后却没法做到，一定会很悔恨与不甘吧。过去低估自己，现在是否还要低估自己？2018年对自我的认识依然不够，性格上依然有很大的问题，导致一些判断和考虑错误。其实这里并不是低估自己，而是人的潜力是很大的，忽略这一点，就如低估自己一样。 收获：失败后的失落会让你面对现实，也许是这样的经历比较锻炼心智，让人变得成熟，大概是类似吃一堑长一智。经历过才印象深刻，才把这回事当成一回事。所以从这一点看，老人家说的很多是良言善语，只是我们的经历不够，难以深刻体会，依然要继续走弯路，直到吃了苦，才真正的明白个中的意思。这个也许是个生物特征的东西，很难改变，调整思维或者更早去经历，都是对的。但我更多的是那种把回事不当回事的人，所以啊，吃了不少暗亏。而这个收获就是经历后、体会过之后，思想的改变。在这个阶段，总之对比以前的自己，我更喜欢现在的自己。因此我对自己说过，经历过生活的洗礼后，要变得越来越喜欢自己。这个也是作为检测自己的一个标准。 2019目标： 定好学习目标与计划，持续提高。 改善懒惰。 目光放长远点，职业/生活/理财等。 对自己的认识，依然要不断改善，要努力积极向上。 比较重要的几点记录下来： 对于比较重要的事情，一定要考虑周全，查询一切可以查询的资料，把一件事情当做打仗来看，分清双方形势，考虑冒进/稳妥/更稳妥的三套以上的方案，同时要分清楚自己的情况与事件的关系。来自外界的意见要以主观为主加以分析，思前想后，分清主次，稳妥为主，否则可能会出现捡了芝麻丢了西瓜，甚至竹篮打水一场空的尴尬境地。 一直以来，都有不少与人争论的场合，通常对于一个问题，不同的人可能会有不同的意见，达成共识有时候并不是一件容易的事情。2019非原则问题，尽量避免争论。当然要继续保持包容和开放的心去接纳不同的意见。尊重事实，而不是奉承。这里其实有一个值得深思的问题，导致辩论的一大原因可能不是因为坚持自己的意见，甚至不是因为还是觉得自己的意见正确。而是来自人性的一部分，也许跟性格也是相关的。如果被别人纠正，意味着自己的不对，意味者局部性的不如人，也许是个性中的好强，这样内心就会难受，所以会出于这种理由要继续辩解并固执己见。这不过是一个个人的看法，实际上如何，原因应该很多样化，但如果自己本身去探究下为何会这样，大概多少能理解别人为何如此了。至少我要做到以事实为准，以更合理的为准，包容与接纳，减少争论。 君子之交淡如水，给与各自恰当的距离与空间，让大家都保持一种舒适的状态，这个是要往后学习与实践的。 情商需要提高，结合场景多思考合适的回答，形成思维回路，加强矛盾场景的锻炼。 提高专注度，做自己的事情，外界信息，要为自己所用，而不是要被外界影响。 今日事今日毕。改善拖延症，要做的事就是一个队列，如果拖，有些事就变得不了了之了，所有要改善拖延症。 踏实向上，加强时间管理，缄默慎言。 修心养性方面： 可以的话2019要去多出去看看风景，留下多点关于旅途的回忆。 要学会照顾自己，品味生活。 小结：以上感觉总结的很泛，但也是一些心里话，记录下来。","categories":[{"name":"总结","slug":"总结","permalink":"https://zengbailiang.cn/categories/总结/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://zengbailiang.cn/tags/随笔/"}]},{"title":"iOS 多线程安全","slug":"2018_08_05_iosSaftThread","date":"2018-08-04T16:00:00.000Z","updated":"2018-08-06T13:38:38.639Z","comments":true,"path":"2018_08_05_iosSaftThread.html","link":"","permalink":"https://zengbailiang.cn/2018_08_05_iosSaftThread.html","excerpt":"","text":"线程安全的概念如果在多线程的场景下，运行一段程序，不会出现预料之外的结果。可以认为这段程序是线程安全的。 导致线程不安全的原因当多线程访问同一个代码段的时候，共享变量的信息可以被各个访问它的线程所修改，以致于某个线程执行完代码块后出现期望之外的结果，甚至使线程崩溃。 __block int i = 0; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for (int j= 0 ; j &lt; 1000; j++) &#123; i ++; &#125; NSLog(@\" a thread: %d\",i); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for (int j= 0 ; j &lt; 1000; j++) &#123; i ++; &#125; NSLog(@\"b thread: %d\",i); &#125;); 其中一种结果： 2018-08-05 15:30:10.299750+0800 safeThreadTest[16566:2770764] a thread: 10552018-08-05 15:30:10.299750+0800 safeThreadTest[16566:2770766] b thread: 1965 与期待的1000 和2000 不一致。 避免线程不安全避免线程不安全的关键是在原子操作，对需要原子操作的代码片段，通过加锁保证其线程安全。 __block int i = 0;NSLock *lock = [NSLock new];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lock]; for (int j= 0 ; j &lt; 1000; j++) &#123; i ++; &#125; NSLog(@\" a thread: %d\",i); [lock unlock];&#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lock]; for (int j= 0 ; j &lt; 1000; j++) &#123; i ++; &#125; NSLog(@\"b thread: %d\",i); [lock unlock];&#125;); 稳定的结果： 2018-08-05 15:34:46.495629+0800 safeThreadTest[16758:2774646] a thread: 10002018-08-05 15:34:46.495806+0800 safeThreadTest[16758:2774644] b thread: 2000 iOS中的atomic与nonatomic使用atomic定义的属性，系统为其默认生成的setter和getter方法是加锁的，setter操作与getter操作是互斥的原子操作。而使用nonatomic定义的属性，系统为其默认生产的setter和getter是不加锁的，两者的操作不互斥，同时也不具备原子性。 由于nonatomic是不加锁的，所以性能是比atomic高。而我们在开发过程中一般也是使用该属性。因为atomic只能保证属性的读写原子操作，并不能保证线程安全，在多线程编程中依然要根据代码的具体功能划分原子操作的范围，通过加锁来保证线程安全。除非原子操作范围就是这个属性的读与写，否则是没有必要定义成atomic，因为线程安全已经通过外层加锁处理。 系统是通过地址总线寻址，数据总线存取数据的。而且数据总线只有一个，其访问内存是串行操作。假定数据总线宽度为64位，数据长度超过64位，那么数据总线就必须多次访问内存。如果数据长度少于数据总线宽度，读写总是串行的，也即是其操作是原子的。int、bool、float、double等操作总是原子操作，同时在定义时无需指定atomic，避免系统增加不必要的加锁操作。而不定长度的数据类型，就有必要根据实际情况定义atomic或nonatomic。 iOS中锁的使用 名称 说明 性能 OSSPinLock 自旋锁 高 dispatch_semaphore_t 信号量 高 pthread_mutex linux提供的互斥锁 高 NSLock OC提供的互斥锁 一般 pthread_mutex(recursive) linux提供的互斥锁 一般 NSCondition 作为锁和线程检查器，有wait/signal方法 一般 NSRecursiveLock 递归锁 一般 NSConditionLock 条件锁，内部包含一个NSCondition对象 低 @synchronized 互斥锁 低 加锁性能不能代表具体程序运行锁的性能。加锁快可能跟锁的实现简单，费时少有关。但使用中锁的性能跟线程等待采用的方式是休眠还是忙等有关。自旋锁由于优先级反转的问题已经不能使用，iOS10有替代版本。常规开发使用简单的NSLock、@synchronized等已经能满足大部分需求，性能要求高再考虑使用信号量等。 总结以上线程安全、锁做简单的总结和理解。如果在开发中，还是要尽量避免多线程设计，搞不好出现死锁，也不好调试。程序的稳定安全比程序的性能更重要。要在确保程序的稳定和线程安全的情况下，再去提高程序的性能。 参考：iOS多线程到底不安全在哪里？不再安全的 OSSpinLock","categories":[{"name":"iOS","slug":"iOS","permalink":"https://zengbailiang.cn/categories/iOS/"}],"tags":[{"name":"线程安全","slug":"线程安全","permalink":"https://zengbailiang.cn/tags/线程安全/"}]},{"title":"进程与线程","slug":"2018_08_04_processAndThread","date":"2018-08-03T16:00:00.000Z","updated":"2018-08-04T14:05:51.608Z","comments":true,"path":"2018_08_04_processAndThread.html","link":"","permalink":"https://zengbailiang.cn/2018_08_04_processAndThread.html","excerpt":"","text":"进程 定义：是一个程序及其数据在处理机上执行时所发生的活动。 程序与进程的区别：程序是一组有序指令的集合，是静态的。而进程是动态的，由创建而产生，由调度而执行，由撤销而消亡。进程具有并发性，可并发执行。进程具备独立性，是接受资源和接受调度的基本单位（是资源分配的最小单位，而调度的最小单位是线程）。进程具有异步性，即按各自独立和不可预知的速度向前推进。进程的三种基本状态： 就绪：已获取除cpu执行权以外的所有资源，只要获得cpu执行权，便可立即执行。就绪线程通常放到一个就绪队列中。 执行：获取cpu执行权，处于执行状态中。 阻塞：当进程执行被打断时，处理器会发起调度，把执行权给予其他就绪进程，而当前进程进入阻塞状态。阻塞状态的进程，会被放进系统的阻塞队列中，等待被唤醒。导致阻塞的几种情况。 向系统请求共享资源失败。 等待某种操作完成。发起IO-》阻塞-》需等IO任务执行完成-》中断处理程序唤醒-》就绪 等待新任务到达。 进程的挂起与唤醒：当系统资源不足的时候，会去挂起就绪或堵塞进程，把它们放入外存以释放内存资源。同时执行挂起原语suspend能主动挂起进程。就绪进程挂起变为静态就绪状态，阻塞进程挂起变为静态阻塞状态，执行中的进程被挂起进入静态就绪状态。当静态就绪状态被激活，加载到内存中，就恢复到活动就绪状态。静态阻塞被激活醒就变为活动阻塞。 状态转换如下图： 阻塞与唤醒过程： 挂起与激活过程： 进程控制块PCBpcb的作用 作为进程实体的一部分，记录了操作系统所需的，用于描述进程当前情况及管理进程运行的全部信息，是操作系统中最中最重要的记录型数据结构。 能实现间断性运行方式，能保存运行的上下文，用于下次执行。 提供进程管理所需的信息。记录了程序和数据在内存或外存中的地址指针。 提供进程调度所需的信息，进程优先级、所处状态等。 实现与其他进程同步与通信。如果使用信号量，进程中必须都设置相应的用于同步的信号量。关于通信，pcb中有用于实现进程通信的区域或通信队列指针等。 pcb中的信息 进程唯一标识符，外部标识符（用户调用）和内部标识符（系统调用）。 处理机状态，也称处理机上下文。主要由处理机的各种寄存器中的内容组成的。寄存器类型包括：1.通用寄存器，用于暂存信息。2.指令计数器，存放下一条指令的地址。3.程序状态字PSW，包含状态信息（条件码、执行方式、中断屏蔽标志）。4.用户栈指针，指向的栈中，存放调用参数和调用地址。 当进程被切换时，处理机信息都必须保存在pcb中，当再次运行的时候，能从原状态恢复。同时，如果进程频繁切换，带来的时空开销是很大的。 进程同步临界资源：一次只允许一个进程使用的资源。例如一些硬件资源，打印机、磁带机等。进程间应采用互斥方式，实现对这种资源的共享。 临界区：访问公共资源的代码片段。 原则： 空闲让进：无程序处于临界区时，代表临界资源空闲，允许请求进入的进程访问。 忙则等待：如果临界资源被访问中，请求访问必须等待，实现互斥。 有限等待：保证在有限时间内能进入自己的临界区，避免死等。 让权等待：当进程无法进入临界区时，释放处理机，避免陷入忙等。此原则应该是在有限等待无法实现的情况下执行。 信号量机制 wait(s),signal(s)基本操作，属于原子操作，执行过程不可中断。当s = 1的时候可以实现互斥同步功能。 semaphore mutex = 1; ... wait(mutex); //临界区 signal(mutex); ... 通过wait，signal能保证临界区同时只能允许一个进程进入。当临界区繁忙时，其他行程访问临界区，执行wait操作会失败，同时进程会进入阻塞。 进程通信 管道系统pipe,接收发送通过共享文件（pipe文件）的方式进行通信。 消息传递系统，send(receiver,message),receive(sender,message) 客户机-服务器系统，通过socket套接字 死锁死锁：如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。 进程饥饿：进程一直获取不到资源。 可抢占资源：能被其他线程抢占的资源。该类资源的抢占不会导致死锁的产生。如处理机、内存空间等。 不可抢占资源：一旦被分配了，不能强行回收，只能等线程释放。如打印机、刻录机等。 死锁产生的几种情况： 竞争不可抢占资源，导致互相等待对方释放资源。双方都必须拥有对方要访问的资源。不能通过调整代码顺序解决。 竞争可消耗资源（中断信号、系统通知等）。循环等待消息的接受，才执行消息的发送，导致死锁。能通过调整代码的执行顺序解决。大家都想获取到消息资源，而等待的消息资源，只有其他人能发出。由于循环等待，导致消息无法发出。属于可消耗资源的竞争。 程序的推进顺序非法。该情况不属于资源使用，但导致死锁也就是出现互相等待的局面或则循环等待的局面。 死锁产生的条件： 互斥条件：分配的资源，同一时间只能被一个进程访问，直到其释放。 请求和保存条件：请求新的资源，同时保存自己已拥有的某个资源不释放,这个不释放的资源就是别人要获取的资源。 不可抢占条件：访问的资源不可被抢占。这样就无法通过抢占的方式解决阻塞。 循环等待条件：这是出现死锁的一个结果，由于前面的几个条件的同时存在才有可能出现这个循环等待的结果，如果这个结果出现，那么意味着出现死锁。 死锁的处理方法： 预防死锁：通过某些限制条件破坏死锁的四个条件，防止死锁的产生。属于事先预防。 避免死锁：在系统资源动态分配的过程中，通过某种方式，防止进程进入不安全区域，避免死锁的发生。输入事先预防。 检测与解除死锁：使用某些方式检测死锁的产生并解除死锁。可通过撤销进程，终止进程等方式，释放资源。 线程20世纪60年代OS系统引入进程解决程序并发问题，80年代提出比进程更小的单位线程。90年代出现多核处理机，线程能更好的发挥处理机的性能。线程是为了提高并发性以及进行相互之间合作而创建的。而现在进程更多的是作为线程的容器，程序的并发执行通过线程来实现。 进程与线程的比较：1.调度角度： 进程过重，是独立运行的基本单位，进程每次调度都需要切换上下文，时空开销大。而线程切换仅仅需要保持和设置少量的寄存器内容，切换代价远低于进程。2. 资源角度：作为资源调度的基本单位，进程拥有独立资源。而线程本身不拥有系统资源，其仅有一点必不可少的能保证独立运行的资源（TCB、程序计数器、保留局部变量、状态参数、返回地址等一组寄存器和堆栈）。3. 独立性角度：进程间相对独立，出了通过少量的全局变量实现共享。线程资源允许别的线程共享，同一进程的所有线程共享同一个内存地址空间和进程资源。4. 稳定性：进程之间除了共享全局变量外，不允许其他进程访问。而线程因为共享同一个进程的内存地址空间和资源，甚至其线程堆栈都能被其他线程读取和清楚。多进程比多线程稳定，但协同能力多线程更强。 线程控制块TCB包含信息： 线程标识符 线程运行状态（就绪、阻塞、执行） 优先级 堆栈指针（调用过程的局部变量和返回地址） 线程专有存储区，用于保存切换时的线程上下文和一些统计信息。 信号屏蔽，对某些信号加以屏蔽。 一组寄存器，程序计数器寄存器PC、通用寄存器。 程序计数器寄存器，用于存储下一条程序指令地址。 通用寄存器，用于存送和暂存数据，也可参与算术逻辑运算并保存结果。 两个指向堆栈的指针，执行自己堆栈的指针和指向核心栈的指针。前者是当线程运行在用户态时使用自己的堆栈来保存局部变量和函数返回地址，后者是线程运行在核心态的时候使用系统核心栈。 线程的实现内核支持线程创建、阻塞、撤销和切换都在内核空间实现。 优点： 对多处理器系统来说，内核能调度同一进程中的多个线程实现真正意义的并发执行。 当进程中的一个线程阻塞了，能调度进程中的其他线程执行，甚至能调度其他进程中的线程执行，前提是这个线程必须是核心态。 内核线程具有很小的数据结构和堆栈，切换开销小。 缺点：用户如果要切换进程中的线程，需要把线程从用户态切换到核心态，因为线程调度由内核控制，系统开销较大。 用户级线程在用户空间中实现。用户级线程的一切操作对内核都是透明的。但是这种线程就不能实现真正意义的并发，系统调度以进程为单位。如果A进程实现了1个用户级线程，而B进程实现了100个用户级线程，那么A中线程获得的执行时间是B中线程的100倍。而内核支持线程，以线程为调度单位。 组合方式 一对多。用户线程映射到一个核心线程。如果核心线程阻塞了，就无法正常工作。 一对一。核心线程的数据与用户线程的数量一样，一一映射。发送阻塞能调度其他线程，但每个用户线程就对应一个核心线程，导致系统开销大，需要全局限制线程的数量。 多对多。存在多个核心线程用于映射用户线程，避免了系统开销过大，也避免了阻塞导致不能正常工作的问题。集合了1和2的优点。 内核支持线程的实现创建进程的时候，分配一个PTDA(per task data area),其中包含若干线程控制块TCB空间。当一个新内核线程被创建时，系统会分配TCB和相关资源。线程销毁时资源被回收，但也可以先不回收，等候新的线程被创建时服用其TCB。 用户级线程的实现在用户空间实现的，线程运行在运行时系统上（runtime system）。线程切换时不需要切换到核心态，切换速度快。申请资源需要通过runtime system间接申请。 内核控制线程：又称lwp（light weight process）。lwp可通过系统调用来获得内核提供的服务，当用户级线程连接到lwp上，就能具有内核支持线程的所有属性（调度方式，按线程调度）。lwp是用户线程与内核线程沟通得桥梁，同时起到用户线程与内核线程的隔离作用。用户线程可能很多，为了节省系统开销，不能设置过多的lwp，通过多路复用的方式实现lwp线程池，如果没有可用lwp那么用户线程进入等待。lwp阻塞可用去连接别的lwp，就算lwp全部阻塞也不妨碍线程执行任务，但不能访问内核了。 优先级倒置当优先级高的线程访问临界资源，而这个临界资源被优先级低的线程占用。此时就会发生优先级倒置。如果此时存在三个优先级a,b,c,c 为低优先级且占用临界资源，a为高优先级需要访问临界资源，b为中优先级不需要访问临界资源。当a去访问资源的时候，发现无法访问，因为被c占用了，同时又存在b线程，b优先级比c高，系统调度去执行b，b执行完毕后，才有可能执行c，c释放临界资源后a才有可能执行。但如果存在多个如b2,b3,b4，那么a线程执行的时刻就会被大大延长。且a的执行被延长的时间不可预知和无法限定。 解决方案1：如果线程正在访问临界资源，设定为不可被抢占，这样其就能更快的退出临界区。但如果这样，当线程访问临界区时，调度对他是失效的。就算有很多优先级比他高的不需要访问临界资源的线程都没机会执行。如果其临界区很长，那么必然是不能接受和不合理的。 解决方案2：当高优先级线程因为访问临界资源被阻塞时，拥有临界资源的低优先级的线程继承高优先级线程的优先级，直到其退出临界区。这样既能不影响系统的正常调度，比他们更高的优先级的线程依然能执行，同时能避免介于他们中间的优先级的线程插入执行。 相比两个方案，方案二更优。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zengbailiang.cn/categories/计算机基础/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zengbailiang.cn/tags/计算机基础/"}]},{"title":"谈谈计算机内存","slug":"2018_07_29_Memory","date":"2018-07-28T16:00:00.000Z","updated":"2018-07-29T04:47:53.777Z","comments":true,"path":"2018_07_29_Memory.html","link":"","permalink":"https://zengbailiang.cn/2018_07_29_Memory.html","excerpt":"","text":"内存的访问 通过地址总线将地址送到内存，然后数据总线会把数据送到微处理器供给cpu使用。 32位总线可寻找范围为[0,2^32 - 1]相当于[0,4294967296]，即4GB。 物理地址到虚拟地址早期计算机是使用物理地址的，但是使用物理地址会存在以下几个问题： 地址空间不隔离 所有的程序都是使用物理地址访问，程序所使用的内存空间是不隔离的。程序可以被其他程序访问，对恶意访问或修改没有防护措施。程序的稳定性难以保证。 内存使用效率低 直接使用物理地址，必须是连续的。如果剩余的物理内存无法满足程序的空间分配，那么就需要把当前运行的某些程序写入磁盘，释放内存空间以供给需要运行的程序。当写入磁盘的程序被唤醒，系统会以同样的策略给该程序分配内存，内存条件满足后把程序读入内存。这里面存在很多的磁盘读写操作，导致内存使用效率低。原因1，使用物理地址，必须是连续的，不能充分的利用内存碎片，颗粒很大。原因2，磁盘读写的操作比较耗时，内存分配必须等待该操作的完成，这样相当于把内存使用的效率变低了。 程序运行地址不确定 系统给程序分配的空间不固定与程序编写时固定地址的数据访问和指令跳转产生冲突。这个冲突增加了编程难度。 虚拟地址为了解决使用物理地址存的问题，加入中间层，通过使用虚拟地址的方式访问程序。然后通过地址映射转换成成物理地址。由于每个程序只能访问自己的虚拟地址，只要妥善的控制这个映射关系，确保程序间的地址不重叠，就能实现程序间的内存地址相互隔离。 三、内存的存储管理方式 分段存储管理方式 地址的整块映射。物理地址分配也是连续的。 解决了地址空间不隔离、程序运行地址不确定的问题。但由于是连续地址，分配空间不足的情况下，需要对某些程序进行磁盘写入以释放空间，导致内存使用效率低的问题。 分页存储管理方式 解决了内存使用效率低的问题。对于每个程序来说，在某个时间段内，只会频繁的用到某部分数据。那么可以把那些不常用的数据存储于磁盘中并释放内存空间。通过分页的存储方式实现更细粒度的控制。内存的分页需要硬件支持，同时在硬件支持的基础上通过系统选择使用的方式。例如硬件支持4k和8k每页，系统选择4k。但是在运行过程中是不能切换分页方式的，也即是说，任意时刻分页方式都是确定的。目前几乎所有pc系统都使用4k大小的页。 内存共享：通过两个程序中的某些地址指向同一个物理页的方式实现。 写入磁盘的数据唤醒：当程序通过虚拟地址对写入磁盘的数据发起调用的时候，内存中并不存在并会发出页错误（pageFault），然后系统接管线程并把磁盘中的页数据读入内存，并恢复正常访问。 页的部分映射表会存储在一个叫TLB(Translation Look Aside Buffer)的寄存器，以提高内存的使用效率。因为把所有的映射表存储在内存中，cpu读取的时候需要两次访问内存。第一次访问页表，第二次才访问目标内存。这样会使访问效率变低。如果通过TLB保存常用的映射表，读取寄存器获取物理地址，能大大提高内存使用效率。TLB的容量有效，如果表满了会淘汰最老的不使用的页映射条目，这里应该有某类的淘汰算法来实现。 一般来说，只有当内存不足的时候才会把数据读入磁盘，也即是虚拟内存。 段页存储管理方式 分页和分段两种方式的结合，同时具备两者的优点。是应用最广泛的存储管理方式。 物理地址与虚拟地址直接的转换时通过硬件实现的。但几乎都是通过MMU（Memory Management Unit）这样的硬件实现的。MMU一般集成于cpu内部。 程序的内存布局 内核空间。 内存的部分空间分配给内核使用，这部分空间程序是无法访问的。例如，内存总量为4G，分配1~2G作内核使用。 栈 栈的作用：用于维护函数调用的上下文，离开栈函数的调用就无法执行。 栈的地址增长方向：跟cpu和os的实现方式有关，Linux是向下增长的，但在程序中显示的都是虚拟地址，不能用于判断其增长方向。 内存分布图： 栈保存了函数调用所需要维护的信息： 函数返回地址和参数 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。 保存上下文：包括函数调用前后要保持不变的寄存器。 i386中使用ebp和esp两个寄存器来为函数活动记录划分范围。esp始终指向栈的顶部，也即当前函数活动记录的顶部。而ebp则会指向函数的栈帧底部。当一个新的函数调用时压栈过程大概如下： 它的参数会先压栈(push params) 然后对其函数执行函数调用（call func），并把返回值地址填入栈。 保存之前的函数ebp，push ebp。 设置当前函数的栈帧底部mov esp, ebp。当前位置的栈顶esp就是当前函数的栈帧底部ebp。 然后执行新的栈帧，当栈帧执行完之后会用ret 返回参数。此时通过读取ebp的值，ebp就能返回到之前函数的栈帧底部，同时esp划过函数参数恢复到之前函数的栈顶。 另外还有一个eip寄存器，记录cpu下一次执行指令的地址。 堆 堆的作用：用来容纳应用程序动态分配内存。 堆内存的分配可以通过程序控制（malloc()），当内存不足的时候会交由系统分配（brk（）、mmap()）。 堆分配算法： 空闲链表 每个节点为包含起始地址和空闲大小。查找空闲空间的时候，通过遍历空闲链表查找合适空间。返回地址和大小，用于内存分配和释放。 存在缺点：链表被破坏，或者返回数据被破坏，那么会导致程序错误、甚至整个堆无法工作。因为空闲链表只记录空闲的数据，而不是全堆信息。如果大小字段错误，确实会导致整个堆无法工作，因为这种情况是无法判断出来的，无法估量整个堆的内存使用情况。 位图 把空闲内存划分为多个块，使用2个字节存储。假设每个块大小为x。堆空间大小为Y,那么数组的元素个数为y/x。每个块的地址也能通过公式计算出。那么我们返回数据的时候，会把第一个元素标记为头块（返回头快和后面跟随的块个数），后面的元素标记为主体块。那么块是有3种状态，空闲/头/主体，用用2bit表示。 优点：1. 只要分配块的大小适中，那么cache命中率会很高，速度快。2. 稳定性好，避免用户越界读写破败位图，作简单备份。即使部分数据受到破坏，也不会导致整个堆无法工作。因为位图是记录了整个堆的内存使用情况，就算部分数据受到破坏，使用保守策略不使用破坏的部分，而不会导致整个堆不可用。 缺点：1. 容易产生碎片。2. 块的大小太小，会导致cache命中率变低。可使用多级位图解决。 对象池 某些场合被分配的对象大小为固定的几个值。那么就按照这个大小分配块。可用位图或空闲链表实现。 而实际中，堆分配算法往往是采用多种算法复合而成的。 ps：部分图片来源于网络，如有侵权，请联系马上删除。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zengbailiang.cn/categories/计算机基础/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zengbailiang.cn/tags/计算机基础/"}]},{"title":"iOS 深复制与浅复制","slug":"2018_07_24_ios","date":"2018-07-23T16:00:00.000Z","updated":"2018-07-25T13:28:23.054Z","comments":true,"path":"2018_07_24_ios.html","link":"","permalink":"https://zengbailiang.cn/2018_07_24_ios.html","excerpt":"","text":"官方文档翻译ProtocolNSCopying(swift) A protocol that objects adopt to provide functional copies of themselves.对象采用的一种协议，用来提供拷贝自身元素的功能。 Overview The exact meaning of “copy” can vary from class to class, but a copy must be a functionally independent object with values identical to the original at the time the copy was made. A copy produced with NSCopying is implicitly retained by the sender, who is responsible for releasing it. 拷贝的确切意义会因类而异，但拷贝的必须是一个功能独立的对象并且其值在复制时跟 元素对象的值一样。通过NSCopying生成的副本会被发送者隐式持有，发送者负责其释放。 NSCopying declares one method, copy(with:), but copying is commonly invoked with the convenience method copy(). The copy() method is defined for all objects inheriting from NSObject and simply invokes copy(with:) with the default zone. NSCopying声明一个方法copy(with:)，但拷贝通常被便利方法copy()调用。copy()方法被所的继承NSObject的对象定义，并通过默认zone直接调用copy(with:)。 Your options for implementing this protocol are as follows: 您实现本协议的选项如下: Implement NSCopying using alloc and init… in classes that don’t inherit copy(with:). 在不继承copy(with:)的类中，使用alloc和init方法。 Implement NSCopying by invoking the superclass’s copy(with:) when NSCopying behavior is inherited. If the superclass implementation might use the NSCopyObject function, make explicit assignments to pointer instance variables for retained objects. 当NSCopying行为被继承时，通过调用父类的copy(with:)实现NSCopying。如果父类实现可能使用NSCopyObject方法，显式分配指针实例变量来持有对象。 Implement NSCopying by retaining the original instead of creating a new copy when the class and its contents are immutable. 当类及其内容是不可变的时，通过保留原始副本而不是创建新的副本来实现NSCopying。 If a subclass inherits NSCopying from its superclass and declares additional instance variables, the subclass has to override copy(with:) to properly handle its own instance variables, invoking the superclass’s implementation first. 如果一个子类继承其父类的NSCopying并声明额外的实例变量。子类必须重写copy(with:)方法来处理自身的实例变量，父类的copy(with:）方法会先被执行。 ProtocolNSMutableCopying(Object-c) A protocol that mutable objects adopt to provide functional copies of themselves. 可变对象采用的一种协议，用来提供拷贝自身元素的功能。 Overview The NSMutableCopying protocol declares a method for providing mutable copies of an object. Only classes that define an “immutable vs. mutable” distinction should adopt this protocol. Classes that don’t define such a distinction should adopt NSCopying instead. NSMutableCopying协议声明了一个方法，用于提供对象的可变副本。只有定义“不可变与可变”区别的类才应该采用此协议。没有定义这种区别的类应该采用NSCopying。 NSMutableCopying declares one method, mutableCopyWithZone:, but mutable copying is commonly invoked with the convenience method mutableCopy. The mutableCopy method is defined for all NSObjects and simply invokes mutableCopyWithZone: with the default zone. NSMutableCopying定义了一个方法mutableCopyWithZone。但可变拷贝一般通过便利方法mutableCopy调用。mutableCopy方法被所有的NSObjects定义并通过默认zone直接调用mutableCopyWithZone。 If a subclass inherits NSMutableCopying from its superclass and declares additional instance variables, the subclass has to override mutableCopyWithZone: to properly handle its own instance variables, invoking the superclass’s implementation first. 如果子类通过父类继承NSMutableCopying协议，同时定义了额外的实例变量。子类必须复写mutableCopyWithZone方法来处理自身额外的实例变量，但会先调用父类的mutableCopyWithZone方法。 相关API：- (id)copy;//执行成功返回不可变对象 - (id)mutableCopy;//执行成功返回可变对象从组合的方式理解深浅拷贝指针拷贝：返回对象与被复制对象都指向同一个对象，返回对象拷贝的是被复制对象的指针。 内容拷贝：创建新的对象，并把被复制对象的内容复制。返回对象与被复制对象指向不同的对象，返回对象拷贝的是被复制对象的内容。 浅复制：被复制对象每一层都是指针拷贝。 仅当执行imutable对象执行copy方法时产生浅复制。 深复制：被复制对象第一层是内容拷贝。 执行mutableCopy总会产生深复制。 mutable对象执行拷贝总会产生深拷贝，不论copy或mutableCopy。 当对象属性中存在集合的时候，集合本身是深拷贝，但其元素执行的依然是浅拷贝。这个在某些开发场景中如果使用不当，会导致业务逻辑的不对。因为是指针拷贝，实际上是同一个对象。如果我们期待他们是不同的对象，期待他们之间的修改是互不影响的，那么久需要执行完全拷贝，简单的深拷贝是不满足的。所以，要实现集合属性的内容拷贝，需要对集合属性执行 initWithArray:copyItems: / initWithDictionary:copyItems:。copyItems入参YES。 排列组合： object type invoke funtion copy type imutable object copy shallow copy imutable object mutableCopy deep copy mutable object copy deep copy mutable object mutableCopy deep copy 我的理解是当执行拷贝使对象状态发生变化，即可变变为不可变或者不可变变为可变，必然是深拷贝。另外可变对象执行拷贝必然也是深拷贝。 总结可变对象拷贝深拷贝，状态变化深拷贝。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://zengbailiang.cn/categories/iOS/"}],"tags":[{"name":"浅拷贝、深拷贝","slug":"浅拷贝、深拷贝","permalink":"https://zengbailiang.cn/tags/浅拷贝、深拷贝/"}]},{"title":"算法-不同路径","slug":"2018-07-22-leetcode","date":"2018-07-21T16:00:00.000Z","updated":"2018-07-24T16:06:05.480Z","comments":true,"path":"2018-07-22-leetcode.html","link":"","permalink":"https://zengbailiang.cn/2018-07-22-leetcode.html","excerpt":"","text":"题目：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 输入: m = 7, n = 3输出: 28 题目分析：每个格子的路径数等于其上方的格子的路径数与其左方的路径数之和。dp公式为：dp(i,j) = dp(i - 1,j) + dp (j,i - 1)，其中( 0&lt;= i &lt;= m - 1, 0 &lt;= j &lt;= n -1 )。所以右下角的格子的的路径数为dp（i-1，j-1）。特殊情况处理，如果m == 1 或者 n == 1,那么路径只有一条。 思路1：dp 0 指向格子的第一行。有时候又在纠结到底是用0作为第一行，还是用1作为第一行。下面的递归就是使用1代表第一行。 代码int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) &#123; return 1; &#125; int dp[100][100]; //水平第一行每个格子只有一种组合 for (int i = 0 ; i &lt; m; ++ i) &#123; dp[i][0] = 1; &#125; //垂直第一行每个格子只有一种组合 for (int i = 0 ; i &lt; n; ++ i) &#123; dp[0][i] = 1; &#125; //数组的第0行对应格子的第一行。第0行dp值已经初始化了，这里从第二行计算起 for (int i = 1; i &lt; m; ++ i) &#123; for (int j = 1; j &lt; n; ++ j) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j -1]; &#125; &#125; //(m -1 , n - 1) 对应目标格子，返回其dp值。 return dp[m - 1][n - 1]; &#125; 思路2：使用递归 核心思路跟dp一样。只是使用递归的方式实现。 数组的下标1代表的第1行。这个可能会直观一点。但有时候更容易出现问题。后面还是统一使用0作为第一行处理。 代码 int subUniquePaths(int m,int n,int **dp)&#123; if (dp[m][n] != 0) &#123; printf(\"(%d,%d) dp:%d\\n\",m,n,dp[m][n]); return dp[m][n]; &#125; else &#123; printf(\"(%d,%d)\\n\",m,n); if (m - 1 == 0 || n - 1 == 0) &#123; return 1; &#125; else &#123; dp[m][n] = subUniquePaths(m - 1, n,dp) + subUniquePaths(m, n -1,dp); return dp[m][n]; &#125; &#125;&#125;int uniquePaths(int m, int n) &#123; int **dp; int row = 101,column = 101; dp = (int **)malloc(sizeof(int *) * row); // 分配所有行的首地址 for (int i = 0; i &lt; row; i ++) &#123; // 按行分配每一列 dp[i] = (int *)malloc(sizeof(int) * column); memset(dp[i], 0, sizeof(sizeof(int) * column)); &#125; return subUniquePaths(m, n, dp);&#125; 小结： 为了直观，在递归的时候使用下标1的行作为第一行，但这也导致了程序处理思维的混乱和不统一，虽然很难说明那种好。但程序中的数组既然是从0开始，那么还是统一采用0作为第一行处理。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://zengbailiang.cn/tags/动态规划/"}]},{"title":"算法-使用最小花费爬楼梯","slug":"2018-07-07-15-0leetcode","date":"2018-07-14T16:00:00.000Z","updated":"2018-07-22T08:53:54.337Z","comments":true,"path":"2018-07-07-15-0leetcode.html","link":"","permalink":"https://zengbailiang.cn/2018-07-07-15-0leetcode.html","excerpt":"","text":"题目：数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 costi。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1:输入: cost = [10, 15, 20]输出: 15解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。示例 2:输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 题目分析：可以把每个阶梯当做一个节点，能走出消耗值小值得路径可能有几条。同时可能会存在一些节点你走错了无法走出最小值的路径。如何选择这些节点是个问题。这看起来有点像广度优先搜索，每一次选择都需要根据前面的两个节点和当前节点的消耗值来确定那个组合的消耗值最小从而确定当前节点的选择。但这其实是一个动态规划问题，后面节点的选择不受前面节点的选择的影响，但会根据前面节点选择的值来确定当前节点的选择（前后步骤的联系），为了保证消耗值最小，前提是每一次选择节点都要满足消耗值最小，那么当路径走完的时候总的消耗值就是最小。算法实现的时候记录每个节点的最小消耗总值，用于后面的节点选择。实际上只需要记录最近的两个节点的最小消耗总值即可。 思路1：dp dp特点： 后面的步骤不受前面的步骤的影响，但会用到前面步骤的计算值。需保证前面的步骤选择正确性。 利用容器记录每个步骤的可用值，空间换时间。 代码 int min(int a, int b )&#123; return a &lt; b ? a:b;&#125;int minCostClimbingStairs(int* cost, int costSize) &#123; int *dp = (int *)malloc(sizeof(int) * (costSize + 1)); memset(dp, 0, sizeof(int) * (costSize + 1)); if (costSize == 2) &#123; return min(cost[0],cost[1]); &#125; for (int i = 2; i &lt;= costSize; i ++) &#123; //记录每个dp值 dp[i] = min(dp[i - 1] + cost[i - 1],dp[i-2] + cost[ i - 2]); &#125; return dp[costSize];&#125;int minCostClimbingStairs(int* cost, int costSize) &#123; int dpStep1 = 0,dpStep2 = 0,dpTemp = 0; if (costSize == 2) &#123; return min(cost[0],cost[1]); &#125; for (int i = 2; i &lt;= costSize; i ++) &#123; dpTemp = dpStep1; //记录最近的第一个节点的dp值 dpStep1 = min(dpStep1 + cost[i - 1],dpStep2 + cost[i - 2]); //记录最近的第二个节点dp值 dpStep2 = dpTemp; &#125; return dpStep1;&#125; 复杂度分析 时间复杂度 O(n), n = strlen(s)，一层循环; 空间复杂度 优化后为O(1)，固定数量的变量。 思路2：递归实现 关键步骤跟dp是一样的，只是逆向的方式实现。变成了最后一次爬梯是选择走一步还是走两步的问题，然后分别计算走一步的最小消耗值和走两步的最小消耗值。执行一个递归过程。计算过程中，发现走一步的很多dp值可以被走二步所用。通过存入一个数组指针存储已有步骤的dp值。这次很多dp值都会被二次利用，而不像dp只利用前面的两个dp值。 代码 int min(int a, int b )&#123; return a &lt; b ? a:b;&#125;int subMinCostClimbingStairs(int* cost, int end,int *dp)&#123; if (dp[end] != 0) &#123; return dp[end]; &#125; if(end == 2) &#123; dp[end] = min(cost[0],cost[1]); &#125; else if (end == 1|| end == 0) &#123; dp[end] = 0; &#125; else &#123; //1步的值。 int a = subMinCostClimbingStairs(cost, end - 1,dp) + cost[end - 1]; //2步的值。这个步骤的执行已经是a有值得时候了，所以可以复用a计算过程中产生的dp值。 int b = subMinCostClimbingStairs(cost, end - 2,dp) + cost[end - 2]; //存储dp值 dp[end] = min(a,b); &#125; return dp[end];&#125;int minCostClimbingStairs(int* cost, int costSize) &#123; int *dp = (int *)malloc(sizeof(int) * (costSize + 1)); memset(dp, 0, sizeof(int) * (costSize + 1)); return subMinCostClimbingStairs(cost, costSize,dp);&#125; 复杂度分析 时间复杂度 大于O(n) 且小于 O(n^2)，定向比较下。 空间复杂度 O(1)，少量的固定的额外空间。 小结： 递归的执行过程还是比较抽象，调试也不方便。递归跟逆向思维联系比较大，从问题的最后一个步骤抽象，反过来递归直到达到退出条件再逐步出栈得出计算结果。而且在调试的过程中会出现内存爆炸的情况，这也是递归需要考虑的问题。可以通过复用计算的中间值减少计算量和提高效率。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://zengbailiang.cn/tags/动态规划/"}]},{"title":"算法-反转整数","slug":"2018-07-07-14-10leetcode","date":"2018-07-13T16:00:00.000Z","updated":"2018-07-22T08:53:53.704Z","comments":true,"path":"2018-07-07-14-10leetcode.html","link":"","permalink":"https://zengbailiang.cn/2018-07-07-14-10leetcode.html","excerpt":"","text":"题目：给定一个 32 位有符号整数，将整数中的数字进行反转。 示例 1:输入: 123输出: 321 示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21 注意:假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 题目分析：1.从低位开始获取位数，每次存储的时候把原有值*10，低位插入到最后面。直到处理完毕。如果中途超出了数值范围则直接返回0。2. 判断是否超出了数值范围 1. 已知 INT_MAX = 2147483647 , INT_MIN = -2147483648. 假设当前已有计算值为rev,尚未处理完毕且当前获取的准备插入的数值为pop。 1. 如果输入值为正数，那么当 rev &gt; INT_MAX/10 或者rev/10 == INT_MAX &amp;&amp; pop&gt;7，代表超出范围。 2. 如果输入值为负数，那么当 rev &lt; INT_MIN/10 或者rev/10 == INT_MIN &amp;&amp; pop &lt; -8,代表超出范围。 代码int reverse(int x) &#123; // int max = INT_MAX;//2147483647 // int min = INT_MIN;//-2147483648 int rev = 0; while (x != 0) &#123; //获得最后一位 int pop = x % 10; //把倒数第二位后移到第一位 x /= 10; //判断溢出情况 结合max 和min 的值 就知道 为什么是 7 和 -8 了 if (rev &gt; INT_MAX / 10 || (rev/10 == INT_MAX &amp;&amp; pop &gt; 7)) &#123; return 0; &#125; if (rev &lt; INT_MIN / 10|| (rev/10 == INT_MIN &amp;&amp; pop &lt; -8)) &#123; return 0; &#125; //*10整体后移一位 ，pop插入到第一位 rev = rev * 10 + pop; &#125; return rev; &#125; 复杂度分析 时间复杂度 O(n), n为字符的长度 空间复杂度 O(1)，固定数量的变量。 小结：主要是数值范围判断的处理。也可以用一个long型来存储，最后的时候再跟INT_MAX判断。开始的想法是从高位开始获取，然后新数值先填充低位再填充高位。这个处理起来没有从低位开始获取的方便，因为新数值前移只需要乘以10即可，非常方便。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/tags/算法/"}]},{"title":"算法-最大子序和","slug":"2018-07-07-07-10leetcode","date":"2018-07-09T16:00:00.000Z","updated":"2018-07-22T08:53:53.069Z","comments":true,"path":"2018-07-07-07-10leetcode.html","link":"","permalink":"https://zengbailiang.cn/2018-07-07-07-10leetcode.html","excerpt":"","text":"题目：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 题目分析：思路1：贪心算法 连续子数组之和如果为负数，那么把它作为和的一部分反而减少了和的大小。所以当子数组之和为负数的时候进行舍弃，取下一个元素作为起点重新累加。但这样累加会存在一个问题，虽然知道起点，也知道终点，但过程中累加到哪一个元素的和为最大却不知道。只能通过每累加一个元素就计算一次和，这样就不会错过每个可能的最大值。 代码 int greedMaxSubArray(int* nums, int numsSize)&#123; int maxSum = INT_MIN; int thisMaxSum = INT_MIN; for (int i = 0 ; i &lt; numsSize; i ++) &#123; //如何和小于0代码表示这整块都可以舍弃，因为不起到增大和的作用 if (thisMaxSum &lt;= 0) &#123; thisMaxSum = nums[i]; &#125; else &#123; thisMaxSum += nums[i]; &#125; if(maxSum &lt; thisMaxSum) &#123; maxSum = thisMaxSum; &#125; &#125; return maxSum;&#125; 复杂度分析 时间复杂度 O(n), n = strlen(s)，一层循环; 空间复杂度 O(1)，固定数量的变量。 思路2：动态规划DP 运行到当前步骤获取到的可用和值为当前元素的值以及累加上当前元素所得的和中的最大值。获取的DP公式： maxSub(i) = getMaxSub(maxSub(i - 1) + nums[i],nums[i]); 代码 // maxSub(i) = getMaxSub(maxSub(i - 1) + nums[i],nums[i]);int dpMaxSubArray(int* nums, int numsSize)&#123; int max = nums[0]; int sum = nums[0]; for (int i = 0 ; i &lt; numsSize; i ++) &#123; int currentValue = nums[i]; if (sum + currentValue &lt; currentValue) &#123; sum += currentValue; &#125; else &#123; sum = currentValue; &#125; if (sum&gt;max) &#123; max = sum; &#125; &#125; return max;&#125; 复杂度分析 时间复杂度 O(n), n = strlen(s)，一层循环; 空间复杂度 O(1)，少量的固定的额外空间。 思路3：分治递归 把数组分成左右两部分，那么对于这个范围，最大和可能出现在左边或者右边或者跨越两个左右部分。本轮中先给出分割点，从分割点向两边扩散遍历，获取跨越中心点最大的和值（只需要把左右部分的遍历最大值相加，有可能左边最大值为正，右边最大值为负，不用管只管相加，左边最大值会在分割后的左边某次递归中参与比较。递归有时候就是在一轮中考虑的情况变少了，有些情况是否在递归的过程中已被处理，或者说递归入参的改变就能计算出这些情况。）。方法的返回值为递归左部分、递归右部分、本轮跨越中心的最大和值三者的最大值。比较难理解的还是每一轮只计算跨越分割点的最大和值，随着范围的缩小递归起来就涵盖了所有的情况。 代码 int max(int a ,int b)&#123; return a&gt;b? a : b;&#125;int maxSubArray(int* nums, int numsSize) &#123; int maxSubLeft = 0; int maxSUbRight = 0; int maxLeft = INT_MIN; int maxRight = INT_MIN; //推出递归条件 if (left == right) &#123; return nums[left]; &#125; int center = (left + right) / 2 ; int maxTempLeft = 0; //计算当前的左相加最大值,右到左 for (int i = center; i &gt;= left; i --) &#123; maxTempLeft += nums[i]; if (maxLeft &lt; maxTempLeft) &#123; maxLeft = maxTempLeft; &#125; &#125; if (maxLeft == INT_MIN) &#123; maxLeft = 0; &#125; //计算当maxTempRight 当前前右相加最大值，左到右 //每一个子数组都独自全部累加左右部分，那么久含括了所有的情况。 int maxTempRight = 0; for (int i = center + 1; i &lt;= right; i ++) &#123; maxTempRight += nums[i]; if (maxRight &lt; maxTempRight) &#123; maxRight = maxTempRight; &#125; &#125; if (maxRight == INT_MIN) &#123; maxRight = 0; &#125; maxSubLeft = maxsubArrayRe(nums, left, center); maxSUbRight = maxsubArrayRe(nums, center + 1,right); return max(max(maxSUbRight,maxSubLeft),maxLeft + maxRight);&#125; 复杂度分析 时间复杂度O(NlogN)。 小结： 贪心算法中，一边累加一边记录最大值，通过这样的方式而不会错过可能的最大值。我开始想的是如何确定起点和终点，想通过舍弃头尾部分获取中间部分的方式来解题，分析出舍弃的条件是累加值少于0，就是对中间部分为负增益。这个思路也许可行，但我没搞出来。而DP，就是要分析规律，关注于步骤与步骤之间的共性，得出dp方程，通过代码实现思路。分治方法中，注意的是中心向两边扩散才能正确的计算跨越左右两边之和。递归中必不可少的是，退出递归条件，上下层递归之间的联系交互是如何的（每一轮都计算出当前范围中跨越左右两边的最大值，而下一轮递归中他会计算出，左边的最大值和右边的最大值），是否涵盖是全部情况。如果采用二分法，因为是分割了范围，那么本轮处理中需要保证那些跨越切割范围的情况。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://zengbailiang.cn/tags/动态规划/"}]},{"title":"算法-Z字形变换","slug":"2018-07-07-07-01leetcode","date":"2018-07-06T16:00:00.000Z","updated":"2018-07-19T14:03:07.625Z","comments":true,"path":"2018-07-07-07-01leetcode.html","link":"","permalink":"https://zengbailiang.cn/2018-07-07-07-01leetcode.html","excerpt":"","text":"题目：将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数： P A H NA P L S I I GY I R 之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR” 实现一个将字符串进行指定行数变换的函数: string convert(string s, int numRows);示例 1: 输入: s = “PAYPALISHIRING”, numRows = 3输出: “PAHNAPLSIIGYIR”示例 2: 输入: s = “PAYPALISHIRING”, numRows = 4输出: “PINALSIGYAHRPI”解释: P I NA L S I GY A H RP I 思路1：按行排序 题目要求有两个，一个是字符是按Z字形排序，一个由上而下按行输出。 分析下Z字形的排序规律。z字形先是由上而下，到了底部再向上，每到底部或者顶部就会反弹，程序中使用bool变量lineUp记录方向。遍历字符的同时，使用一个二维数组int a[row][strlen(s)]来存储行与元素原始下标的关系。遍历完毕后，按行拼接字符串并输出。 元素的下标与输出后所在的行有这样的对应关系。 #row #数字对应元素下标。 0 0P 6I 12N 1 1A 5L 7S 11I 13G 2 2Y 4A 8H 10R 3 3P 9I 代码 char* convert(char* s, int numRows) &#123;if (numRows == 1) &#123; return s;&#125;bool lineUp = true;int len = strlen(s);//记录字符的二维数组。其实可以使用int的二维数组，因为字符能自动转成asscii对应的int数字。char **pArr = (char**)malloc(sizeof(char*) * numRows);//这个数组是为了记录当前行最大下标，用于后面遍历。其实可以不用，在记录字符串的时候末尾添加'\\0'用于判断就行。int *indexArr = (int*)malloc(sizeof(int) * numRows);memset(indexArr, -1, sizeof(int) * numRows);for (int i = 0; i &lt; numRows; i++ ) &#123;//开始的时候设置长度为len 。在leetcode上执行报超出内存限制。分析后改为len /2 + 1,因为两行的时候最多为len / 2 + 1；超过三行字符被分散到其他行行，也不会超过len /2 + 1。修改后执行通过。 char *a = (char*)malloc(sizeof(char*) * (len / 2 + 1)); memset(a, '#', sizeof(char*) * (len / 2 + 1)); pArr[i] = a;&#125;int j = 0;for (int i = 0; i &lt; len; i ++) &#123; int currentIndex = indexArr[j] + 1; indexArr[j] = currentIndex; pArr[j][currentIndex] = s[i]; if (lineUp) &#123; if (j == numRows - 1) &#123; j --; lineUp = false; &#125; else &#123; j ++; &#125; &#125; else &#123; if (j == 0) &#123; j ++; lineUp = true; &#125; else &#123; j --; &#125; &#125;&#125;char *p = (char*)malloc(sizeof(char*) * len);memset(p, 0, sizeof(char*) * len);int jj = 0;for (int ii = 0; ii &lt; numRows ; ii ++)&#123; char *temp = pArr[ii]; for (int k = 0; k &lt;= indexArr[ii]; k++) &#123; p[jj++] = temp[k]; &#125;&#125;free(pArr);free(indexArr);return p;&#125; 复杂度分析 时间复杂度 O(n), n = strlen(s); 空间复杂度 O(n)。 思路2：按行访问 这个是对字符输入的方式分析后得出的数学规律。首尾两行成等比关系，中间的行除了等比的位置填充元素外，另外还需要在等比距离倒退一定长度offset的位置填充，offset = currentRow。 代码 char* convert(char* s, int numRows) &#123;int len = strlen(s);//特殊情况特殊处理if (len == 0 || numRows == 0 || numRows == 1 || numRows == len)&#123; return s;&#125;char *p = (char*)malloc(sizeof(char) * len);//等比间隔int cycleLen = 2 * numRows - 2;int pIndex = 0;for (int i = 0 ; i &lt; numRows; i ++) &#123; for (int j = 0; j + i &lt; len ; j += cycleLen) &#123; //获取等比位置的字符 p[pIndex ++] = s[i + j]; //获取中间行非等比位置的字符 if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp; j + cycleLen - i &lt; len) &#123; p[pIndex ++] = s[ j + cycleLen - i]; &#125; &#125;&#125;return p;&#125; 复杂度分析 时间复杂度 O(n), n = strlen(s); 空间复杂度 O(n)。如果返回字符不视为额外空间，那么空间复杂度为O(1)。 小结： 这道题开始也是用分析规律的方法去做，但举的例子少了点，写出来运行才发现规律是错的。后面也就没继续找数学规律。 为了避免下次犯错，找规律需要论证不少于3个例子。同时规律需要分情况讨论，例如该题的首尾两行作为一类，中间行作为一类。另外别想着用简单的规律就能处理全部问题，一般这类问题都是二级或者多级的，例如多种情况对应不同的规律，或者同一个规律要处理的多个问题。还有如果一类问题按一定方式呈现，一般会存在规律。 注意的地方：二维数组初始化问题；meset的使用；字符串、ASCII码、int之间的关系等。 部分代码可以写的更简洁，但为了更好的描述过程，暂时还是保持这个风格，有利于学习和理解。","categories":[{"name":"blog","slug":"blog","permalink":"https://zengbailiang.cn/categories/blog/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/tags/算法/"}]},{"title":"算法-两最长回文子串","slug":"2018-06-07-01-leetcode","date":"2018-06-30T16:00:00.000Z","updated":"2018-07-22T08:53:50.551Z","comments":true,"path":"2018-06-07-01-leetcode.html","link":"","permalink":"https://zengbailiang.cn/2018-06-07-01-leetcode.html","excerpt":"","text":"题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。 示例 1：输入: \"babad\"输出: \"bab\"注意: \"aba\"也是一个有效答案。示例 2：输入: \"cbbd\"输出: \"bb\" 思路 暴力法。2层循环嵌套，遍历所有子串。在判断子串是否为回文并对比保存最大的起止下标。通过前后同时截取字符串对比的方式来判断子串是否为回文。如果相等，就向两边靠拢，直对比的下标相等并且值也相等位置。如果不相等，子串非回文。 中心扩展算法。回文字符串有一个特点，就是左右对称。如果是奇数长度的回文字符串，中间的字符作为对称点，如aba中的a。如果是偶数长度的回文字符串，会以中间两个字符作为对称点,如abba中的bb。那么比较的时候，找到中心点，两边扩展对比就可以了。直到打破对称，通过暂存的历史最长回文子串的起止坐标比对当前长度，如果当前子串的长度较大，更新起止坐标。由于存在奇偶两种长度，对应的中心点不一样，但两种模式都可能产生回问子串，所有匹配的时候两种模式都要进行匹配，并取同一个中心点的两种模式中长度更长的更新起止坐标，这个是编码时需要处理的细节问题。 编码细节问题1.为了获取最后的子串，需要通过暂存起止坐标startIndex、endIndex。2.默认奇数匹配方式，通过判断当前元素与其后面的元素是否相等来决定是否满足偶数匹配。 char* longestPalindrome(char* s) &#123; int startIndex = 0 ; int endIndex = 0; int len = strlen(s); for (int i = 0; i &lt; len; i ++) &#123; int frontIndex = i ; int nextIndex = i; bool evenSerech = true; //满足偶数匹配方式 if (s[i] == s[nextIndex + 1]) &#123; evenSerech = true; &#125; while (frontIndex &gt; -1 &amp;&amp; nextIndex &lt; len &amp;&amp; s[frontIndex] == s[nextIndex]) &#123; frontIndex --; nextIndex ++; &#125; int current = --nextIndex + 1 - ++frontIndex ; if (current &gt; (endIndex + 1 - startIndex)) &#123; startIndex = frontIndex; endIndex = nextIndex; &#125; if (evenSerech) &#123; frontIndex = i ; nextIndex = i + 1; while (frontIndex &gt; -1 &amp;&amp; nextIndex &lt; len &amp;&amp; s[frontIndex] == s[nextIndex]) &#123; frontIndex --; nextIndex ++; &#125; int current = --nextIndex + 1 - ++frontIndex ; if (current &gt; (endIndex + 1 - startIndex)) &#123; startIndex = frontIndex; endIndex = nextIndex; &#125; &#125; &#125; char *p = (char*)malloc(sizeof(char*) * (endIndex + 1 - startIndex)); int j = 0; for (int i = startIndex; i &lt;= endIndex; i ++) &#123; p[j ++] = s[i]; &#125; return p;&#125; 小结：需要认真的分析回文的特点，回文串分偶数长度与奇数长度两种情况（认真审题并分析题目所求,不能忽略了一些必要的点，这一点很重要，卡时间比较多的是想通过修改起止指针的位置来适配偶数的模式，发现怎么都不能同时适配奇偶两种情况，如果是两类情况不能简单的统一处理的话，要变回单独处理）。另外这题能反转字符串取相同子串的方法（有坑）、动态规划和Manacher 算法来处理，后面再学习学习。 待完善L(‘ω’)┘三└(‘ω’)｣….","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/tags/算法/"}]},{"title":"算法-两个排序数组的中位数","slug":"2018-06-30-01-leetcode","date":"2018-06-29T16:00:00.000Z","updated":"2018-07-22T08:52:55.951Z","comments":true,"path":"2018-06-30-01-leetcode.html","link":"","permalink":"https://zengbailiang.cn/2018-06-30-01-leetcode.html","excerpt":"","text":"题目两个排序数组的中位数 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。 请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。 示例 1:nums1 = [1, 3]nums2 = [2]中位数是 2.0示例 2:nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5 思路： 中位数下标 （假设数组为arr，长度为len，下标范围[0 ,len - 1]） 如果len % 2 = 1 （为奇数），那么中位数的值为arr[mindIndex = len /2] 。 如果len % 2 - 0 (为偶数)，那么中位数的值为(arr[len/2]+arr[len/2 - 1])/2.0的值的和的平均值。 思路一：最简单的思路把两个有序数组合并成一个有序的数组，再通过规则1.获取中位数的值。优化：结合题目要求，只需要获取中位数的值，并不需要真的要把两个数组排序成一个有序数组。那么通过两数组间隔读取，下标后移，直到累加到位置为为len/2即可获取到结果。这里如何更快地把找到len/2的位置是效率的关键。 思路二：假定数组A、B、长度分别为Alen、Blen。那么排序后的新数组为C、Clen。Clen = (Alen + Blen + 1）/ 2。因为A和B都是有序的，如果C是由A和B的一部分元素组成的。那么可以想象，C必然是A左边一定长度为ALefPairLen和B的左边一定长度为BLeftPairLen的两部分组成.ALefPairLen和BLeftPairLen是联动关系，ALefPairLen + BLeftPairLen = (Alen + Blen + 1）/ 2,一增一减，一减一增，总长度是固定的。然后为了获得中位数，只需要获取其中一个数组的用于合并那部分的末尾Index，或者index + 1 （index + 1 = LefPairLen） ；这就变成了一个查找指定下标的问题了。 继续思路二（切换到程序中的变量，便于理解） 定义：假定，A数组的用于合并的长度为i，，那么最后一个元素的下标为i-1，i为用于合并的最后一个元素的下一个元素的下标。B的数组的长度j = (Alen + Blen + 1）/ 2 - i,那么B数组的最后一个元素的下标为j-1，j为用于合并的最后一个元素的下一个元素的下标。 结束条件：要获取合法的i值，需要满足 A[i -1 ] &lt;= B[j] &amp;&amp; A[j] &gt;= B[j -1]；如果leftPairA的最后一个元素少于leftPairB在原数组中最后一个元素的下一个元素，那么leftPairA是符合要求的。反过来B数组也一样。要达到在leftPairA和leftPairB右边的元素都比这两部分大，不然就需要继续调整。 特殊情况：代码注释中记录。 数的获取：因为取长度的时候为halfLen = (Alen + Blen + 1）/ 2。如果总长度为奇数，最后一位就是中位fmax(a[i-1],B[j-1])。如果总长度为偶数，需要取处于中间的两个数，最后一位(fmax(a[i-1],B[j-1])为左边的一个，右边一个为halfLen之外的fmin(A[i],B[j]))。 double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) &#123; int* A = nums1; int* B = nums2; int m = nums1Size; int n = nums2Size; if (m &gt; n ) &#123; int* tmp = A; A = B; B = tmp; int k = m; m = n; n = k; &#125; int iMin = 0; int iMax = m; //halfLen 偶数等于实际的一半，奇数等于向上取整 int halfLen = (m + n + 1) / 2 ; while (iMin &lt;= iMax) &#123; //偶数index[i-1 , i ],奇数[i] int i = (iMin + iMax) /2; //长度之外的第一个元素 int j = halfLen - i; if (i &lt; iMax &amp;&amp; A[i] &lt; B[j - 1] ) &#123; //太小了，下限提高 iMin = iMin + 1; &#125; else if ( i &gt; iMin &amp;&amp; A[i- 1] &gt; B[j]) &#123; //太大了,上限降低 iMax = iMax - 1; &#125; else &#123; //满足需求 (A[i - 1] &lt; B[j] &amp;&amp; A[i] &gt; B[j - 1]) || i == 0 || j == 0 || i == m || j == n int leftMax = 0; //m &gt; n if (i == 0) &#123; //在A被选中的长度为0 leftMax = B[j - 1]; &#125;else if (j == 0) &#123; //在B中被选中的长度为0 leftMax = A[i - 1]; &#125; else &#123; //i = m;代表A数组都被选中 //j = n;代表整个B数组都被选中 //包含 j == n || i == m 的情况 leftMax = fmax(A[i - 1], B[j - 1]); &#125; if ((m + n) % 2 == 1) &#123; return leftMax; &#125; int rightMin = 0; if (i == m) &#123; //A全部被选中。那么总长度为偶数时，中位数为中间两数的平均值，选中的最后一个数为leftMax，rightMin为hanlflen之外的第一个数B[j]； rightMin = B[j]; &#125;else if (j == n) &#123; //B全部被选中。那么总长度为偶数时，中位数为中间两数的平均值，选中的最后一个数为leftMax，rightMin为hanlflen之外的第一个数A[j]； rightMin = A[i]; &#125; else &#123; //包含j == 0 || i == 0 的情况 rightMin = fmin(A[i], B[j]); &#125; return (leftMax + rightMin) / 2.0 ; &#125; &#125; return 0;&#125; //另外一种效率不错的解法double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) &#123; int* A = nums1; int* B = nums2; int m = nums1Size; int n = nums2Size; if (m &lt; n ) &#123; int* tmp = A; A = B; B = tmp; int k = m; m = n; n = k; &#125; int iMin = 0; int iMax = m; int halfLen = (m + n + 1) / 2 ; while (iMin &lt;= iMax) &#123; //偶数index[i-1 , i ],奇数[i] int i = (iMin + iMax) /2; //长度之外的第一个元素 int j = halfLen - i; if ( A[i- 1] &gt; B[j] &amp;&amp; i &gt; iMin ) &#123; //太大了,上限降低 iMax = iMax - 1; &#125; else if (A[i] &lt; B[j - 1] &amp;&amp; i &lt; iMax) &#123; //太小了，下限提高 iMin = iMin + 1; &#125; else &#123; //满足需求 A[i - 1] &lt; B[j] &amp;&amp; A[i] &gt; B[j - 1] int leftMax = 0; //m &gt; n if (i == 0) &#123; //在A中无法找到符合的数值 leftMax = B[j - 1]; &#125;else if (j == 0) &#123; //在B中无法找到符合的数值 leftMax = A[i - 1]; &#125; else &#123; //包含 j == n || i == m 的情况 leftMax = fmax(A[i - 1], B[j - 1]); if ((m + n) % 2 == 1) &#123; return leftMax; &#125; &#125; int rightMin = 0; if (i == m) &#123; rightMin = B[j]; &#125;else if (j == n) &#123; rightMin = A[i]; &#125; else &#123; //包含j == 0 || i == 0 的情况 rightMin = fmin(A[i], B[j]); return (leftMax + rightMin) / 2.0 ; &#125; &#125; return 0;&#125; 小结:这道理题要处理的细节比较多。切割长度halfLen = (m + n + 1) / 2，最后一位是哪一位，是刚好是中位数呢，还是中位数左移一位，还是右移一位呢。这个会影响到后面的中位数下标取值。还要搞懂每个临界条件代表的意义。总的来说如果每一句代码都是必须的，那么必然要做到对代码的含义了然于心，才能保证程序的正确性。对的思路+对的编码 = 对的答案。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/tags/算法/"}]},{"title":"算法-两数相加","slug":"2018-06-28-01-leetcode","date":"2018-06-27T16:00:00.000Z","updated":"2018-07-22T08:53:52.405Z","comments":true,"path":"2018-06-28-01-leetcode.html","link":"","permalink":"https://zengbailiang.cn/2018-06-28-01-leetcode.html","excerpt":"","text":"/* 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 */ /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123; struct ListNode* l3 = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* n1 = l1; struct ListNode* n2 = l2; struct ListNode* n3 = l3; int carry = 0; while (1) &#123; int c1 = 0; int c2 = 0; if (n1 != NULL) &#123; c1 = n1-&gt;val; n1 = n1 -&gt;next; &#125; if (n2 != NULL) &#123; c2 = n2-&gt;val; n2 = n2 -&gt;next; &#125; int sum = c1 + c2 + carry; carry = sum /10; int currentValue = sum % 10; n3-&gt;val = currentValue; //考虑进位有值得情况需要进入下一个循环 if(n1 != NULL || n2 != NULL || carry) &#123; struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode)); n3-&gt;next = newNode; n3 = n3 -&gt;next; &#125; else &#123; //最后一个节点为NULL n3 -&gt;next = NULL; break; &#125; &#125; return l3;&#125; 小结：面向过程的思路。注意的几个问题： 进位问题，低位相加得出进位值提供给高位计算。 最后一轮相加的时候可能会产生进位，这个时候需要进入下一轮循环，计算下一位的值。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/tags/算法/"}]},{"title":"算法-无重复字符的最长子串","slug":"2018-06-28-02-leetcode","date":"2018-06-27T16:00:00.000Z","updated":"2018-07-22T08:52:36.067Z","comments":true,"path":"2018-06-28-02-leetcode.html","link":"","permalink":"https://zengbailiang.cn/2018-06-28-02-leetcode.html","excerpt":"","text":"给定一个字符串，找出不含有重复字符的最长子串的长度。 示例：给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。 给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。 给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列 而不是子串。 思路： 从字符串第一个元素起，从左到右获取子串。 每前进一个字符(下标为j)，就在当前子串中查找是否存在与当前字符重复的字符，如果存在(重复字符的下标为i)，那么能确定一个包含不重复字符的子串，其长度为j - i 对比已存储的最大长度并把两者的最大值存储。 现在下一个子串的起点为当前重复的字符下标j.重复执行2、3操作，直到最后一个字符。 其实这是滑动窗口的思路。左闭右开。 int lengthOfLongestSubstring(char* s) &#123; int len = strlen(s); //长度为0 的情况的处理 if(len == 0) return 0; int max = 1; int statrIndex = 0; for (int i = 1; i &lt; len; i ++) &#123; char subStr = s[i]; for(int j = statrIndex; j &lt;i; j ++) &#123; char ssubStr = s[j]; //如果找到重复字符串 if (subStr == ssubStr ) &#123; if (max &lt; i - statrIndex) &#123; max = i - statrIndex; &#125; statrIndex = j + 1; break; &#125; &#125; //长度没添加一位，更新最大值 if (max &lt; i + 1 - statrIndex) &#123; max = i + 1 - statrIndex; &#125; &#125; return max;&#125; 其他解法： //每个字符都有唯一字符串ASCII的作为唯一标识，这是个技巧性问题。最多256个int lengthOfLongestSubstring(char* s) &#123; //算法：用book标记出现过的字符的index，用max标记最大长度，用start标记当前不重复开始的index，用num表示当前不重复的个数 //遍历数组，若book[]大于start，说明遇到相同元素，则从其相同处重新计算长度和起始位置 if(NULL == s) return NULL; int len=strlen(s); int book[255]=&#123;0&#125;; //memset(book,0xff,255*sizeof(int));//将book初始化为-1 if (0==len) return 0; int start=0,max=0;//max_start=0; int num=0; for (int i=0;i&lt;len;i++) &#123; if(book[s[i]]==0 || book[s[i]]&lt;start+1) &#123; num++; if(num&gt;max) &#123; //max_start=start; max=num; &#125; book[s[i]]=i+1; &#125; else &#123; start=book[s[i]]; num=i-start+1; book[s[i]]=i+1; &#125; &#125; return max;&#125; //写得好屌啊int lengthOfLongestSubstring(char* s) &#123; int len=0; char *end=s,*temp; char* addressTable[128]=&#123;NULL&#125;; while(*end)&#123; temp = addressTable[*end]; addressTable[*end]=end; if(temp&gt;=s)&#123; len=end-s&gt;len?end-s:len; s = temp+1; &#125;end++; &#125; len=end-s&gt;len?end-s:len; return len;&#125; 小结：这里又存在查找问题，可以考虑使用哈希Map提高效率。","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"字符串处理","slug":"字符串处理","permalink":"https://zengbailiang.cn/tags/字符串处理/"}]},{"title":"算法-两数之和","slug":"2018-06-27-01-leetcode","date":"2018-06-26T16:00:00.000Z","updated":"2018-07-22T08:53:51.789Z","comments":true,"path":"2018-06-27-01-leetcode.html","link":"","permalink":"https://zengbailiang.cn/2018-06-27-01-leetcode.html","excerpt":"","text":"题目 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]/** * Note: The returned array must be malloced, assume caller calls free(). */ //面向过程的解法；这是最直接的思路。int* twoSum(int* nums, int numsSize, int target) &#123; int *a=(int *)malloc(2*sizeof(int)); //外层index从0开始遍历 int index = 0; while (index &lt; numsSize - 1) &#123; //内层从外层当前下标index的下一个元素开始遍历即i= index + 1 int i = index + 1; while (i &lt; numsSize) &#123; //判断两个元素之和是否等于target,如果相等，保存值并返回。 if (*(nums + i) + *(nums + index) == target) &#123; *(a + 0)= index; *(a + 1) = i; return a; &#125; i ++; &#125; index ++; &#125; return a;&#125; //思路升级//c++ 哈希map 空间换时间class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int,int&gt; valueMap; for (int i = 0 ; i &lt; nums.size(); i++) &#123; int searchValue = target - nums[i]; map&lt;int,int&gt;::iterator it ; //通过value查找是否存在，该操作时间复杂度为O(1); it = valueMap.find(searchValue); if (it != valueMap.end()) &#123; vector&lt;int&gt; collect; collect.push_back(valueMap[searchValue]); collect.push_back(i); return collect; &#125; valueMap.insert(pair&lt;int, int&gt;(nums[i],i)); &#125; vector&lt;int&gt; collect; return collect; &#125;&#125;; 小结： 该题难度不大，直接使用面向过程的方法就能求解。 该问题步骤分解中，因为已知和以及其中一个加数求另外一个加数，转换到程序中就是一个查找的问题-&gt;一个已知集合查找特定值得问题. 一个已知集合查找特定值得问题，会直接导致两种思路： 遍历查找-&gt;优化遍历方法 空间换时间-&gt;哈希查找(这里会产生一种数据结构，它会把一个数值和数值的索引存储【起到存储的作用】，并能快速通过索引查找到对应的数值。另外由于不存在相同索引，所以可以【存储同一索引最后状态的值】,这个性质可以对某类问题做优化，例如最长不重复字符子串问题，通过值替换能保存相同字符的最后位置j(当前位置)，假设被替换前的值为i ，那么当前子串长度len = j - i )。 思维路线：-&gt;常规思路是否可解；-&gt;是否存查找问题-&gt;是否可以使用空间换时间(哈希查找，备忘录等)","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/tags/算法/"}]},{"title":"ffmpeg iOS平台编译","slug":"2018-06-22-01","date":"2018-06-21T16:00:00.000Z","updated":"2018-07-24T16:00:04.660Z","comments":true,"path":"2018-06-22-01.html","link":"","permalink":"https://zengbailiang.cn/2018-06-22-01.html","excerpt":"","text":"一、编译过程 1.下载源码 2.预先编译作为插件的库fdk-aac，x264等。 3.安装yasm 4.安装编译工具 5.编写脚本 6.执行脚本 二、脚本注解(包含fdk,x264库的集成，如果不包含编译，需要移除configure相关编译参数)#!/bin/sh# directories#赋值源码版本SOURCE=\"ffmpeg-4.0.1\"#FAT文件夹名称FAT=\"FFmpeg-iOS\"#文件夹名称SCRATCH=\"scratch\"# must be an absolute path#THIN路径THIN=`pwd`/\"thin\"#架构类型数组ARCHS=\"arm64 armv7\"# absolute path to x264 libraryX264=`pwd`/x264-ios# absolute path to fdk-aac libraryFDK_AAC=`pwd`/fdk-aac-ios#编译选项CONFIGURE_FLAGS=\"--enable-gpl --disable-shared --disable-stripping --disable-ffmpeg --disable-ffplay --disable-ffprobe --disable-avdevice --disable-indevs --disable-filters --disable-devices --disable-parsers --disable-postproc --disable-debug --disable-asm --disable-yasm --disable-doc --disable-bsfs --disable-muxers --disable-demuxers --disable-ffplay --disable-ffprobe --disable-indevs --disable-outdevs --enable-cross-compile --enable-filter=aresample --enable-bsf=aac_adtstoasc --enable-small --enable-dct --enable-dwt --enable-lsp --enable-mdct --enable-rdft --enable-fft --enable-static --enable-version3 --enable-nonfree --disable-encoders --enable-encoder=pcm_s16le --enable-encoder=aac --enable-encoder=libx264 --enable-encoder=mp2 --disable-decoders --enable-decoder=aac --enable-decoder=mp3 --enable-decoder=h264 --enable-decoder=pcm_s16le --disable-parsers --enable-parser=aac --enable-parser=mpeg4video --enable-parser=mpegvideo --enable-parser=mpegaudio --enable-parser=aac --disable-muxers --enable-muxer=flv --enable-muxer=mp4 --enable-muxer=wav --enable-muxer=adts --disable-demuxers --enable-demuxer=flv --enable-demuxer=mpegvideo --enable-demuxer=mpegtsraw --enable-demuxer=mpegts --enable-demuxer=mpegps --enable-demuxer=h264 --enable-demuxer=y4m --enable-demuxer=wav --enable-demuxer=aac --enable-demuxer=hls --enable-demuxer=mov --enable-demuxer=m4v --disable-protocols --enable-protocol=rtmp --enable-protocol=http --enable-protocol=file --enable-libx264 --enable-libfdk-aac --enable-libfdk_aac --enable-encoder=libfdk_aac\"COMPILE=\"y\"LIPO=\"y\"#支持的iOS最低版本DEPLOYMENT_TARGET=\"8.0\"#赋值部分结束if [ \"$*\" ]then if [ \"$*\" = \"lipo\" ] then # skip compile COMPILE= else ARCHS=\"$*\" if [ $# -eq 1 ] then # skip lipo LIPO= fi fifiif [ \"$COMPILE\" ]then#是否安装yasm，x86汇编反汇编器 支持16位、32位、64位 if [ ! `which yasm` ] then echo 'Yasm not found' #是否安装brew软件包管理工具 if [ ! `which brew` ] then echo 'Homebrew not found. Trying to install...' ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" \\ || exit 1 fi echo 'Trying to install Yasm...' brew install yasm || exit 1 fi #是否已经安装ffmpeg编译工具 if [ ! `which gas-preprocessor.pl` ] then echo 'gas-preprocessor.pl not found. Trying to install...' (curl -L https://github.com/libav/gas-preprocessor/raw/master/gas-preprocessor.pl \\ -o /usr/local/bin/gas-preprocessor.pl \\ &amp;&amp; chmod +x /usr/local/bin/gas-preprocessor.pl) \\ || exit 1 fi if [ ! -r $SOURCE ] then echo 'FFmpeg source not found. Trying to download...' #尝试下载对于的ffmpeg源码并解压，如果失败就退出 curl http://www.ffmpeg.org/releases/$SOURCE.tar.bz2 | tar xj \\ || exit 1 fi#赋值当前路径 CWD=`pwd` #遍历需要编译的架构 for ARCH in $ARCHS do echo \"building $ARCH...\" #创建/scratch/$ARCH目录 mkdir -p \"$SCRATCH/$ARCH\" #进入目录 cd \"$SCRATCH/$ARCH\" CFLAGS=\"-arch $ARCH\" if [ \"$ARCH\" = \"i386\" -o \"$ARCH\" = \"x86_64\" ] then #如果是模拟器 PLATFORM=\"iPhoneSimulator\" #编译参数 最低系统版本 CFLAGS=\"$CFLAGS -mios-simulator-version-min=$DEPLOYMENT_TARGET\" else #如果是真机 PLATFORM=\"iPhoneOS\" CFLAGS=\"$CFLAGS -mios-version-min=$DEPLOYMENT_TARGET\" if [ \"$ARCH\" = \"arm64\" ] then EXPORT=\"GASPP_FIX_XCODE5=1\" fi fi #PLATFORM变量转换为小写并赋值给XCRUN_SDK XCRUN_SDK=`echo $PLATFORM | tr '[:upper:]' '[:lower:]'` CC=\"xcrun -sdk $XCRUN_SDK clang\" CXXFLAGS=\"$CFLAGS\" LDFLAGS=\"$CFLAGS\" if [ \"$X264\" ] then #指定头文件路径 CFLAGS=\"$CFLAGS -I$X264/include\" #指定库路径 LDFLAGS=\"$LDFLAGS -L$X264/lib\" fi if [ \"$FDK_AAC\" ] then CFLAGS=\"$CFLAGS -I$FDK_AAC/include\" LDFLAGS=\"$LDFLAGS -L$FDK_AAC/lib\" fi #修改configure编译参数 TMPDIR=$&#123;TMPDIR/%\\/&#125; $CWD/$SOURCE/configure \\ --target-os=darwin \\ --arch=$ARCH \\ --cc=\"$CC\" \\ $CONFIGURE_FLAGS \\ --extra-cflags=\"$CFLAGS\" \\ --extra-ldflags=\"$LDFLAGS\" \\ --prefix=\"$THIN/$ARCH\" \\ || exit 1 #清除之前编译的可执行文件及配置文件。 echo 'build-ffmpeg:make clean' make clean echo 'build-ffmpeg:make' #make || exit 1 echo 'build-ffmpeg:make install' #make install $EXPORT || exit 1 make -j3 install $EXPORT || exit 1 cd $CWD donefiif [ \"$LIPO\" ]then echo \"building fat binaries...\" mkdir -p $FAT/lib set - $ARCHS CWD=`pwd` cd $THIN/$1/lib for LIB in *.a do cd $CWD echo lipo -create `find $THIN -name $LIB` -output $FAT/lib/$LIB 1&gt;&amp;2 #合并.a库 lipo -create `find $THIN -name $LIB` -output $FAT/lib/$LIB || exit 1 done cd $CWD cp -rf $THIN/$1/include $FATfiecho Done 三、相关命令 命令/参数 说明 which 查看可执行文件的位置 curl 下载相关资源 tar xj 解压相关资源 make 对源代码包进行编译 make install 安装编译后的代码包 configure 生成makefile文件，并可在后面指定相关编译选项 configure 编译选项，可用 ./configure –help查看 参数 说明 [默认] –target-os compiler targets OS [] –prefix=PREFIX install in PREFIX [/usr/local] –cc=CC use C compiler CC [gcc] –extra-cflags=ECFLAGS 指定头文件路径 add ECFLAGS to CFLAGS [] –extra-ldflags=ELDFLAGS 指定库文件路径 add ELDFLAGS to LDFLAGS [] 参考：configure/make/make install的作用https://www.linuxidc.com/Linux/2011-02/32211.htm CFLAGS LDFLAGS详解https://blog.csdn.net/xinyuan510214/article/details/50457433 https://blog.csdn.net/shenhuxi_yu/article/details/79788760 https://www.jianshu.com/p/e590f041c5f6","categories":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://zengbailiang.cn/categories/ffmpeg/"}],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://zengbailiang.cn/tags/ffmpeg/"}]},{"title":"数组实现循环队列","slug":"2018-05-09-011","date":"2018-05-08T16:00:00.000Z","updated":"2018-07-22T08:53:49.925Z","comments":true,"path":"2018-05-09-011.html","link":"","permalink":"https://zengbailiang.cn/2018-05-09-011.html","excerpt":"","text":"循环队列作为一种常用的数据结构，它使头尾指针能够灵活的在容器头尾跳跃，实现循环存取的结构。线性队列，在不移动元素的情况下，随着数据的不断读写，会出现假上溢的情况（当尾部指针已经到了容器底部，线性队列就无法插入了，尽管存在已出队列的可以空间，），导致已出队列的可用空间无法再被利用。另外循环队列很适合作为缓存的处理。 /* CycleQueue.m CycleQueue Created by zengbailiang on 2018/5/8. Copyright © 2018年 zengbailiang. All rights reserved. 循环队列*/#import \"CycleQueue.h\"#define CYCLE_QUEUE_MAX_SIZE 10#define CYCLE_QUEUE_ELEMENT inttypedef struct kSCycleQueue&#123; CYCLE_QUEUE_ELEMENT data[CYCLE_QUEUE_MAX_SIZE]; int fornt ,rear;&#125;*SCycleQueue;@implementation CycleQueueint queueInit(SCycleQueue *queue)&#123; if ((*queue) == NULL) &#123; (*queue) = (SCycleQueue)malloc(sizeof(struct kSCycleQueue)); /*初始化队列头和队列尾部，队列尾初始化为-1是为了添加原始的时候统一操作为后移*/ (*queue)-&gt;fornt = 0; (*queue)-&gt;rear = -1; &#125; else &#123; return -1; &#125; return 1;&#125;bool canAdd(SCycleQueue *queue)&#123; if((*queue) == NULL ||(*queue)-&gt;fornt + (*queue) -&gt;rear + 1 == CYCLE_QUEUE_MAX_SIZE ||((*queue)-&gt;rear != -1 &amp;&amp; (*queue)-&gt;rear + 1 == (*queue)-&gt;fornt)) &#123; return false; &#125; else &#123; return true; &#125;&#125;int add(SCycleQueue *queue,CYCLE_QUEUE_ELEMENT e)&#123; if (canAdd(queue)) &#123; /*如果已经是在最后一个原始，那么跳到第0个原始添加，实现循环*/ if ((*queue) -&gt; rear == CYCLE_QUEUE_MAX_SIZE - 1) &#123; (*queue) -&gt; rear = 0; &#125; else &#123; /*非最后一个元素后移即可*/ (*queue) -&gt; rear += 1; &#125; /*队尾添加元素*/ (*queue) -&gt;data[(*queue) -&gt;rear] = e; return 1; &#125; else &#123; return 0; &#125; &#125;int delete(SCycleQueue *queue,CYCLE_QUEUE_ELEMENT *e)&#123; if ((*queue) == NULL) &#123; return -1; &#125; /*如果rear不等于-1就代表存在元素*/ else if((*queue)-&gt;fornt == 0 &amp;&amp; (*queue)-&gt;rear == -1) &#123; return 0; &#125; else &#123; (*e) = (*queue)-&gt;data[(*queue)-&gt;fornt]; (*queue)-&gt;data[(*queue)-&gt;fornt] = -1; /*如果 fornt == rear，代表最后一个元素了，这个时候把标记复位用于上面的判断。*/ if ((*queue)-&gt;fornt == (*queue)-&gt;rear) &#123; (*queue)-&gt;fornt = 0; (*queue)-&gt;rear = -1; &#125; else if((*queue)-&gt;fornt == CYCLE_QUEUE_MAX_SIZE - 1) &#123; /*如果是最后一个元素出队列，那么队列头跳到容器第一个元素实现循环出队列*/ (*queue)-&gt;fornt = 0; &#125; else &#123; (*queue)-&gt;fornt += 1; &#125; return 1; &#125;&#125;+ (void)testt&#123; test(); test1(); test2();&#125;void test()&#123; SCycleQueue queue; queueInit(&amp;queue); add(&amp;queue, 0); add(&amp;queue, 1); add(&amp;queue, 2); add(&amp;queue, 3); add(&amp;queue, 4); add(&amp;queue, 5); add(&amp;queue, 6); add(&amp;queue, 7); add(&amp;queue, 8); /*加满*/ add(&amp;queue, 9); CYCLE_QUEUE_ELEMENT e; delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); /*容器底部已满，循环到头部开始添加*/ add(&amp;queue, 10); add(&amp;queue, 11); add(&amp;queue, 12); add(&amp;queue, 13); add(&amp;queue, 14);&#125;void test1()&#123; SCycleQueue queue; queueInit(&amp;queue); add(&amp;queue, 0); add(&amp;queue, 1); add(&amp;queue, 2); add(&amp;queue, 3); add(&amp;queue, 4); add(&amp;queue, 5); add(&amp;queue, 6); add(&amp;queue, 7); add(&amp;queue, 8); add(&amp;queue, 9); CYCLE_QUEUE_ELEMENT e; delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); /*全部出队列，标记复位*/ delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); add(&amp;queue, 6); add(&amp;queue, 7); add(&amp;queue, 8); add(&amp;queue, 9);&#125;void test2()&#123; SCycleQueue queue; queueInit(&amp;queue); add(&amp;queue, 0); add(&amp;queue, 1); add(&amp;queue, 2); add(&amp;queue, 3); add(&amp;queue, 4); add(&amp;queue, 5); add(&amp;queue, 6); add(&amp;queue, 7); add(&amp;queue, 8); add(&amp;queue, 9); CYCLE_QUEUE_ELEMENT e; delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); /*font = 5*/ delete(&amp;queue, &amp;e); add(&amp;queue, 15); add(&amp;queue, 16); add(&amp;queue, 11); add(&amp;queue, 12); add(&amp;queue, 13); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); /*循环到容器头出队列*/ delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e); delete(&amp;queue, &amp;e);&#125;@end","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zengbailiang.cn/categories/数据结构/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zengbailiang.cn/tags/数据结构与算法/"}]},{"title":"iOS 指纹解锁 检测指纹信息变更","slug":"2018-05-12-01","date":"2018-05-08T16:00:00.000Z","updated":"2018-07-18T14:40:10.288Z","comments":true,"path":"2018-05-12-01.html","link":"","permalink":"https://zengbailiang.cn/2018-05-12-01.html","excerpt":"","text":"通过LAContext evaluatedPolicyDomainState属性可以获取到当前data类型的指纹信息数据，当指纹增加或者删除，该data就会发生变化，通过记录这个TouchIdData与最新的data做对比就能判断指纹信息是否变更，从而定制app功能。 存在的疑问： TouchIdData可能为空吗？官方文档说明： DiscussionThis property returns a value only when the canEvaluatePolicy(:error:) method succeeds for a biometric policy or the evaluatePolicy(:localizedReason:reply:) method is called and a successful biometric authentication is performed. Otherwise, nil is returned.只有当canEvaluatePolicy方法执行并返回YES或者evaluatePolicy执行并指纹识别通过，这个属性才能有值，否则为空。 TouchIdData能否获取具体的指纹信息？ The returned data is an opaque structure. It can be used to compare with other values returned by this property to determine whether the authorized database has been updated. However, the nature of the change cannot be determined from this data.返回的数据是一个不透明的结构。它可以用来与此属性返回的其他值进行比较，以确定是否更新了授权数据库。然而，变化的性质不能从这些数据中确定。 在指纹信息没有修改的时候，不同app获取到的TouchIdData是一样的吗?实测不同的app，在指纹没有变化的情况下TouchIdData是不一样的。但这个是不能打包票的，如果苹果修改了这部分的算法，返回一个相同值也是有可能的。 添加一个新指纹，再删除刚添加的那个指纹，TouchIdData相对一轮操作之前变化了吗？实测TouchIdData没有变化，也就是说TouchIdData是面向结果的，而不是面向过程的，只要最终结果指纹集合一样，TouchIdData就一样。 代码实现 static var IDENTIFY:String? = nil static let SERVICE = \"TOUCHID_SERVICE\" static let ACCOUNT_PREFIX = \"TOUCHID_PERFIX\" open class func setCurrentTouchIdDataIdentity(identity:String ) &#123; //设定当前身份用于存储data TouchIdManager.IDENTIFY = identity &#125; //获取当前时刻的data class func currentOriTouchIdData() -&gt; Data?&#123; let context = LAContext() var error:NSError? = nil;//先使用canEvaluatePolicy方法进行评估 if context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &amp;error) &#123; return context.evaluatedPolicyDomainState &#125; print(\"errorMsg:\" + self.errorMessageForFails(errorCode:(error?.code)! )) return nil &#125;//使用keychain保存当前身份的dataopen class func setCurrentIdentityTouchIdData()-&gt; Bool &#123; if self.currentTouchIdDataIdentity() == nil &#123; return false; &#125; else &#123; if self.currentOriTouchIdData() != nil &#123; //storage by keychain SAMKeychain.setPasswordData(self.currentOriTouchIdData()!, forService:SERVICE, account: ACCOUNT_PREFIX + self.currentTouchIdDataIdentity()!) return true; &#125; else &#123; return false; &#125; &#125; &#125;//获取当前身份的上一次存储的data，用于对比 class func currentIdentityTouchIdData()-&gt;Data? &#123; guard (self.currentTouchIdDataIdentity() != nil) else &#123; return nil; &#125; return SAMKeychain.passwordData(forService: TouchIdManager.SERVICE, account: TouchIdManager.ACCOUNT_PREFIX + self.currentTouchIdDataIdentity()!) &#125;//检测以这个身份设置开始到当前时刻指纹信息是否变更open class func touchIdInfoDidChange()-&gt;Bool &#123; let data = self.currentOriTouchIdData() if data == nil &amp;&amp; self.isErrorTouchIDLockout() &#123; //lock after unlock failed many times,and the fingerprint is not changed. return false &#125; else &#123; let oldData = self.currentIdentityTouchIdData() if oldData == nil &#123; //never set return false &#125; else if oldData == data &#123; //not change return false &#125; else &#123; return true &#125; &#125; &#125;//检测当前是否为biometryLockout状态 class func isErrorTouchIDLockout()-&gt;Bool &#123; let context = LAContext() var error:NSError? context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &amp;error) guard error != nil else &#123; return false &#125; if error!.code == LAError.biometryLockout.rawValue &#123; return true &#125; else &#123; return false &#125; &#125; 指纹识别的两种LAPolicy： deviceOwnerAuthenticationWithBiometrics这个类型不能弹出密码解锁界面，但能更精准的反馈用户操作的状态：如指纹识别三次失败等。 deviceOwnerAuthentication对识别行为的结果做了简化，无法判断具体状态。但能弹出密码解锁界面。结合两者可以使指纹解锁做的更友善一点。 最终效果[正常流程]：指纹识别错误三次回调失败-&gt;再点击再识别错误两次-&gt;弹出密码解锁界面-&gt;密码错误5次-&gt;锁定1分钟-&gt;再输错-&gt;锁定五分钟。 代码实现 open class func showTouchId(title:String,fallbackTitle:String?, fallbackBlock:TouchIdFallBackBlokc?,resultBlock:TouchIdResultBlock?) &#123; let context = LAContext(); context.localizedFallbackTitle = fallbackTitle var useableError:NSError? if context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &amp;useableError) &#123; context.evaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, localizedReason: title) &#123; (success, error) in DispatchQueue.main.async &#123; if success &#123; if resultBlock != nil &#123; resultBlock!(true,success,error) &#125; &#125; else &#123; guard let error = error else &#123; return; &#125; print(\"errorMsg:\" + self.errorMessageForFails(errorCode: error._code)) if error._code == LAError.userFallback.rawValue &#123; if fallbackBlock != nil &#123; fallbackBlock!() &#125; &#125; else if error._code == LAError.biometryLockout.rawValue &#123; //try to show password interface self.tryShowTouchIdOrPwdInterface(title: title, resultBlock: resultBlock) &#125; else &#123; if resultBlock != nil &#123; resultBlock!(true,success,error) &#125; &#125; &#125; &#125; &#125; &#125; else &#123; print(\"errorMsg:\" + self.errorMessageForFails(errorCode:(useableError?.code)! )) if useableError?.code == LAError.biometryLockout.rawValue &#123; //try to show password interface self.tryShowTouchIdOrPwdInterface(title: title, resultBlock: resultBlock) &#125; else &#123; if resultBlock != nil &#123; resultBlock!(false,false,useableError) &#125; &#125; &#125; &#125; class func tryShowTouchIdOrPwdInterface(title:String,resultBlock:TouchIdResultBlock?) &#123; let context = LAContext(); context.localizedFallbackTitle = \"\" var useableError:NSError? if context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthentication, error: &amp;useableError) &#123; context.evaluatePolicy(LAPolicy.deviceOwnerAuthentication, localizedReason: title) &#123; (success, error) in DispatchQueue.main.async &#123; if resultBlock != nil &#123; resultBlock!(true,success,error) &#125; &#125; guard let error = error else &#123; return; &#125; print(\"errorMsg:\" + self.errorMessageForFails(errorCode: error._code)) &#125; &#125; else &#123; print(\"errorMsg:\" + self.errorMessageForFails(errorCode:(useableError?.code)! )) if resultBlock != nil &#123; resultBlock!(false,false,useableError) &#125; &#125; &#125; 测试demo: swift:https://github.com/zmubai/TouchIDTest-swift object-c:https://github.com/zmubai/TouchIDTest-OC","categories":[{"name":"blog","slug":"blog","permalink":"https://zengbailiang.cn/categories/blog/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://zengbailiang.cn/tags/iOS/"}]},{"title":"git的文件系统与底层原理 (1)","slug":"2018-05-05-01","date":"2018-05-04T16:00:00.000Z","updated":"2018-07-22T08:53:49.298Z","comments":true,"path":"2018-05-05-01.html","link":"","permalink":"https://zengbailiang.cn/2018-05-05-01.html","excerpt":"","text":"由于工作中使用git作为版本管理，之前对git的了解不多，特别是底层方面的原理方面的知识。为了能更好的使用git，有必要学习并梳理下相关知识。 步入正题： git的文件结构执行git init 初始化后，会在.git文件夹下会创建多个目录，每个文件夹功能划分的很清晰。 git的存储方式Git 是一套内容寻址文件系统.通过键值对的方式存储和查找。 下面操作一遍，直观的看到整个过程，以便理解。 首先，创建一个内容对象$ echo \"小明的文件\" | git hash-object -w --stdin5c98f8a9221e5336f68c7575cd238b48875137c6 命令/参数 说明 echo 将字符串输出到终端 git hash-object 创建一个blob（二进制大对象）,可指定其他类型，不一定是blob。 –stdin 从标准终端中读取输入，代替从文件读取，这里读取的是由echo命令输出到终端的字符串。 -w 把blob对象写入数据库 参考：https://git-scm.com/docs/git-hash-object 查看刚才存储的数据$ find .git/objects -type f.git/objects/5c/98f8a9221e5336f68c7575cd238b48875137c6 命令/参数 说明 find 查找目录下文件 -type f 指定查类型为普通文件 参考：http://man.linuxde.net/find 可以见到文件名称为数字和字母组成的字符串。这个是根据文件内容和头信息（Header），通过SHA-1算法计算得出的40位十六进制校验和。 校验和 5c98f8a9221e5336f68c7575cd238b48875137c6 存储路径 5c/98f8a9221e5336f68c7575cd238b48875137c6以校验和前两位作为子路径创建文件夹，以校验和后38位作为文件名生成文件。 SHA-1是一种加密哈希函数（cryptographic hash function）。SHA-1将文件中的内容通过其hash算法生成一个160bit的报文摘要，即40个十六进制数字（每个十六进制数字占4位）。它几乎可以保证，如果两个文件的SHA-1值是相同的，那么它们确是完全相同的内容（类似于生活中的指纹识别）；SHA-1主要有两种用途，一个是加密，一个是数据完整性校验。Linux kernel开创者和Git的开发者——Linus说，Git使用了SHA-1并非是为了安全性，而是为了数据的完整性。理论上SHA-1会在2^51攻击下实现哈希碰撞，所以也不是完全的安全。 通过校验和作为键值 解读文件$ git cat-file -p 5c98f8a9221e5336f68c7575cd238b48875137c6小明的文件 命令/参数 说明 git cat-file 读取对象信息 -p 根据对象的类型打印其信息 参考：https://git-scm.com/docs/git-cat-file 以上，说明了git的数据存储的基本方式。主要是使用SHA-1算法根据其内容和头信息生成唯一的40位校验和，并使用校验和作为key做文件存取。 模拟bolb对象存储流程 以上，说明了git的数据存储的基本方式。主要步骤： 使用SHA-1算法根据其原始内容和头信息（头信息格式”blob #{content.length}\\0”）生成唯一的40位校验和。 以校验和前两位创建文件夹、校验和后38位作为文件名。 对拼接后的内容压缩后存储。 下面是创建文件，修改文件，恢复文件的相关过程。 重新创建一个仓库并创建一个文件$ echo '小明该吃午饭了' &gt; test.txt$ git hash-object -w test.txtefbd70f46da0d1852de88c58aebc86616beecdaf 修改文件再保存$ echo \"小明打算去吃个泡面\" &gt; test.txt$ git hash-object -w test.txt26aab56c7d1f9bd962b28f78ce61f021b221d317 查看已保存的内容$ find .git/objects -type f.git/objects/26/aab56c7d1f9bd962b28f78ce61f021b221d317.git/objects/ef/bd70f46da0d1852de88c58aebc86616beecdaf 恢复到第一个版本$ git cat-file -p efbd70f46da0d1852de88c58aebc86616beecdaf &gt; .git/test.txt$ cat .git/test.txt小明该吃午饭了 git会记录每个版本的修改，根据校验和可恢复到相应的版本。 小结：这个过程中包括文件创建、文件修改、文件恢复，跟我们平时工作中使用的高级命令功能很相似。git会把整个过程转化为底层操作，同时对用户透明。 相关引用参考： http://smilejay.com/2012/08/git-commit-sha-1/ https://git-scm.com/book/zh/v1/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1","categories":[{"name":"git","slug":"git","permalink":"https://zengbailiang.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://zengbailiang.cn/tags/git/"}]},{"title":"git 常用操作汇总","slug":"2018-04-23-0","date":"2018-04-22T16:00:00.000Z","updated":"2018-07-22T08:53:48.673Z","comments":true,"path":"2018-04-23-0.html","link":"","permalink":"https://zengbailiang.cn/2018-04-23-0.html","excerpt":"","text":"说明(默认在master分支、远程分支origin， 省略分支名称) 配置本地信息git cogfig --global user.name userName git config --global user.email userEmail 克隆远程仓库git clone remotePath 如：git clone https://github.com/yourname/test.git 本地推送到远程仓库git remote add origin remotePath [绑定远程仓库] git push -u origin master [推送到远程master分支] 本地提交git status [显示工作区变更] git add finePath [把单个文件添加到暂存区] git commit -m &quot;log&quot; [提交到本地分支] git commit -am &quot;log&quot; [提交到本地分支，包含add操作] 显示文件修改git diff finePath [工作区文件与暂存区文件对比] git diff finePath --cached [暂存区文件与当前版本文件对比] 参考：https://www.jianshu.com/p/80542dc3164e本地分支处理git branch -a [显示本地所有分支] git checkout -b newBranch [开发新功能的时候，开启新分支] git checkout branchWhichHas [切换到已存在分支] 合并分支操作：git checkout -b B [建立分支B] ......开发新功能 并提交 git checkout master [切换到master分支] git merge B [在master分支中把B分支更新合并过来] 本地变基git rebase B [把B分支中的修改以变基的方式合并到master分支中，以当前分支为基底，把B分支的修改逐一提交到当前分支] 注意点:变基能把提交历史记录变得清晰，便于管理和维护。但要遵守原则：一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行变基操作。因为变基修改推送到远程，别人同步后，会认为是一个新的提交，实际上内容没有变化。然后他需要合并这个提交才能继续开发，合并后会存在两份相同的提交历史。这个合并推送到服务器，会导致其他开发者不必要的疑惑。变基详细说明：https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E5%8F%98%E5%9F%BA 本地撤销操作git checkout -- filePath [工作区撤销单个文件修改] git checkout commitId filePath [单个文件回滚] git reset HEAD fineName [暂存区撤销单个文件修改] git reset HEAD --hard commitid [本地回滚到版本号为commitid] git push origin HEAD --force [同步回滚远程版本] 如果不小心把问题代码同步到了远程，为了不影响其他人开发，可考虑强制回滚代码。git reset HEAD commitID [1.本地问题版本先回滚 ] git push -f 或者 git push --force [2.把本地代码强制同步远程] 或 git revert [撤销上一次提交] 或 如果要回滚到较远的版本，比较暴力的方法：拉取一份新副本，手动把改动的新代码覆盖到新副本并提交。 参考： https://blog.csdn.net/fuchaosz/article/details/52170105对于单次commit操作的再修改可以继续add 文件 并执行git commit --amend [合并上次提交为本次提交] 冲突处理修改冲突文件后再次执行add、commit操作 log 查询git log git log --author=authorName [指定提交人]git log --pretty=oneline [单行显示log信息] log更多用法：https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2 彩蛋存送门：https://git-scm.com/download/gui/mac","categories":[{"name":"git","slug":"git","permalink":"https://zengbailiang.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://zengbailiang.cn/tags/git/"}]},{"title":"算法-两个有序数组找交集","slug":"2018-03-21-0","date":"2018-03-20T16:00:00.000Z","updated":"2018-07-22T08:53:47.932Z","comments":true,"path":"2018-03-21-0.html","link":"","permalink":"https://zengbailiang.cn/2018-03-21-0.html","excerpt":"","text":"有两个长度分别为m,n的升序数组,其中n&gt; m*m,求这两个数组的交集,要求其复杂度尽可能低。 如： 数组a :-10,6,7 数组b:-15,1,3,4,5,6,7,8,9,10,15 输出：6，7 思路分析：最直接的思路，两层循环嵌套，找出两者的交集。 void intersection0(int *a,int lenA,int *b,int lenB)&#123; for (int i = 0 ; i &lt; lenA; i ++) &#123; int num = *(a + i); for (int j = index ; j &lt; lenB; j ++) &#123; int temp = *(b + j); if (num == temp) &#123; printf(\"%d \",num); &#125; &#125; &#125;&#125; 时间复杂度分析：最好的情况为：m + （1 + 2 + … + m = m + m^2 /2+m/2 渐进为m^2 ;最坏的情况为：m + m *(m *m) = m^3 +m ；渐进为m^3；平均复杂度为：m^3 优化：由于本身是一个升序的数列，当第一个元素查找到的时候，其下标为index，那么把index+1作为下一个元素的查找起始下标；如果第一个元素没有找到，记录B数组第一个比他大的元素的index作为下一个元素的查找起始下标。通过把查找范围不断缩小，查找的效率就会有所提高。优化后的代码： void intersection0(int *a,int lenA,int *b,int lenB)&#123; for (int i = 0 ; i &lt; lenA; i ++) &#123; int num = *(a + i); int index = 0; for (int j = index ; j &lt; lenB; j ++) &#123; int temp = *(b + j); if (num == temp) &#123; index = j + 1;//记录下标，作为下一元素的起始查找下标。 printf(\"%d \",num); &#125; else if (temp &gt; num) &#123; index = j;//记录下标，作为下一元素的起始查找下标。 &#125; &#125; &#125;&#125; 优化后的时间复杂度分析：最好的情况为：m + m = 2m 渐进为m；最坏的情况为：m + 1 + 2+ 3…+ m 渐进为 m^2 ；平均时间复杂度为：m^2 //另外一种写法,时间复杂度跟上面的一样void intersection1(int *a,int len0,int *b,int len1)&#123; int i ,j; i = 0; j = 0; while (i &lt;= len0 - 1 &amp;&amp; j &lt;= len1 - 1) &#123; if (*(a + i) == *(b + j)) &#123; i ++; j ++; &#125; else if (*(a + i) &gt; *(b + j)) &#123; j ++; &#125; else &#123; i ++; &#125; &#125;&#125; 分析与改进可见上面的算法都是m的平方阶或立方阶，并不理想。因为a数组遍历是必须的，问题就转变为提高在b数组中查找效率。复杂度计算应该为m(??)这样的形式，可不可以实现m(logm)这样的线性对数阶呢。比较简单的是使用二分查找。同时为了在查找的过程中不断收窄比较范围，使用双向间隔查找的方式。 具体过程：先查找a[0]并收窄查找下限，然后查找a[lenA - 1- 0]并收窄查找上限，然后进入下一轮。另外b数组的元素分布比较均匀的话，可以使用插值查找，效率会比二分法高不少。插值查找关键步骤mid = low + (height - low ) *(key - b[low])/(b[height]-b[low] )。 void intersection(int *a,int len0,int *b,int len1)&#123; int low = 0; int height = len1 - 1; int tempLow = low; int tempHeight = height; int mid; //双向间隔遍历查找 for (int i = 0 ; i &lt;= len0/2; i ++) &#123; //如果是同于个元素结束,考虑i执行了++，就是上轮的右边等于当前的左边 if(i == len0 - i) &#123; break; &#125; low = tempLow; height = tempHeight; mid = (low + height)/2; //左边开始查找,并调整下限 int num = *(a + i); while (height &gt;= low) &#123; printf(\"mid %d\\n\",mid); int temp = *(b + mid); if (num == temp) &#123; tempLow = mid;//调整下限 break; &#125; else if (low == height) &#123; tempLow = mid;//调整下限 break; &#125; else if (num &lt; temp) &#123; height = mid - 1; &#125; else &#123; low = mid + 1; &#125; mid = (low + height)/2; &#125; printf(\"-------右边-----\\n\"); //如果是同于个元素结束 if(i == len0 - 1 - i) &#123; break; &#125; low = tempLow; height = tempHeight; mid = (low + height)/2; //右边开始查找,并调整上限 int num1 = *(a + len0 - 1 - i); while (height &gt;=low) &#123; int temp = *(b + mid); if (num1 == temp) &#123; tempHeight = mid;//调整上限 break; &#125; else if (low == height) &#123; tempHeight = mid;//调整上限 break; &#125; else if (num1 &lt; temp) &#123; height = mid - 1; &#125; else &#123; low = mid + 1; &#125; mid = (low + height)/2; &#125; &#125;&#125; 但是，这样输出的顺序也是间隔的。所以，如果要求输出是升序的话，这个输出的时候就要处理下，左边遍历的可以马上输出，右边遍历的需要存储起来，处理结束后，再顺序输出。 参考资料：插值查找:https://blog.csdn.net/wangyunyun00/article/details/23464359","categories":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zengbailiang.cn/tags/算法/"}]},{"title":"github page 域名绑定、域名设置https配置","slug":"2018-03-17-1","date":"2018-03-15T16:00:00.000Z","updated":"2018-07-22T08:53:45.134Z","comments":true,"path":"2018-03-17-1.html","link":"","permalink":"https://zengbailiang.cn/2018-03-17-1.html","excerpt":"","text":"最近搭建了个人博客，网上教程很多，最后选择使用github page + 个人域名 + 配置https的方案。主要参考：http://beiyuu.com/github-pages 一、域名与github page 的配置问题。fork模板仓库后，在git端需要进行三步配置： CNAME文件修改【内容必须为一行】 修改仓库名称为：userName.github.io，此为github page要求的命名方式。 进入仓库setting进行设置。 域名解析配置中需要配置ip地址：分两步 获取github page的ip地址。 配置域名解析【这里使用的是阿里云的域名，其他的域名配置应该是类似的。更新后大概需要10分钟左右才能生效】 两者都没配好的时候，访问userName.github.io时可能会跳转到github的404页面。如果两者都对应ip地址配置好的，清空本地缓存并多刷新访问，有可能页面缓存或dns缓存没刷新。 二、github page 不支持证书绑定，通过dns代理跳转实现。具体参考：https://segmentfault.com/a/1190000007740693与教程中不同的是，新版的page rule有所不同，没有了always use Https这个配置了，忽略即可。 相关资源参考：//主流程http://beiyuu.com/github-pages//https配置https://segmentfault.com/a/1190000007740693","categories":[{"name":"swift","slug":"swift","permalink":"https://zengbailiang.cn/categories/swift/"}],"tags":[{"name":"github page","slug":"github-page","permalink":"https://zengbailiang.cn/tags/github-page/"},{"name":"域名绑定","slug":"域名绑定","permalink":"https://zengbailiang.cn/tags/域名绑定/"},{"name":"域名设置https配置","slug":"域名设置https配置","permalink":"https://zengbailiang.cn/tags/域名设置https配置/"}]},{"title":"初入swift-常量变量、可选类型、可选绑定、隐式解析可选类型","slug":"2018-03-17-0","date":"2018-03-13T16:00:00.000Z","updated":"2018-07-22T08:53:43.680Z","comments":true,"path":"2018-03-17-0.html","link":"","permalink":"https://zengbailiang.cn/2018-03-17-0.html","excerpt":"","text":"最早接触swift的时候是swift2.0，现在已经到了swift4.0了。可惜的是项目中一直没有机会使用swift，但最近回顾swift的时候发现swift确实有很多优点。swift是一门强类型的语言，它有类型推断、它的语法提供尽量精简的表达方式，闭包的形式一简再简，化繁为简。例如：类型推断，因为你给变量赋值了，那么其实你的类型就是变量的类型，我能根据已有的信息推断出需要的信息。 为了更好的加深对swift的印象，从语法入手，对比oc，并做总结。 一.swift只有常量和变量。声明变量用var，常量用let，如果一个值不需要变化的话，那么就把它声明为常量。无论是常量和变量在使用前都必须初始化，否则会编译报错。 //swift不需要添加“;”,系统自动识别 let item0 = 1 //系统自动推断出类型为int let item1:Int = 1 //注明类型 var item2 = 1 var item3:String = &quot;hello swift&quot;具备oc没有的类型推断，起到简化代码的效果。同时它隐含着对开发者的要求，要清楚自己赋值的变量类型。 二.可选类型swift提供可选类型来处理值存在缺失的情况。例如你定义一个常量，如果在它的使用期间有可能会为空，那么就有必要把这个常量定义为可选类型。 var item:Int? //定义为可选类型。没有显式赋值，默认赋值为nilswift真机智，又提醒开发者需要搞清楚这个变量会不会存在缺失。 更机智的是，你使用这个值的时候也要考虑几种情况。 当不清楚它是否有值的情况下，获取它的时候可以直接使用变量名，例如print(item) 当明确知道它有值的情况下，使用强制解析（变量后面添加！），如print(item!)。但是如果这个值为nil，使用tiem！就会出现异常。 然后为了区分这两种情况，可以通过if进行判断，这里又有一个叫做可选绑定的概念。 var item：Int？ //普通的if判断 if item != nil { print(tiem!) } else { //不操作，反正是为nil } //可选绑定 //temp只做输出作用，如果item赋值给temp有值，那么进入第一个分支，temp只做输出作用，不需要再进行强制解析。 if let temp = item { print(temp) } else { }从语法的角度来分析，要避免使用item！且item = nil 的情况，因为这种情况会导致程序崩溃。但是从swfit的设计思想和开发者的角度来看，要更清楚每个常量变量的作用、生命周期会不会存在为空的情况等。使用强制解析的时候，必须确保有值。 三、相对可选类型，另外有一个隐式解析可选类型如果你总能确定这个常量在它的生命周期中一定有值，那么就没有必要每次都进行if判断或者可选绑定，这样是非常低效的。直接把类型定义为隐式解析可选类型。形如： //可选绑定 var item0:Int? = 1 let temp0 = item0! //隐士解析可选绑定，问号变成感叹号 var item1:Int! = 1 //直接解析，不需要感叹号 let temp1 = item1小结通过分析可选类型、可选绑定、隐式解析可选类型、变量的获取等用法，去思考下swift为什么要这么设计。能感觉到swift尽量通过语法层面的东西，对开发者有更高的要求，至少在编码的层面要更清楚自己定义的每一个东西，它的作用是怎么样的，会存在什么情况，使用的时候的状态是有值还是没值等等。 待续~","categories":[{"name":"swift","slug":"swift","permalink":"https://zengbailiang.cn/categories/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://zengbailiang.cn/tags/swift/"}]},{"title":"iOS 网络数据-减少重复的字典取值操作、直接获取目的字段","slug":"2018-03-17-4","date":"2018-02-21T16:00:00.000Z","updated":"2018-07-22T08:53:46.610Z","comments":true,"path":"2018-03-17-4.html","link":"","permalink":"https://zengbailiang.cn/2018-03-17-4.html","excerpt":"","text":"当我们处理接口数据的时候，有些情况仅仅需要获取一个或多个字段，来进行状态判断或数据显示。在写这部分代码的时候，或多或少会有一种重复感，但它又不是一成不变的重复，而是其模式相同，大量的字典取值操作，又或者多层的字典取值。这里能否实现一个功能，减少重复操作，一步到位，又或者提高下效率，让这部分代码逻辑变得简洁统一。我想可以自己定义一个取值协议，通过这个协议对数据进行解析，获取目的字段。这样就方便多了，只要根据协议解析就就可以省去很多重复操作。 实现思路获取到后台数据的时候，接口回调回来的是一个字典对象，如果不是，那么需要进行一层处理转换成字典对象。然后，我们只需要对这个字典对象一层一层的解析，直到获取并返回目的字段的值。在解析的过程中，添加必要的健壮性处理，如果无法满足下一步解析的条件，结束解析并返回错误信息。 协议设定传入特定结构的字符串作为解析的依据。而这个字符串的结构规则就是协议的内容。 把”{“作为字典类型的标记 把”[“作为数组类型的标记 在”{“、”[“前添加各自的字段名keyName 由左到右解析 例如：@”keyName0{KeyName1{dstKeyName{“第一层字段名为keyName0，类型为字典，所以先解析出一个字典对象value0。通过value0和第二层字段名KeyName1，解析出一个value1。如此类推，通过value1获取目的字段dstKeyName的值dstValue。其正确的数据结构： &#123; \"keyName0\":&#123; \"KeyName1\":&#123; \"dstKeyName\":&#123; //keys &amp; values &#125; &#125; &#125;&#125; 补充能获取下一层的必须是一个字典对象，就是说协议字符串目的字段之前所有字段的类型标记都为”{“。还有一点，我们可以在目的字段后面添加类型标记，这样的话，就可以根据这个类型标记来判断目的字段的值的类型是否与期待的一致。可以添加NSString、NSNumber类型的符号如NSString对应@，Number对应$等，约定好添加逻辑处理即可。 测试代码： NSString *path = [[NSBundle mainBundle]pathForResource:@\"json\" ofType:@\"txt\"]; NSString *jsonString = [[NSString alloc]initWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]; NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding]; NSError *jsonError = nil; NSDictionary *testDictionary = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:&amp;jsonError]; if (jsonError) &#123; NSLog(@\"error0：%@ \",jsonError); return; &#125; NSNumber *status = [SafeDataProcessor getObjectWithFormmateString:@\"data&#123;status\" data:testDictionary]; //直接获取page字段 NSNumber *page = [SafeDataProcessor getObjectWithFormmateString:@\"data&#123;result&#123;all_page\" data:testDictionary]; //先获取result字段，再获取list字段 NSDictionary *result = [SafeDataProcessor getObjectWithFormmateString:@\"data&#123;result&#123;\" data:testDictionary]; NSArray *list = [SafeDataProcessor getObjectWithFormmateString:@\"list[\" data:result]; NSLog(@\"\\n statu:%@,\\n page:%@,\\n list:%@,\\n result:%@,\\n \",status,page,list,result); 调试结果： 2018-02-22 10:57:25.093365+0800 SafeNetDataProcessor[2882:123596] statu:200, page:20, list:( &#123; \"check_reply_info\" = &#123; num = 6; type = 1; &#125;; content = \"\\U5b66\\U4e60\\U4e0d\\U662f\\U7ed9\\U8001\\U5e08\\U5b66\\U7684\\Uff0c\\U662f\\U7ed9\\U4f60\\U81ea\\U5df1\\U5b66\\U7684\\U3002\"; \"create_time\" = 1518361773; floor = 1; groupid = \"-1\"; \"light_count\" = 1992; pid = 259696; puid = 25941704; quote = ( ); \"quote_deleted\" = 0; smallcontent = \"\\U5b66\\U4e60\\U4e0d\\U662f\\U7ed9...\"; time = \"8\\U5c0f\\U65f6\\U524d\"; togglecontent = \"\"; \"update_info\" = 0; userImg = \"http://i1.hoopchina.com.cn/user/665/256623943989665/256623943989665-1518360162.jpeg@45h_45w_2e\"; userName = \"\\U4e8c\\U53f7\\U8001\\U6d41\\U6c13\"; \"user_banned\" = 0; via = 9; &#125;, 功能的优缺点分析优点：这个功能的优点很明显，就是把分散的处理集中了，输入结构字符串和网络返回值，即可获取目的字段的值，中间的健壮性处理和取值操作都可以省掉了，从这个角度看，减少了编码工作，提高了效率；同时，统一的健壮性处理，只要保证内部处理正确稳定，那么该部分处理就是稳定安全的。对比原来，每次都要手写一次，难保每次都是正确的，特别拷贝大段代码进行修改，这样的操作容易出现低级错误。 缺点：根据字符串来解析，所以会有额外的字符串操作处理，使程序的执行效率变低。 小结从程序运行的角度来看，效率最高的的固然是最贴近需求，无多余操作的代码。但从软件开发的角度来看，程序本身执行效率很重要，但是程序健壮性、编码效率和编码质量也同样重要。 demo地址:https://github.com/zmubai/SafeDataProcessor end~","categories":[{"name":"net data","slug":"net-data","permalink":"https://zengbailiang.cn/categories/net-data/"}],"tags":[{"name":"网络数据处理","slug":"网络数据处理","permalink":"https://zengbailiang.cn/tags/网络数据处理/"}]},{"title":"iOS 网络数据处理技巧，提高程序健壮性","slug":"2018-03-17-3","date":"2018-02-18T16:00:00.000Z","updated":"2018-07-22T08:53:45.894Z","comments":true,"path":"2018-03-17-3.html","link":"","permalink":"https://zengbailiang.cn/2018-03-17-3.html","excerpt":"","text":"作为一名移动开发者，免不了跟网络数据打交道。在需求开发的过程中，我们会通过接口文档约定好前后端交互的数据结构，基于这个，我们能顺利地实现前端的数据交互，顺利的把数据送往后台。如果我们严格遵守双方约定，就可以大大的减少数据问题。但是，数据这东西无法保证百分百准确，为了避免数据错误导致更大的程序错误，我们必须对数据做严格校验，从而保证程序的健壮性。 /* //示例数据结构： { &quot;data&quot;:{ &quot;status&quot;:200, &quot;result&quot;:{ &quot;list&quot;:Array[20], &quot;all_page&quot;:20 } }, &quot;status&quot;:0 } */网络数据健壮性处理逐层判断从外到里一层一层的判断，确保每一步操作成功了才进行下一步操作。 + (NSDictionary *)resultWithResponseDictionary:(NSDictionary*)responseDictionary { NSAssert([responseDictionary isKindOfClass:[NSDictionary class]], @&quot;responseDictionary should be dictionary class&quot;); if (![responseDictionary isKindOfClass:[NSDictionary class]]) return nil; NSDictionary *data = [responseDictionary valueForKey:@&quot;data&quot;]; if (![data isKindOfClass:[NSDictionary class]]) return nil; NSDictionary *result = [data valueForKey:@&quot;result&quot;]; if (![result isKindOfClass:[NSDictionary class]]) { return nil; } else { return result; } } + (NSArray *)getListWithResponseDictionary:(NSDictionary*)responseDictionary { NSDictionary *result = [self resultWithResponseDictionary:responseDictionary]; NSArray *list = [result valueForKey:@&quot;list&quot;]; return [list isKindOfClass:[NSArray class]]?list:nil; }字段类型判断因为OC是动态语言，对象的真实类型在运行的时候才能确定，如果不添加类型判断，在网络数据处理的场景下，可能会出现对象真实类型与期待类型不一致的情况，导致方法调用失败，程序异常崩溃。例如，预期的是一个NSString对象，调用了NSString类独有的substringFromIndex方法，运行的时候却是一个NSNumber对象，继续调用substringFromIndex方法，就会产生一个运行时崩溃。另一种情况，调用的是共同父类的方法 ，NSNumber对象执行方法不会发生异常，但这时程序已经存在风险了，因为对象类型已经不符程序预期。可通过- (BOOL)isKindOfClass:(Class)aClass对类型进行判断。 非空判断空对象调用方法是不会产生异常的，而操作空对象就可能出现异常，例如数组操作、字典操作等。如： //测试代码 NSMutableDictionary *dic = @{}.mutableCopy; [dic setObject:nil forKey:@&quot;age&quot;]; 异常： *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;*** -[__NSDictionaryM setObject:forKey:]: object cannot be nil (key: age)&apos; //测试代码 [@[].mutableCopy addObject:nil]; 异常： *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;*** -[__NSArrayM insertObject:atIndex:]: object cannot be nil&apos;为了避免类似的问题，需要在操作对象前添加必要的非空判断。 单个字段逻辑合法性判断对于一些有意义的字段，这些字段有其合法的取值区间，那么操作该数据时需要先判断其数据是否合法，例如：年龄age， 其合法性校验age&gt;0 。 字段间逻辑合法性判断有一些字段之间存在逻辑关系，特别是提交数据给后台的时候，我们更需要在提交之前做一次数据间逻辑合法性的校验。如 x、y、z字段之间有如下关系：z = 2x + y。那么提交数据前就需要判断下其是否符逻辑z = 2x + y。 小结1、2、3点在网络数据处理中是非常有必要的，而4、5点加强了对数据逻辑的校验，更加贴近业务。同时，4、5点一般采取断言的方式进行处理。在开发测试的过程中，如果存在问题，我们期待通过断言及时发现问题。 end~","categories":[{"name":"net data","slug":"net-data","permalink":"https://zengbailiang.cn/categories/net-data/"}],"tags":[{"name":"网络数据处理","slug":"网络数据处理","permalink":"https://zengbailiang.cn/tags/网络数据处理/"}]},{"title":"iOS m3u8本地缓存播放(控制下载并发、暂停恢复)","slug":"2018-03-17-5","date":"2017-10-10T16:00:00.000Z","updated":"2018-07-22T08:53:47.282Z","comments":true,"path":"2018-03-17-5.html","link":"","permalink":"https://zengbailiang.cn/2018-03-17-5.html","excerpt":"","text":"目录一、m3u8缓存播放的整个流程二、控制媒体下载的并发数三、控制单个媒体的切片下载并发数四、下载的中断和恢复五、注意的问题与思路延伸 一、m3u8缓存播放的整个流程 下载m3u8文件 解析m3u8文件获取视频切片单元的信息。 根据2.获取的视频切片信息中的切片链接下载切片并保持到本地。 根据获取的切片信息与本地服务器的配置信息，拼接出切片的本地地址、生成新的m3u8文件并保存到本地。 开启本地服务器，使用本地url播放本地m3u8文件。 附上：时序图，具体可看demo 二、控制媒体下载的并发数这里使用信号量来控制并发数- (void)downloadVideoWithUrlString:(NSString *)urlStr downloadProgressHandler:(ZBLM3u8ManagerDownloadProgressHandler)downloadProgressHandler downloadSuccessBlock:(ZBLM3u8ManagerDownloadSuccessBlock) downloadSuccessBlock&#123; dispatch_async(_downloadQueue, ^&#123; dispatch_semaphore_wait(_movieSemaphore, DISPATCH_TIME_FOREVER); __weak __typeof(self) weakself = self; [[self downloadContainerWithUrlString:urlStr] startDownloadWithUrlString:urlStr downloadProgressHandler:^(float progress) &#123; downloadProgressHandler(progress); &#125; completaionHandler:^(NSString *locaLUrl, NSError *error) &#123; if (!error) &#123; [weakself.downloadContainerDictionary removeObjectForKey:[ZBLM3u8Setting uuidWithUrl:urlStr]]; NSLog(@\"下载完成:%@\",urlStr); downloadSuccessBlock(locaLUrl); &#125; else &#123; NSLog(@\"下载失败:%@\",error); [self resumeDownload]; &#125; NSLog(@\"%@\",weakself.downloadContainerDictionary.allKeys); dispatch_semaphore_signal(_movieSemaphore); &#125;]; &#125;);&#125; //这里可以设置_movieSemaphore的的初始值为具体的可同时下载数。Example:_movieSemaphore = dispatch_semaphore_create(1),意味着同一时间只允许下载一个视频，等同于视频的串行下载。三、控制单个媒体的切片下载并发数开始的时候，考虑使用AFURLSessionManager中的operationQueue.maxConcurrentOperationCount来控制并发。但这是行不通的。因为这个queue是用于回调而不是用于下载队列。/** The operation queue on which delegate callbacks are run. */@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue; 再看AF中初始化 - (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123; self = [super init]; if (!self) &#123; return nil; &#125; if (!configuration) &#123; configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; &#125; self.sessionConfiguration = configuration; self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];... 这个queue确实是用于回调，而我是需要控制下载并发。这似乎不满足。而且实测中也发现确实不行。那么，只能在任务发起哪里做并发控制，同样，这里还是采用信号量。这里的控制相对复杂一点、因为后面的任务恢复、失败任务重新创建也要做控制。- (void)startDownload&#123; //因为这是外部调用的方法，操作的执行要放到异步线程中。避免因为并发控制中的等待而堵塞外部线程 dispatch_async(self.downloadQueue, ^&#123; if (!_fileDownloadInfos.count) &#123; _completaionHandler(nil); return; &#125; NSLog(@\"downloadInfoCount:%ld\",(long)_fileDownloadInfos.count); [_fileDownloadInfos enumerateObjectsUsingBlock:^(ZBLM3u8FileDownloadInfo * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; //控制切片下载并发 dispatch_semaphore_wait(self.tsSemaphore, DISPATCH_TIME_FOREVER); if ([ZBLM3u8FileManager exitItemWithPath:obj.filePath]) &#123; obj.success = YES; [self verifyDownloadCountAndCallbackByDownloadSuccess:YES]; &#125; else &#123; //如果收到中断信号，中断下载流程释放信号量并返回 if (self.suspend) &#123; obj.beStopCreateTask = YES; dispatch_semaphore_signal(self.tsSemaphore); NSLog(@\"suspend and return! don not createDownloadTask!\"); return ; &#125; else &#123; //真正的创建下载任务 [self createDownloadTaskWithIndex:idx]; &#125; &#125; &#125;]; &#125;);&#125;//信号量在每个任务的回调后都会释放一次- (void)verifyDownloadCountAndCallbackByDownloadSuccess:(BOOL) isSuccess&#123; dispatch_semaphore_signal(self.tsSemaphore);... 这里也看到信号量的控制问题，必须理清信号量的获得和释放时机，一次获得必须有一次释放。不释放或者重复释放，都会导致并发的控制不准。如果这样，那这里的并发控制就没有意义了。 要做到准确获取和释放，重点在于理清程序的执行路径。在每一条执行路径中都必须释放信号量。这个跟锁的使用也是一样的。 调试现象：如果程序不像预料中运行，又没有什么错误，那很有可能就是堵塞了。锁没有释放或者信号量的处理有问题。处理步骤：点击xcode调试栏的暂停按钮，查看程序的调用栈，分析每个线程的运行情况，找到堵塞具体执行代码。根据具体的逻辑修正问题。 四、下载的中断和恢复这里有几个小问题：根据判断NSURLSessionTask 提供的3个方法可以做一些中断和恢复处理 (void)suspend; 挂起任务，但只能挂起执行中的任务。对于已经创建而且执行resum方法但并没真正执行的任务无效（这里非常坑）。通常我们使用这个方法的时候会判断下任务的具体状态，如果是task.state == NSURLSessionTaskStateRunning采取执行 [task suspend]。但这个判断是不准确的。如果一个任务创建并执行resume但并没真正执行，它的状态也是为NSURLSessionTaskStateRunning。如果这个时候程序收到中断消息，对状态为NSURLSessionTaskStateRunning 的任务全部执行suspend操作，你会发现有些任务不听话，继续执行。到底什么搞鬼…我的理解是这样的，这些不听话的任务正是那些添加到下载队列中等待执行的任务，而在等待状态下收到suspend消息是不管用的。但它接收cannel消息是管用的。那么问题的解决就是找出这些等待的任务。处理办法：通过判断接收字节数来区分状态。现在我只面向你接收的字节数，而不管你真开启还是假开启了。 switch (obj.downloadTask.state) &#123; case NSURLSessionTaskStateRunning: &#123; //等待中，假开启状态， if (obj.downloadTask.countOfBytesReceived &lt;= 0) &#123; [obj.downloadTask cancel]; &#125; else &#123; //正在下载，真开启状态， [obj.downloadTask suspend]; &#125; &#125; break; (void)resume;官方文档是这么说明的：Resumes the task, if it is suspended.意思是指只能发起被挂起的任务。存在两种情况： 1.新创建的任务并没有执行resume，此时状态为：NSURLSessionTaskStateSuspended2.执行suspend方法后被手动挂起的任务，状态同为NSURLSessionTaskStateSuspended。 同时这里提供了额外信息：状态为NSURLSessionTaskStateCompleted的任务是不能通过resume重新发起的。而在某些情况下我们需要对这种状态的任务重新发起，包括手动cannel的、执行失败的。这种情况下只能根据具体的情况，重新创建任务并发起。 if (obj.downloadTask.error &amp;&amp; obj.downloadTask.state == NSURLSessionTaskStateCompleted)&#123; //下载失败的任务重新创建 [self createDownloadTaskWithIndex:idx]; &#125; (void)cancel;官方文档说明： This method returns immediately, marking the task as being canceled. Once a task is marked as being canceled, URLSession:task:didCompleteWithError: will be sent to the task delegate, passing an error in the domain NSURLErrorDomain with the code NSURLErrorCancelled. A task may, under some circumstances, send messages to its delegate before the cancelation is acknowledged.This method may be called on a task that is suspended. 简而言之：调用这个方法可以cannel任意状态的任务包括挂起的任务。并执行didCompleteWithError回调（AF中会执行回调并返回错误NSURLErrorCancelled），状态被标记为NSURLSessionTaskStateCompleted。故上面恢复失败任务的时候，通过task.state和task.error共同判断。 总结下任务生命周期中的任务状态变化： 创建成功：…Suspended 执行resume:…Running（可以通过判断countOfBytesReceived来区分任务处于等待还是下载中） 执行suspend：…Suspended 执行cannel：(中间状态…Canceling）-&gt;…Completed（可以结合task.error判断任务执行结果） 回归正题：视频单元的中断和恢复，中断就是调用suspend方法挂起正在执行的任务，cannel掉等待的任务，代码跟上面说明方法的时候非常雷同。这里着重说明下恢复。如果单单恢复其实很简单，恢复挂起的任务和重新创建错误的任务。这只是从程序的角度看待，要使一个程序有更高的可用性，应在功能实现的同时做的更加的合理。应优先恢复挂起的任务、然后重新创建错误的任务。这样做都是为了承前启后更快的把一个下载任务完成。而且这个视频切片是讲究有序的，所以我们恢复的时候也要遵从FIFO的原则。五、注意的问题与思路延伸 解析m3u8注意的问题 这里的解析格式太多，很容易出现问题，应使用try/catch来保证程序的健壮性。 根据url获取原始m3u8文件信息，这个操作太耗时了。为了提高程序的效率，获取到原始m3u8文件后应做本地持久化并用于二次下载。如果整个流程下载成功，可以选择删除该文件，或者不操作。由于是纯文本文件，少量的文件冗余是允许的。 文件的操作通过开启一个同步队列来处。可以设定low优先级避免占用太高的cpu资源。其实高cpu占用会伴随着另外一个问题，手机的发热量。 key的处理问题 如果存在key的下载，需要把key下载到本地，约定好key的名称和新建m3u8文件中的key链接。这样本地播放就能正常加解密。例如下载到本地的key保存为…/key。那么链接应该是http:localhost:port/…/key 中断的优先级 程序的中断操作拥有最高优先级的，因为要任何状态下都能中断下载。无论是为了程序的流畅性、网络变为移动信号避免使用用户的移动流量等发出中断命令，都必须立即响应。 切片数量的全局分配 多个视频同时下载，多个切片同时并发。如果要做到控制全局的切片并发数而不是单个视频的切片并发数。这就要设计一个算法在全局Manger哪里做分配和回收。 保证app流程，监控网速开启和中断下载 下载视频的功能应该要保证app本身网络请求的正常运行。app如何获取到网络的带宽，好像只能通过下载文件方式来推算。可在应用请求空闲时通过短时间下载一个可用源来计算带宽，同时监控app 实时网络吞吐，适当的开关下载。虽然很难做到实时，但是在切换网络的时候进行带宽重测、又或者地理位置变化一定距离后进行带宽重测、又或者定时作带宽重测。还有就是考虑wifi状态下才进行下载。 切换网络后请求失去连接，恢复下载的问题 因为网络切换本地ip变化，发起的请求会失去连接。如果通过downloadTask是没办法做到恢复下载的。虽然可以用resumeData来恢复下载，但是这个只能在cannel操作的时候获取，至于失去连接的情况下是没办法获取到的（系统提供的api中没有在失败回调哪里返回resumeData的）。这个时候需要自己创建文件句柄，使用dataTask做到文件续下。初始化dataTask的时候设定请求头’Accept-Ranges’参数为文件的已下载字节数（需要服务器支持），就可以获取到未下载的部分数据。 并发中锁的处理 要理清那些代码可能存在并发，那些操作要保证原子性。难就难在一个方法中会存在部分代码块是并发执行的，这有利于效率的提高；部分些代码要原子操作。最优的做法就是对原子操作用锁来保证，没有任何多余的代码加入到同步操作中，这样也是效率最高的。而拿捏不准的情况下，可以锁定更多的代码，至少这样不会因为并发而导致问题，但这样就牺牲了效率和及时性。当一个简单的系统，要做到最优好像并不难，但是一个复杂的系统做到最优就非常难了或者是要花费非常大的精力。 是否需要全部切片下载完成才能播放 其实并不需要全部下载完成就能播放的。一个车子开起来只要保证后面的能源供应充足就能一直正常运作。首先保证key 先下载下来，而且要保证有序下载，然后下载一定量的切片文件，这个时候就可以组装m3u8文件到本地，发起播放。只要后面下载的切片能满足播放器的播放，就不会出现问题。但如果供应不足视频就会停了，播放不了，尽管后面文件下载下来了，还是不能自动恢复，仿佛失去了缓冲功能。这里就是跟直接请求服务器的差别了，直接请求服务器，因为文件本身是存在的，发起的请求是存在的，如果网速慢，播放器的反应是缓冲；而本地服务播放就不同了，如果文件在播放前没有下载下来，发起的请求立马就挂了，这个请求不存在，当然就不存在缓冲。 线程多开占用资源，每个线程占用512K到1M空间。建议使用单线程下载，且稳定性高。 dome链接：https://github.com/zmubai/ZBLM3U8DownLoadTest","categories":[{"name":"m3u8","slug":"m3u8","permalink":"https://zengbailiang.cn/categories/m3u8/"}],"tags":[{"name":"m3u8","slug":"m3u8","permalink":"https://zengbailiang.cn/tags/m3u8/"}]}]}