<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="知行合一"><meta name="keywords" content><meta name="author" content="liang"><meta name="copyright" content="liang"><title>liang's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">liang</div><div class="author-info__description text-center">知行合一</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">51</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">14</span></a></div></div></div><nav id="nav" style="background-image: url(/personImg/topimg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">liang's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">about</a></span></div><div id="site-info"><div id="site-title">liang's blog</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/xianhuzhiwuyuan.html">仙湖植物园一游</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/记事/">记事</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/散文/">散文</a></span><div class="content">仙湖植物园一游冬日里，游园有一番趣味。有一种安逸恬静的感觉。特别是天气冷的刚好好，与友人一起慢慢的漫步干净的泊油路上，看见美丽的风景，呼吸清新的空气，或者谈笑风生，或者静静的欣赏风景，也是一大乐事。



这里帮一家人拍照，感觉生涩和开心。那是一家人，两个老人家，还有他们的女儿和双胞胎外孙女，小孩子的妈妈说“快点过来，哥哥帮我们拍照了。” 哈哈，听到还能被叫哥哥，好开心。可惜等了片刻，小孩子好像被什么好玩的吸引了，玩得不亦乐乎，没有过来拍照。

感觉这个画面好美，有天空的蓝，湖面的青，水杉的红，人和景色融合的很美。
冬日恬静
冬日恬静
正在上阶梯的女孩，一种冬日恬静的美感。



</div><a class="more" href="/xianhuzhiwuyuan.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/124. 二叉树中的最大路径和.html">124. 二叉树中的最大路径和</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content">124. 二叉树中的最大路径和给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。示例 1:输入: [1,2,3]       1      / \     2   3输出: 6示例 2:输入: [-10,9,20,null,null,15,7]   -10   / \  9  20    /  \   15   7输出: 42

解：使用dfs递归遍历树。
  A / \B   C


拿一个完整的最简单的二叉树结构单元进行分析。使用dsp遍历回到根节点的时候，存在3种情况的路径，分别是

A + left 
A + right
A 

那么对于节点A , 其最大路径取三者中最大值。然后继续递归返回。这种情况是作为一个大的路径的部分返回到父节点，继续递归返回。
如果
但最大路径有可能在遍历的任意一次产生，分4种情况

只取root
root + left
root + right
root + left + right

取较大者。要存储和更新这个值，可能通过全局变量，或把指针作为函数参数传 ...</div><a class="more" href="/124. 二叉树中的最大路径和.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/236. 二叉树的最近公共祖先.html">236. 二叉树的最近公共祖先</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

解：p ,q 分别为两个的子节点。使用bsf。在遍历的过程值，函数设定返回一个节点。可以这样设定：

如果仅仅找到p 或q，那么把其返回。
那么如果 left 和right 都有值返回，代表两个节点，分别在两边找到，此时的父节点就是他们的最近公共祖先。 
如果仅仅一边有值，那么继续把值为p或q向上传递。

具体代码注释如下：
// 如果找到其中一个那么返回找到的那个，如果两个都找不到返回null， 如果两个都找到返回最近公共祖先TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;    if (root == NULL) &#123;  ...</div><a class="more" href="/236. 二叉树的最近公共祖先.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/148. 排序链表.html">148. 排序链表</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"> 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。示例 1:输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4示例 2:输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5

解1：自底向上的分析过程，局部排序到整体排序。1-》2-》4-》x （x&gt;=size）
描述下主要过程：

获取链长度，从而能确定循环的结束条件。当size == len -1的时候为循环的最后一次。
循环过程：size属于[1,len -1]。内循环对链表以size进行分割成长度为size的left right ，已经剩下部分的cur，并用tail拼接left、right合并后的部分。cur继续以size切换进行内内循环，直到以size为大小的局部排序结束，同时tail指向dummyHead的地址，因此获取dummyHead.next为上次局部排序后的链表，继续外内循环，直到结束。最后返回dummyHead.next。（代码中使用preHead,表示dummyHead，d ...</div><a class="more" href="/148. 排序链表.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/146. LRU缓存机制.html">146. LRU缓存机制</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"> 运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

解：使用双向链表来快速处理和调整，最近使用的元素.

put 分两种情况，如果存在，那么把已有元素调整到链头（拿出，删除，在插入）；如果不存在，直接插入。
获取元素类似，存在，那么调整到头并返回。不存在那么返回-1；

class LRUCache &#123;public:    LRUCache(int capacity) &#123;        maxSize = capacity;    &#125;        int get(int key) &#123;        if (m.find(key) != m.end())&#123;			 ...</div><a class="more" href="/146. LRU缓存机制.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/238. 除自身以外数组的乘积.html">238. 除自身以外数组的乘积</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"> 给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。示例:输入: [1,2,3,4]输出: [24,12,8,6]说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。

解：
暴力法。两层循环。 时间复杂度为O(n^2)。
除自身外的乘积，等于其左边元素的乘积 和 其右边元素的乘积 的 乘积。使用两个临时数组分别保存对应下标其左边的元素积和右边元素的积。由于只是遍历两次，并没有循环嵌套，所以时间复杂度为O(n)。

vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; res (nums.size() ,1);    int temp = 1;    for (int i = 0; i &lt; nums.size(); ++ i) &#123;        res[i] = temp;        temp *=  ...</div><a class="more" href="/238. 除自身以外数组的乘积.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/33. 搜索旋转排序数组.html">33. 搜索旋转排序数组</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1

解：由于题目说道数组是有序的，虽然做了旋转，且要求时间复杂度为logN，那么很容易会想到二分。
思路：存在旋转的分界点，其实就是数组旋转之前的起点。分界点的左边大于分界点，但分界点的左边和右边（包含分界点）都是两个有序的子数组。通过二分很容易确定这个分界点，然后根据target值与数组最后一个元素比较确定查找的子数组，如果小于最后元素，那么target只可能存在于右边子数组，相反存在与右边子数组，设计一个子函数二分查找并返回target在子数组的下标，如果找不到则返回-1.
另外查 ...</div><a class="more" href="/33. 搜索旋转排序数组.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/16. 最接近的三数之和.html">16. 最接近的三数之和</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"> 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).

解1：比暴力法好一点，在最内层做了二分。时间复杂度依然很高 n2 *longn。
int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;    sort(nums.begin(),nums.end());    ///这个初始化是有问题的,对于lastBiger和smaller没有问题，但对于res是可能存在问题，有可能他是最大值的三倍，但刚好是最接近target的，如果这样程序就会错误。这里大概可以设置为MAX_INT 或 MIN_INT。    int undefine = nums[nums.size() - 1] * 3;    int res = u ...</div><a class="more" href="/16. 最接近的三数之和.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/15. 三数之和.html">15. 三数之和</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"> 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]

解：根据题目和例子，结果集是不允许重复的解，但数组中的元素可以重复利用。首先把问题由三个数和为0 转化为,求两个数和为第三个数相反数的问题，并在处理过程中，跳过重复的情况。
步骤：排序数组，从左边i遍历数组，左边i作为最小值。再开启两个下标left,right从两边查找，查找和为nums[i]的相反数。其中如果nums[i]&gt;0,那么就代表右边不可能存在解的可能，可以退出遍历。
而对于每一此遍历，会去查找以num[i]做为最小值的所有非重复解。当找到其中一个解后，做一些处理避免重复后，继续移动两个下标，查找下一组解。所以遍历结束后，可得所有解。
重复处理：
比较重要的去重处理是由两个部分组成。首先循环外判断num[i] 与nu ...</div><a class="more" href="/15. 三数之和.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/435. 无重叠区间.html">1262. 可被三整除的最大和</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content">给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。 示例 1：输入：nums = [3,6,5,1,8]输出：18解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。示例 2：输入：nums = [4]输出：0解释：4 不能被 3 整除，所以无法选出数字，返回 0。

解:1.用sum累加所有数。同时使用两个数组，把余数为2和1的分别填充到其中，并对这两数组降序排序（因为要和最大，大的优先使用）。那么有了这两个基础上，结合问题，这个时候计算sum的余数，存在3中情况：

余数为0,直接返回sum.
余数为1，那么又存在两种情况，分别为减去余数为1数组中的最后一个或余数为2数组的最后两个，使sum最大，前提是其他们元素数量满足。
余数为2，那么又存在两种情况，分别为减去余数为2数组中的最后一个或余数为1数组的最后两个，使sum最大，前提是其他们元素数量满足。

static bool compDesc(int a,int b)&#123;    return a &gt; b;&#125;int adjustSum(int rem ,int ...</div><a class="more" href="/435. 无重叠区间.html#more" style="margin-top: 14px">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/personImg/topimg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By liang</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>