<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta name="google-site-verification" content="xdxP4Om7Pxp3OMC73kRMv2emRoA91RXOEPaKMivB_zg" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="liang&#39;s blog">
<meta property="og:url" content="https://zengbailiang.cn/index.html">
<meta property="og:site_name" content="liang&#39;s blog">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liang&#39;s blog">
<meta name="twitter:description" content="知行合一">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zengbailiang.cn/"/>





  <title> Hexo, NexT - liang's blog知行合一 </title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">liang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/1249. 移除无效的括号.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1249. 移除无效的括号.html" itemprop="url">1249. 移除无效的括号</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-19T00:00:00+08:00">
                2019-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/1249. 移除无效的括号.html" class="leancloud_visitors" data-flag-title="1249. 移除无效的括号">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  624
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 给你一个由 &apos;(&apos;、&apos;)&apos; 和小写字母组成的字符串 s。</span><br><span class="line"></span><br><span class="line">你需要从字符串中删除最少数目的 &apos;(&apos; 或者 &apos;)&apos; （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</span><br><span class="line"></span><br><span class="line">请返回任意一个合法字符串。</span><br><span class="line"></span><br><span class="line">有效「括号字符串」应当符合以下 任意一条 要求：</span><br><span class="line"></span><br><span class="line">空字符串或只包含小写字母的字符串</span><br><span class="line">可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」</span><br><span class="line">可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;lee(t(c)o)de)&quot;</span><br><span class="line">输出：&quot;lee(t(c)o)de&quot;</span><br><span class="line">解释：&quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; 也是一个可行答案。</span><br></pre></td></tr></table></figure>
<h4 id="解1："><a href="#解1：" class="headerlink" title="解1："></a>解1：</h4><p>利用栈来处理括号的匹配问题。遍历字符串，遇到”(“入栈，遇到”)”,那么需要查看栈里面是否为空，分两种情况：</p>
<ol>
<li>如果栈不为空，那么存在匹配的”(“，那么出栈，继续遍历。</li>
<li>如果栈为空，那么此”)”找不到匹配，此”)”，必然是需要删除的，把其标记到map中。可能不同的思路处理的方式不一样，有些处理方式可能把其放入栈中，最后的时候在拿出来，删除。</li>
</ol>
<p>最后获取到需要删除的map集合，创建临时字符串res，用于返回，遍历原字符串，并对比map是否存在，不存在的话，拼接到res中，遍历结束后返回res.</p>
<p>map是为了提高对比的效率，空间换时间。看到有些题解，在第一次遍历的时候用特殊字符串例如*替换对应位置的字符，最后遍历的时候通过对比来判定，这样就不需要额外map来处理了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">string minRemoveToMakeValid(string s) &#123;</span><br><span class="line">    stack&lt;int&gt; st;</span><br><span class="line">    map&lt;int,int&gt; map;</span><br><span class="line">    for (int i = 0; i &lt; s.length(); i ++) &#123;</span><br><span class="line">        char c = s[i];</span><br><span class="line">        if (c == &apos;(&apos;) &#123;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(c == &apos;)&apos;)&#123;</span><br><span class="line">            if (!st.empty()) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                map[i] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (!st.empty()) &#123;</span><br><span class="line">        int i = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        map[i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    string res;</span><br><span class="line">    for (int i = 0; i &lt; s.length(); i ++) &#123;</span><br><span class="line">        if(map.find(i) == map.end())&#123;</span><br><span class="line">            res.append(s[i],1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>括号匹配，利用了栈，是此题关键。有时候某些问题，使用合适的数据结构，队列，栈、树等等，能很好的处理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/807. 保持城市天际线.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/807. 保持城市天际线.html" itemprop="url">807. 保持城市天际线</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-19T00:00:00+08:00">
                2019-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/807. 保持城市天际线.html" class="leancloud_visitors" data-flag-title="807. 保持城市天际线">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  796
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 在二维数组grid中，grid[i][j]代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。</span><br><span class="line"></span><br><span class="line">最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。 请看下面的例子。</span><br><span class="line"></span><br><span class="line">建筑物高度可以增加的最大总和是多少？</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">输入： grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]</span><br><span class="line">输出： 35</span><br><span class="line">解释： </span><br><span class="line">The grid is:</span><br><span class="line">[ [3, 0, 8, 4], </span><br><span class="line">  [2, 4, 5, 7],</span><br><span class="line">  [9, 2, 6, 3],</span><br><span class="line">  [0, 3, 1, 0] ]</span><br><span class="line"></span><br><span class="line">从数组竖直方向（即顶部，底部）看“天际线”是：[9, 4, 8, 7]</span><br><span class="line">从水平水平方向（即左侧，右侧）看“天际线”是：[8, 7, 9, 3]</span><br><span class="line"></span><br><span class="line">在不影响天际线的情况下对建筑物进行增高后，新数组如下：</span><br><span class="line"></span><br><span class="line">gridNew = [ [8, 4, 8, 7],</span><br><span class="line">            [7, 4, 7, 7],</span><br><span class="line">            [9, 4, 8, 7],</span><br><span class="line">            [3, 3, 3, 3] ]</span><br></pre></td></tr></table></figure>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>对于每一行或每一列都存在一个边际值，而对于每一个做坐标点，它必须同时满足小于等于它所在的列和行的两个边际值，即其必须小于等于，所在行和列的边界值的最小值&lt;=min(边际值row,边际值col)，而增加的部分累计就是题目所求。基于这个思路，可得以下步骤:</p>
<ol>
<li>定义两个临时数组用于存储行和列的边际值，通过遍历坐标点，更新这些值.一次遍历就可以获取到所有的边际值，[i]相同对比更新hSize，[j]相同对比更新vMaxArr。</li>
<li>再次遍历，累计增加值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int maxIncreaseKeepingSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    long hSize = grid.size();</span><br><span class="line">    long vSize = grid[0].size();</span><br><span class="line">    vector&lt;int&gt; hMaxArr (hSize,0);</span><br><span class="line">    vector&lt;int&gt; vMaxArr (vSize,0);</span><br><span class="line">    //先获取 hMaxArr vMaxArr</span><br><span class="line">    for (int i = 0; i &lt; hSize ; i ++) &#123;</span><br><span class="line">        for (int j = 0 ; j &lt; vSize; j ++) &#123;</span><br><span class="line">            if(grid[i][j]&gt;hMaxArr[i])&#123;</span><br><span class="line">                hMaxArr[i] = grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            if (grid[i][j]&gt;vMaxArr[j]) &#123;</span><br><span class="line">                vMaxArr[j] = grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; hSize ; i ++) &#123;</span><br><span class="line">        for (int j=0 ; j &lt; vSize; j ++) &#123;</span><br><span class="line">            int minLimit = hMaxArr[i] &gt; vMaxArr[j] ? vMaxArr[j] : hMaxArr[i];</span><br><span class="line">            int mayAdd = minLimit - grid[i][j];</span><br><span class="line">            if(mayAdd)&#123;</span><br><span class="line">                res += mayAdd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return  res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这道题的问题思路比较直观。<br>不能超过边际线–》那么要知道每个坐标能到达的上限，其上限是什么？-》其上限就是其所在的行列边际值得最小值。 ==》解题开始，获取边际点，累计高，返回。</p>
<p>这种能有清晰的求解思路的题，相对好解。而有些题目，理清题目，并不容易想到可论证的正确思路（也即是可行思路），例如贪心算法之类的（435. 无重叠区间）。so解题前要尽量快速思考出思路，不断假设，提供条件，换思路等，找到可行思路。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/744. 寻找比目标字母大的最小字母.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/744. 寻找比目标字母大的最小字母.html" itemprop="url">744. 寻找比目标字母大的最小字母</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-19T00:00:00+08:00">
                2019-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/744. 寻找比目标字母大的最小字母.html" class="leancloud_visitors" data-flag-title="744. 寻找比目标字母大的最小字母">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  490
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。</span><br><span class="line"></span><br><span class="line">数组里字母的顺序是循环的。举个例子，如果目标字母target = &apos;z&apos; 并且有序数组为 letters = [&apos;a&apos;, &apos;b&apos;]，则答案返回 &apos;a&apos;。</span><br></pre></td></tr></table></figure>
<h4 id="解1"><a href="#解1" class="headerlink" title="解1:"></a>解1:</h4><p>遍历，然后对比target,记录比target大且差值最小的元素的下标bigIndex，如果存在那么返回letters[bigIndex]。如果没有比traget大的元素，那么根据题意，字母是循环的，那么返回letters[0]。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123;</span><br><span class="line">    int big = -1;</span><br><span class="line">    int bigIndex = -1;</span><br><span class="line">        for(int i = 0; i &lt; letters.size(); i ++)&#123;</span><br><span class="line">            int len = letters[i] - target;</span><br><span class="line">            if(len &gt;= 0)</span><br><span class="line">            &#123;</span><br><span class="line">               if(len &lt; big|| big == -1)&#123;</span><br><span class="line">                   big = len;</span><br><span class="line">                   bigIndex = i;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(big)&#123;</span><br><span class="line">            return letters[big];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return letters[0];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解2"><a href="#解2" class="headerlink" title="解2"></a>解2</h4><p>由于输入是有序数组，那么可能会想到二分。二分就查找比target大的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = (int)letters.size();</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (mid&gt; 0 &amp;&amp; letters[mid - 1] &lt;= target &amp;&amp; letters[mid]&gt; target) &#123;</span><br><span class="line">            return letters[mid];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if (letters[mid]&lt;=target) &#123;</span><br><span class="line">            //注意这里的条件，已经明确的判断出mid不符合要求。所以left = mid + 1;</span><br><span class="line">            //mid，不符合要求，调整下限</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">            //此分支代表, letters[mid]&gt;target,需要调整上限，但mid依然有可能符合要求。</span><br><span class="line">            //mid有可能符合要求，调整上限</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return letters[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分条件判断后，调整上下限时候是有非常严谨的逻辑的，例如+1还是-1，是否= mid等。<br>另外有时候，二分是调整区间找坐标，有时候是给出特定的目标值，来查找坐标，情况很多。甚至二分的判断条件是一个函数，是一个以mid为入参的函数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/1123最深叶节点的最近公共祖先191115.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1123最深叶节点的最近公共祖先191115.html" itemprop="url">leetcode 1123 最深叶节点的最近公共祖先</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-15T00:00:00+08:00">
                2019-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/1123最深叶节点的最近公共祖先191115.html" class="leancloud_visitors" data-flag-title="leetcode 1123 最深叶节点的最近公共祖先">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  669
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> 给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。</span><br><span class="line"></span><br><span class="line">回想一下：</span><br><span class="line"></span><br><span class="line">叶节点 是二叉树中没有子节点的节点</span><br><span class="line">树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1</span><br><span class="line">如果我们假定 A 是一组节点 S 的 最近公共祖先，&lt;font color=&quot;#c7254e&quot; face=&quot;Menlo, Monaco, Consolas, Courier New, monospace&quot;&gt;S&lt;/font&gt; 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：[1,2,3]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：root = [1,2,3,4]</span><br><span class="line">输出：[4]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：root = [1,2,3,4,5]</span><br><span class="line">输出：[2,4,5]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">给你的树中将有 1 到 1000 个节点。</span><br><span class="line">树中每个节点的值都在 1 到 1000 之间。</span><br></pre></td></tr></table></figure>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>最近公共祖先，是指，其下面的节点全部都是他的孩子。那么对应题目,有一种情况比较刺手，当存在不止一个分支的深度都等于树的最大深度，此时，就需要返回他们的共同祖先，而一般使用递归实现的时候，这个好像不好处理，开始这里卡了好久。正如代码所示，使用两个int指针记录分支的深度，当子递归返回时，对比两变量决定是否返回当前的root。</p>
<p>其他情况：1.root为空，返回root。2.存在一个分支的最深叶子，2.1叶子无兄弟节点，返回本身，2.2存在兄弟节点，返回其父节点。<br>3.存在多分支最深叶子，就需要根据深度指针对比，判断和返回。（这个上面单独已经说明）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">     int val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode*  findDeepComm(TreeNode* root,int *deep)&#123;</span><br><span class="line">    if (root != nullptr) &#123;</span><br><span class="line">        *deep += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int *dL = (int*)malloc(sizeof(int));</span><br><span class="line">    int *dR = (int*)malloc(sizeof(int));</span><br><span class="line">    *dL = *deep;</span><br><span class="line">    *dR = *deep;</span><br><span class="line">    TreeNode *nl = root;</span><br><span class="line">    if(root-&gt;left)&#123;</span><br><span class="line">        nl = findDeepComm(root-&gt;left, dL);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *nr = root;</span><br><span class="line">    if (root-&gt;right) &#123;</span><br><span class="line">        nr = findDeepComm(root-&gt;right, dR);</span><br><span class="line">    &#125;</span><br><span class="line">    if (*dL == *dR) &#123;</span><br><span class="line">        *deep = *dL;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        *deep = *dL &gt; *dR ? *dL:*dR;</span><br><span class="line">        return *dL &gt; *dR ? nl : nr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* lcaDeepestLeaves(TreeNode* root) &#123;</span><br><span class="line">    int *deep = (int*)malloc(sizeof(int));;</span><br><span class="line">    *deep = 0;</span><br><span class="line">    return findDeepComm(root,deep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记：其实，根据题目给的例子，把我搞懵了。审题很重要，另外就是对递归的理解，小技巧，深度指针跟踪，递归中常用的小技巧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/887. 鸡蛋掉落 191112.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/887. 鸡蛋掉落 191112.html" itemprop="url">leetcode 887. 鸡蛋掉落</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-12T00:00:00+08:00">
                2019-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/887. 鸡蛋掉落 191112.html" class="leancloud_visitors" data-flag-title="leetcode 887. 鸡蛋掉落">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,267
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">887. 鸡蛋掉落</span><br><span class="line">你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</span><br><span class="line"></span><br><span class="line">每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</span><br><span class="line"></span><br><span class="line">你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</span><br><span class="line"></span><br><span class="line">每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</span><br><span class="line"></span><br><span class="line">你的目标是确切地知道 F 的值是多少。</span><br><span class="line"></span><br><span class="line">无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：K = 1, N = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。</span><br><span class="line">否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。</span><br><span class="line">如果它没碎，那么我们肯定知道 F = 2 。</span><br><span class="line">因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</span><br></pre></td></tr></table></figure>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>动态规划。<br>dp[i][j]表示i个鸡蛋 ,j层需要的次数。<br>当某个时刻楼层为x,仍下鸡蛋，会出现两种情况<br>1.鸡蛋碎了，那么调整范围dp[i-1][x-1]。<br>2.鸡蛋没碎，那么调整范围dp[i][j-x]。</p>
<p>那么dp方程为:<br>dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x]))(+1是因为计算上这本次扔鸡蛋)<br>主要步骤：</p>
<ol>
<li>dp[i][j] 赋值保险值。例如100层，保险值就是100。等于j。</li>
<li>计算dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x]))。</li>
<li>返回dp[K][N]。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Time Limit Exceeded</span><br><span class="line">int superEggDrop(int K, int N) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(K + 1, vector&lt;int&gt;(N + 1));</span><br><span class="line">    for (int i = 1; i &lt;= N; i ++) &#123;</span><br><span class="line">        dp[1][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    //2 - K 个鸡蛋</span><br><span class="line">    for (int i = 2;i &lt;= K; ++i)&#123;</span><br><span class="line">        // 1 - N 层</span><br><span class="line">        for (int j = 1; j &lt;= N; ++j) &#123;</span><br><span class="line">            //赋值最大次数</span><br><span class="line">            dp[i][j] = j;</span><br><span class="line">            //鸡蛋有可能在任何一层砸碎</span><br><span class="line">            for (int x = 1; x &lt; j; ++x) &#123;</span><br><span class="line">                dp[i][j] = min(dp[i][j], 1 + max(dp[i][j - x], dp[i -1][x -1]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[K][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法会超时，需要优化。下面采取二分优化。</p>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int superEggDrop(int K, int N) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp (K+1,vector&lt;int&gt;(N+1));</span><br><span class="line">    //赋基础值</span><br><span class="line">    for (int i = 1 ; i &lt;= N; ++i) &#123;</span><br><span class="line">        dp[1][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    //2 - K egg</span><br><span class="line">    for (int i = 2; i &lt;= K; ++i) &#123;</span><br><span class="line">        // 1 - N floor</span><br><span class="line">        for (int j = 1; j &lt;= N; ++j) &#123;</span><br><span class="line">            //赋保险值</span><br><span class="line">            dp[i][j] = j;</span><br><span class="line">            int left = 1;</span><br><span class="line">            int right = j;</span><br><span class="line">            //二分查找临界点</span><br><span class="line">            while (left&lt;right) &#123;</span><br><span class="line">                int mid = left + (right - left)/2;</span><br><span class="line">                if (dp[i - 1][mid -1] &lt; dp[i][j - mid]) &#123;</span><br><span class="line">                    //mid 过小 向右偏移</span><br><span class="line">                    left = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    //mid 过大，向左偏移</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ///为什么最后right是临界点呢（ring保留mid,不让某些值缺失，但临界值为什么不能发生在left。。。；根据判断条件left&lt;right。可以理解为left一直增大，直到=&gt;right，那么退出循环，此时right就是临界值。这个过程如何一定保证right为临界值！！！），这里有点没想通。</span><br><span class="line">            dp[i][j] = min(dp[i][j], 1 + max(dp[i-1][right-1],dp[i][j-right]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[K][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>再次优化，理论上楼层越多临界点越大，so临界点是一致递增的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int superEggDrop(int K, int N) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp (K+1,vector&lt;int&gt;(N+1));</span><br><span class="line">    //赋基础值</span><br><span class="line">    for (int i = 1 ; i &lt;= N; ++i) &#123;</span><br><span class="line">        dp[1][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    //2 - K egg</span><br><span class="line">    for (int i = 2; i &lt;= K; ++i) &#123;</span><br><span class="line">        // 1 - N floor</span><br><span class="line">        int s = 1;</span><br><span class="line">        for (int j = 1; j &lt;= N; ++j) &#123;</span><br><span class="line">            //赋保险值</span><br><span class="line">            dp[i][j] = j;</span><br><span class="line">            //随着楼层的增加 s会变大。（使用s递增，比解法二的临界值好理解很多，且很容易确定准确性）</span><br><span class="line">            while (dp[i - 1][s -1] &lt; dp[i][j - s]) &#123;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = min(dp[i][j], 1 + max(dp[i-1][s-1],dp[i][j-s]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[K][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种类型的题目，求最值得问题，很可能用到动态规划。且随着变量的递增，后面的结果依赖于之前的过程。抽象出dp方程比较重要。<br>例如本题就比较难抽象，要完全理清题意，准确无误的抽象不容易：</p>
<p>dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x]))</p>
<ol>
<li>dp[i][j],i egg ;j floor</li>
<li>dp[i][j],保险值等于j</li>
<li>每次扔鸡蛋分两种情况，所以有max(dp[i-1][x-1],dp[i][j-x])，max是为了取最坏情况次数。加上当次扔鸡蛋， 所以有1 + max(dp[i-1][x-1],dp[i][j-x])</li>
<li>最终有dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x]))</li>
</ol>
<p>一般来说，有了初步的解题思路，再一步一步优化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/715. Range 模块191109.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/715. Range 模块191109.html" itemprop="url">leetcode 715. Range 模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-09T00:00:00+08:00">
                2019-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/715. Range 模块191109.html" class="leancloud_visitors" data-flag-title="leetcode 715. Range 模块">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,164
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">715. Range 模块</span><br><span class="line">Range 模块是跟踪数字范围的模块。你的任务是以一种有效的方式设计和实现以下接口。</span><br><span class="line"></span><br><span class="line">addRange(int left, int right) 添加半开区间 [left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 [left, right) 中尚未跟踪的任何数字到该区间中。</span><br><span class="line">queryRange(int left, int right) 只有在当前正在跟踪区间 [left, right) 中的每一个实数时，才返回 true。</span><br><span class="line">removeRange(int left, int right) 停止跟踪区间 [left, right) 中当前正在跟踪的每个实数。</span><br><span class="line"></span><br><span class="line">addRange(10, 20): null</span><br><span class="line">removeRange(14, 16): null</span><br><span class="line">queryRange(10, 14): true （区间 [10, 14) 中的每个数都正在被跟踪）</span><br><span class="line">queryRange(13, 15): false （未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）</span><br><span class="line">queryRange(16, 17): true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪）</span><br></pre></td></tr></table></figure>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>使用一个全局数组来存储已有的范围。对于添加，遍历数组，分两种情况判断，1.范围之间不存在交集，那么把rangs[i]加入到临时数组中；2.如果包含（被包含或包含）或者两者存在交集，那么更新left,right,值。重复该过程，直到遍历结束，此时把合成的left,right范围插入到临时数组中，赋值给全局数组，更新范围成功。对于删除，遍历数组，分三种情况判断，1.范围之间没有交集，那么把rangs[i]加入到临时数组中；2.如果存在交集（包括包含/被包含），这个时候，对范围进行拆分,那部分依然包含的范围加入到临时数组中，如果是包含的情况情况，要把两边的范围加入，如果是部分交集，只需把原范围不相交的一侧加入。在编码的时候，通过两个if处理了交集的情况。对于查询，就是遍历范围，判断边界，返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;int,int&gt;&gt; rangs;</span><br><span class="line"></span><br><span class="line">   void addRange(int left, int right) &#123;</span><br><span class="line">       vector&lt;pair&lt;int, int&gt;&gt; res;</span><br><span class="line">       int size = (int)rangs.size();</span><br><span class="line">       for(int i = 0; i &lt; size; i ++)&#123;</span><br><span class="line">          if(rangs[i].first &gt;= right || left &gt;= rangs[i].second)&#123;</span><br><span class="line">               //不包含，且没有交集</span><br><span class="line">               res.push_back(rangs[i]);</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               //包含或存在交集</span><br><span class="line">               left = min(left, rangs[i].first);</span><br><span class="line">               right = max(right, rangs[i].second);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       res.insert(res.begin(), &#123;left,right&#125;);</span><br><span class="line">       rangs = res;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   bool queryRange(int left, int right) &#123;</span><br><span class="line">       int size = (int)rangs.size();</span><br><span class="line">       for(int i = 0; i &lt; size; i ++)&#123;</span><br><span class="line">           if(rangs[i].first &lt;= left &amp;&amp; rangs[i].second &gt;= right)&#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   void removeRange(int left, int right) &#123;</span><br><span class="line">      vector&lt;pair&lt;int, int&gt;&gt; res;</span><br><span class="line">      int size = (int)rangs.size();</span><br><span class="line">      for(int i = 0; i &lt; size; i ++)&#123;</span><br><span class="line">          if(rangs[i].first &gt; right || left &gt; rangs[i].second)&#123;</span><br><span class="line">              //不包含 并且不连续(如果 &gt;= || &gt;=的话，对与相连的区间就少了合成的机会。某些情况下会导致边界的重复，如果发生，那么会导致删除函数的不准确)</span><br><span class="line">              res.push_back(rangs[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          else&#123;</span><br><span class="line">              //存在交集 或者 包含</span><br><span class="line">              if (rangs[i].first &lt; left) &#123;</span><br><span class="line">                  res.push_back(&#123;rangs[i].first,left&#125;);</span><br><span class="line">              &#125;</span><br><span class="line">              if (rangs[i].second &gt; right)</span><br><span class="line">              &#123;</span><br><span class="line">                  res.push_back(&#123;right,rangs[i].second&#125;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      rangs = res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>后记：这种方法没太大的技巧。情况较多和边界处理，是这道题的难点所在。</p>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt; m;</span><br><span class="line">    /*</span><br><span class="line">     查找所在的范围。</span><br><span class="line">     1.add. 如果不存在，直接返回原范围。否则，返回需要更新的范围</span><br><span class="line">     2.remove 如果不存在，直接返回原范围。否则，返回交集的范围。</span><br><span class="line">     */</span><br><span class="line">    pair&lt;int, int&gt; find(int left,int right)&#123;</span><br><span class="line">        auto l = m.upper_bound(left);</span><br><span class="line">        auto r = m.upper_bound(right);</span><br><span class="line">        if (l != m.begin() &amp;&amp; (--l)-&gt;second &lt; left) &#123;</span><br><span class="line">            //不存在交集</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l==r) &#123;</span><br><span class="line">            return &#123;left,right&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = min(left,l-&gt;first);</span><br><span class="line">        int j = max(right,(--r)-&gt;second);</span><br><span class="line">        m.erase(l, ++r);</span><br><span class="line">        return &#123;i,j&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   void addRange(int left, int right) &#123;</span><br><span class="line">       pair&lt;int, int&gt; p = find(left,right);</span><br><span class="line">       //插入或调整范围</span><br><span class="line">       m[p.first] = p.second;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   bool queryRange(int left, int right) &#123;</span><br><span class="line">    //获取第一个大于left的pair,如果不是第一个，那么必然存在firs&lt;left的pair，如果这个pair的second大于等于right,那么返回true。</span><br><span class="line">       auto p = m.upper_bound(left);</span><br><span class="line">       return p != m.begin() &amp;&amp; (--p)-&gt;second &gt;= right;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   void removeRange(int left, int right) &#123;</span><br><span class="line">       pair&lt;int, int&gt; p = find(left,right);</span><br><span class="line">       //去除，[left,right)。更新范围，要保留左侧或右侧的相交的部分。</span><br><span class="line">       if(p.first &lt; left) m[p.first] = left;</span><br><span class="line">       if(p.second &gt; right) m[right] = p.second;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>后记：使用map这样的有序的结构，从而使用二分提高查找效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-11-4leetcode719. 找出第 k 小的距离对.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-11-4leetcode719. 找出第 k 小的距离对.html" itemprop="url">719. 找出第 k 小的距离对</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-04T00:00:00+08:00">
                2019-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-11-4leetcode719. 找出第 k 小的距离对.html" class="leancloud_visitors" data-flag-title="719. 找出第 k 小的距离对">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  527
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums = [1,3,1]</span><br><span class="line">k = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">所有数对如下：</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。</span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line">2 &lt;= len(nums) &lt;= 10000.</span><br><span class="line">0 &lt;= nums[i] &lt; 1000000.</span><br><span class="line">1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2.</span><br></pre></td></tr></table></figure>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>非常规的思路。如果对数组排序后，可以得出绝对值的区间范围。这是一个有序的区间范围,对于有序的范围，就可以考虑二分法去缩小范围。设定一个目标值，然后根据目标值在子函数中查找符合题目的条件，本题在子函数中计算小于等于目标值的绝对值个数，以作为二分的判断依据和获取答案的第K个最小距离。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int smallOrEquarK(vector&lt;int&gt;&amp; nums,long mid)&#123;</span><br><span class="line">    int res  = 0;</span><br><span class="line">    for (int right = 0; right &lt; nums.size(); right ++) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        ///滑动窗口，计算个数</span><br><span class="line">        while (nums[right] - nums[left] &gt; mid) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += right - left;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int smallestDistancePair(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    long left = 0;</span><br><span class="line">    long right = nums[nums.size() - 1] - nums[0];</span><br><span class="line">    while (left&lt; right) &#123;</span><br><span class="line">        long  mid = left + (right - left)/2;</span><br><span class="line">        int count = smallOrEquarK(nums,mid);</span><br><span class="line">        if(count &gt;= k)&#123;</span><br><span class="line">        ///如果大于等于mid,那么有可能mid是题解，所以right = mid,作为最新的右边界。</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        //如果小于，那边mid一定不是题解，所以left = mid + 1,作为左边界。</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记：<br>如果不是熟悉二分法的解题特征，应该比较难想到这种方法吧。这不是一种正向思路的常规解法。包括子函数中使用的滑动窗口，都是优化的技巧。另外二分的，while的条件，边界的重新赋值都是有所依据的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-11-3leetcode778水位上升的泳池中游泳本.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-11-3leetcode778水位上升的泳池中游泳本.html" itemprop="url">778. 水位上升的泳池中游泳</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-03T00:00:00+08:00">
                2019-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-11-3leetcode778水位上升的泳池中游泳本.html" class="leancloud_visitors" data-flag-title="778. 水位上升的泳池中游泳">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  773
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。</span><br><span class="line"></span><br><span class="line">现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</span><br><span class="line"></span><br><span class="line">你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [[0,2],[1,3]]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">时间为0时，你位于坐标方格的位置为 (0, 0)。</span><br><span class="line">此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。</span><br><span class="line"></span><br><span class="line">等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置</span><br></pre></td></tr></table></figure>
<h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>解读问题可知，要求的是能到达右下角的所有路径的每条路径的最大值，这个最大值集合的最小值。目标值是一个已知的范围，[格子中的最小值，格子中的最大值]。那么可以通过二分在目标区间查找目标值。根据目标值值，进行dfs或bfs来获取是否存在此路径来调整二分区间，逼近目标值。</p>
<p>后记：已知有限区间，不妨考虑下二分是否可行，关键字（有限区间、有序）。dfs一般涉及到递归,可以使用栈来实现。而bfs，需要队列来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int t,vector&lt;vector&lt;int&gt;&gt;&amp; grid,int i , int j ,vector&lt;vector&lt;bool&gt;&gt; &amp;visit)&#123;</span><br><span class="line">    long size = grid.size();</span><br><span class="line">    //超出范围，或者不符合条件，或者已经访问。返回。</span><br><span class="line">    if(i &lt; 0</span><br><span class="line">       ||i &gt; size - 1</span><br><span class="line">       ||j &lt; 0</span><br><span class="line">       ||j &gt; size - 1</span><br><span class="line">       ||grid[i][j] &gt; t</span><br><span class="line">       ||visit[i][j])&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[i][j] = true;</span><br><span class="line">    dfs(t, grid, i + 1, j, visit);</span><br><span class="line">    dfs(t, grid, i, j + 1, visit);</span><br><span class="line">    dfs(t, grid, i - 1, j, visit);</span><br><span class="line">    dfs(t, grid, i, j - 1, visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int swimInWater(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = 0;</span><br><span class="line">    //left,right分别获取方块中最小和最大的水的深度。</span><br><span class="line">    for (int r = 0; r &lt; grid.size(); ++r) &#123;</span><br><span class="line">        for (int c = 0; c &lt; grid.size(); ++c) &#123;</span><br><span class="line">            right = max(right, grid[r][c]);</span><br><span class="line">            left = min(left, grid[r][c]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    long size = grid.size();</span><br><span class="line">    int res = right;</span><br><span class="line">    //此条件为什么是&lt;=。 因为是查找点，而非查找区间</span><br><span class="line">    while (left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left)/2;</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; visit(size,vector&lt;bool&gt;(size,false));</span><br><span class="line">        dfs(mid, grid, 0, 0, visit);</span><br><span class="line">        if(visit[size-1][size-1])&#123;</span><br><span class="line">            res = mid;</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-10-31leetcode658找到 K 个最接近的元素.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-10-31leetcode658找到 K 个最接近的元素.html" itemprop="url">658. 找到 K 个最接近的元素</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-31T00:00:00+08:00">
                2019-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-10-31leetcode658找到 K 个最接近的元素.html" class="leancloud_visitors" data-flag-title="658. 找到 K 个最接近的元素">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  853
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5], k=4, x=3<br>输出: [1,2,3,4]</p>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>找到k个最接近的元素，实际上是返回原数组的一个子数组。那么可以通过两头向中间获取原数组的元素，然后跟x对比，舍弃差值较大的。直到舍弃size - k 个元素为止。然后通过一个数组返回这些帅选过后的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123;</span><br><span class="line">    vector&lt;int&gt; res(k,0);</span><br><span class="line">    int len = arr.size();</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = len - 1;</span><br><span class="line">    while(len &gt; k)&#123;</span><br><span class="line">        if(abs(arr[left] - x) &gt; abs(arr[right] - x))&#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        len --;</span><br><span class="line">    &#125;</span><br><span class="line">    ///新数值index从0开始</span><br><span class="line">    int index = 0;</span><br><span class="line">    for(int i = left; i &lt;= right; i ++)&#123;</span><br><span class="line">        res[index++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h5><p>1.把问题转化为查找子数组。确定了这一点，然后想到解法一的思路。分析题目，对信息进行有效的解读，非常有利于思路的推进，或者找到新的思路。例如此题转化为查找子数组。</p>
<h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>采用二分法，查找最合适的子数组的起始坐标。二分开始的范围为(0,size - k),保证右边只至少存在k个元素。然后二分，获取arr[mid] - x,arr[mid + k ] -x 的值来比较，判断arr[mid]是否被舍弃，如果舍弃那么 left = mid +1,反之right = mid.最后达到临界条件left = right。然后获取 left .. left + k(不包含)下标的元素集合返回。</p>
<p>比较难理解的点分析：<br>当abs(arr[mid] - x) &gt; abs(arr[mid + k] - x)时，舍弃mid这个点,start = mid + 1，这个很好理解。<br>但当abs(arr[mid] - x) &gt;= abs(arr[mid + k] - x)是，end = mid，这个就不太好理解了。根据对比条件可得，要舍弃[mid+k]这个点。那么就算end作为start，那么返回的区间就是[mid, mid + k -1]。从个角度来看，这个二分的过程，实际上是确定start的过程，由始至终目标start都在[start,end]这个区间中，然后不断二分，逼近最合适的start。这样好像就理解了这个解法的关键点了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123;</span><br><span class="line">    vector&lt;int&gt; res(k,0);</span><br><span class="line">    int start = 0;</span><br><span class="line">     //end的初始值，设定二分开始区间为(0,size -k),所以下面用到mid + k 是不会越界的;</span><br><span class="line">    int end = arr.size() - k;</span><br><span class="line">    int mid;</span><br><span class="line">    while (start &lt; end) &#123;</span><br><span class="line">        mid = start + (end - start)/2;</span><br><span class="line">        if(abs(arr[mid] - x) &gt; abs(arr[mid + k] - x))&#123;</span><br><span class="line">        ///这里是mid这个点已经不符合要求，舍弃，调整start</span><br><span class="line">            start = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">        ///这是是</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int index = 0;</span><br><span class="line">    for (int i = start; i &lt; start + k; i ++) &#123;</span><br><span class="line">        res[index++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记：二分法并不是想象中的那么简单。某些场景下并不是那么好理解。就如此题的，目的是获取目标起始坐标，二分的区间也是起始坐标所在的区间。而比较的条件是能确定区间移动方向的两个边界值的比较。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-07-20iOS  证书校验的几种嵌入方式，公钥证书pem的读取.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-07-20iOS  证书校验的几种嵌入方式，公钥证书pem的读取.html" itemprop="url">iOS  证书校验的几种嵌入方式，公钥证书pem的读取</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T00:00:00+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-07-20iOS  证书校验的几种嵌入方式，公钥证书pem的读取.html" class="leancloud_visitors" data-flag-title="iOS  证书校验的几种嵌入方式，公钥证书pem的读取">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  654
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="嵌入的几种方式"><a href="#嵌入的几种方式" class="headerlink" title="嵌入的几种方式"></a>嵌入的几种方式</h4><p>使用公有协议https进行网络传输，为了避免数据被抓包，需要实现客户端的证书校验功能。而证书校验可能存在几种实现的方式。分别如下：<br>A. 直接把客户端证书cer,嵌入到bundle中。<br>B. 提取客户端证书的公钥，生成pem格式文件，嵌入到bundle中。<br>C. 把cer证书pem格式的文本硬编码到代码中。<br>D. 把pem格式公钥硬编码到代码中。</p>
<h4 id="差别分析"><a href="#差别分析" class="headerlink" title="差别分析"></a>差别分析</h4><p>实际上，以上的实现方式都能实现证书校验的功能，只是对应的证书数据解析哪一步的代码处理有点差异。让我感到疑惑的是，为什么会存在这几种方式，特别是A和B。</p>
<p>使用B而不使用A的原因猜测：</p>
<ol>
<li>开发团队可能不愿意泄漏过多的证书信息，只是为了实现功能必要的嵌入公钥信息。</li>
<li>证书信息不常驻内存，存在频繁读取的场景，此时考虑效率，只使用必要的公钥信息。</li>
</ol>
<p>而C,D与A，B没有多大区别，主要是转成了base64硬编码到代码中。从安全性的角度来说，可能比直接把文件嵌入安全一点。文件直接砸壳就能拿到，很直接。而硬编码需要分析二进制，并且还要在一堆字符串查找，不那么直接。</p>
<h4 id="公钥证书pem的读取"><a href="#公钥证书pem的读取" class="headerlink" title="公钥证书pem的读取"></a>公钥证书pem的读取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 从公钥证书文件中获取到公钥的SecKeyRef指针。 Base64String-&gt;NSData</span><br><span class="line">+ (id)publicSecKeyFromKeyBits:(NSData *)givenData &#123;</span><br><span class="line">    NSMutableDictionary *options = [NSMutableDictionary dictionary];</span><br><span class="line">    options[(__bridge id)kSecAttrKeyType] = (__bridge id) kSecAttrKeyTypeRSA;</span><br><span class="line">    options[(__bridge id)kSecAttrKeyClass] = (__bridge id) kSecAttrKeyClassPublic;</span><br><span class="line"></span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    CFErrorRef ee = (__bridge CFErrorRef)error;</span><br><span class="line">    ///但这个方法在iOS10才支持。</span><br><span class="line">    id ret = (__bridge_transfer id)SecKeyCreateWithData((__bridge CFDataRef)givenData, (__bridge CFDictionaryRef)options, &amp;ee);</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法存在一个比较明显的缺点，只支持iOS10及其以上。我看到一些嵌入pem格式的公钥证书的app是支持到8.0的，但没能找到能支持低版本的生成SecKeyRef的方法，也许其作用并不是用来做证书校验的。</p>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>在后台不能提供客户端证书的情况下，可以在浏览器使用对应的域名下得网址进行请求，把证书拿到。macOS可以这么操作：1.请求相应的地址，2点击地址栏左边的小锁头，3点击证书，4出现证书详情的时候，点击拖动证书图标保存到本地。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/icon.jpg"
                alt="zengbailiang" />
            
              <p class="site-author-name" itemprop="name">zengbailiang</p>
              <p class="site-description motion-element" itemprop="description">知行合一</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a rel="external nofollow" href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zmubai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zengbailiang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">54.5k</span>
  
</div>


  <div class="powered-by">由 <a rel="external nofollow" class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("7VSaCuGNNUXrDp0aOK65w7PQ-gzGzoHsz", "l1D8p6eriduqG6aqx1f8H7ia");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
