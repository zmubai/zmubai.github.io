<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta name="google-site-verification" content="xdxP4Om7Pxp3OMC73kRMv2emRoA91RXOEPaKMivB_zg" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="liang&#39;s blog">
<meta property="og:url" content="https://zengbailiang.cn/index.html">
<meta property="og:site_name" content="liang&#39;s blog">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liang&#39;s blog">
<meta name="twitter:description" content="知行合一">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zengbailiang.cn/"/>





  <title> Hexo, NexT - liang's blog知行合一 </title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">liang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/1123最深叶节点的最近公共祖先191115.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/1123最深叶节点的最近公共祖先191115.html" itemprop="url">leetcode 1123 最深叶节点的最近公共祖先</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-15T00:00:00+08:00">
                2019-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/1123最深叶节点的最近公共祖先191115.html" class="leancloud_visitors" data-flag-title="leetcode 1123 最深叶节点的最近公共祖先">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  669
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> 给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。</span><br><span class="line"></span><br><span class="line">回想一下：</span><br><span class="line"></span><br><span class="line">叶节点 是二叉树中没有子节点的节点</span><br><span class="line">树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1</span><br><span class="line">如果我们假定 A 是一组节点 S 的 最近公共祖先，&lt;font color=&quot;#c7254e&quot; face=&quot;Menlo, Monaco, Consolas, Courier New, monospace&quot;&gt;S&lt;/font&gt; 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：[1,2,3]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：root = [1,2,3,4]</span><br><span class="line">输出：[4]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：root = [1,2,3,4,5]</span><br><span class="line">输出：[2,4,5]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">给你的树中将有 1 到 1000 个节点。</span><br><span class="line">树中每个节点的值都在 1 到 1000 之间。</span><br></pre></td></tr></table></figure>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>最近公共祖先，是指，其下面的节点全部都是他的孩子。那么对应题目,有一种情况比较刺手，当存在不止一个分支的深度都等于树的最大深度，此时，就需要返回他们的共同祖先，而一般使用递归实现的时候，这个好像不好处理，开始这里卡了好久。正如代码所示，使用两个int指针记录分支的深度，当子递归返回时，对比两变量决定是否返回当前的root。</p>
<p>其他情况：1.root为空，返回root。2.存在一个分支的最深叶子，2.1叶子无兄弟节点，返回本身，2.2存在兄弟节点，返回其父节点。<br>3.存在多分支最深叶子，就需要根据深度指针对比，判断和返回。（这个上面单独已经说明）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">     int val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode*  findDeepComm(TreeNode* root,int *deep)&#123;</span><br><span class="line">    if (root != nullptr) &#123;</span><br><span class="line">        *deep += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int *dL = (int*)malloc(sizeof(int));</span><br><span class="line">    int *dR = (int*)malloc(sizeof(int));</span><br><span class="line">    *dL = *deep;</span><br><span class="line">    *dR = *deep;</span><br><span class="line">    TreeNode *nl = root;</span><br><span class="line">    if(root-&gt;left)&#123;</span><br><span class="line">        nl = findDeepComm(root-&gt;left, dL);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *nr = root;</span><br><span class="line">    if (root-&gt;right) &#123;</span><br><span class="line">        nr = findDeepComm(root-&gt;right, dR);</span><br><span class="line">    &#125;</span><br><span class="line">    if (*dL == *dR) &#123;</span><br><span class="line">        *deep = *dL;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        *deep = *dL &gt; *dR ? *dL:*dR;</span><br><span class="line">        return *dL &gt; *dR ? nl : nr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* lcaDeepestLeaves(TreeNode* root) &#123;</span><br><span class="line">    int *deep = (int*)malloc(sizeof(int));;</span><br><span class="line">    *deep = 0;</span><br><span class="line">    return findDeepComm(root,deep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记：其实，根据题目给的例子，把我搞懵了。审题很重要，另外就是对递归的理解，小技巧，深度指针跟踪，递归中常用的小技巧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/887. 鸡蛋掉落 191112.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/887. 鸡蛋掉落 191112.html" itemprop="url">leetcode 887. 鸡蛋掉落</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-12T00:00:00+08:00">
                2019-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/887. 鸡蛋掉落 191112.html" class="leancloud_visitors" data-flag-title="leetcode 887. 鸡蛋掉落">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,267
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">887. 鸡蛋掉落</span><br><span class="line">你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</span><br><span class="line"></span><br><span class="line">每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</span><br><span class="line"></span><br><span class="line">你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</span><br><span class="line"></span><br><span class="line">每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</span><br><span class="line"></span><br><span class="line">你的目标是确切地知道 F 的值是多少。</span><br><span class="line"></span><br><span class="line">无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：K = 1, N = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。</span><br><span class="line">否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。</span><br><span class="line">如果它没碎，那么我们肯定知道 F = 2 。</span><br><span class="line">因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</span><br></pre></td></tr></table></figure>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>动态规划。<br>dp[i][j]表示i个鸡蛋 ,j层需要的次数。<br>当某个时刻楼层为x,仍下鸡蛋，会出现两种情况<br>1.鸡蛋碎了，那么调整范围dp[i-1][x-1]。<br>2.鸡蛋没碎，那么调整范围dp[i][j-x]。</p>
<p>那么dp方程为:<br>dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x]))(+1是因为计算上这本次扔鸡蛋)<br>主要步骤：</p>
<ol>
<li>dp[i][j] 赋值保险值。例如100层，保险值就是100。等于j。</li>
<li>计算dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x]))。</li>
<li>返回dp[K][N]。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Time Limit Exceeded</span><br><span class="line">int superEggDrop(int K, int N) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(K + 1, vector&lt;int&gt;(N + 1));</span><br><span class="line">    for (int i = 1; i &lt;= N; i ++) &#123;</span><br><span class="line">        dp[1][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    //2 - K 个鸡蛋</span><br><span class="line">    for (int i = 2;i &lt;= K; ++i)&#123;</span><br><span class="line">        // 1 - N 层</span><br><span class="line">        for (int j = 1; j &lt;= N; ++j) &#123;</span><br><span class="line">            //赋值最大次数</span><br><span class="line">            dp[i][j] = j;</span><br><span class="line">            //鸡蛋有可能在任何一层砸碎</span><br><span class="line">            for (int x = 1; x &lt; j; ++x) &#123;</span><br><span class="line">                dp[i][j] = min(dp[i][j], 1 + max(dp[i][j - x], dp[i -1][x -1]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[K][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法会超时，需要优化。下面采取二分优化。</p>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int superEggDrop(int K, int N) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp (K+1,vector&lt;int&gt;(N+1));</span><br><span class="line">    //赋基础值</span><br><span class="line">    for (int i = 1 ; i &lt;= N; ++i) &#123;</span><br><span class="line">        dp[1][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    //2 - K egg</span><br><span class="line">    for (int i = 2; i &lt;= K; ++i) &#123;</span><br><span class="line">        // 1 - N floor</span><br><span class="line">        for (int j = 1; j &lt;= N; ++j) &#123;</span><br><span class="line">            //赋保险值</span><br><span class="line">            dp[i][j] = j;</span><br><span class="line">            int left = 1;</span><br><span class="line">            int right = j;</span><br><span class="line">            //二分查找临界点</span><br><span class="line">            while (left&lt;right) &#123;</span><br><span class="line">                int mid = left + (right - left)/2;</span><br><span class="line">                if (dp[i - 1][mid -1] &lt; dp[i][j - mid]) &#123;</span><br><span class="line">                    //mid 过小 向右偏移</span><br><span class="line">                    left = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    //mid 过大，向左偏移</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ///为什么最后right是临界点呢（ring保留mid,不让某些值缺失，但临界值为什么不能发生在left。。。；根据判断条件left&lt;right。可以理解为left一直增大，直到=&gt;right，那么退出循环，此时right就是临界值。这个过程如何一定保证right为临界值！！！），这里有点没想通。</span><br><span class="line">            dp[i][j] = min(dp[i][j], 1 + max(dp[i-1][right-1],dp[i][j-right]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[K][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>再次优化，理论上楼层越多临界点越大，so临界点是一致递增的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int superEggDrop(int K, int N) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp (K+1,vector&lt;int&gt;(N+1));</span><br><span class="line">    //赋基础值</span><br><span class="line">    for (int i = 1 ; i &lt;= N; ++i) &#123;</span><br><span class="line">        dp[1][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    //2 - K egg</span><br><span class="line">    for (int i = 2; i &lt;= K; ++i) &#123;</span><br><span class="line">        // 1 - N floor</span><br><span class="line">        int s = 1;</span><br><span class="line">        for (int j = 1; j &lt;= N; ++j) &#123;</span><br><span class="line">            //赋保险值</span><br><span class="line">            dp[i][j] = j;</span><br><span class="line">            //随着楼层的增加 s会变大。（使用s递增，比解法二的临界值好理解很多，且很容易确定准确性）</span><br><span class="line">            while (dp[i - 1][s -1] &lt; dp[i][j - s]) &#123;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = min(dp[i][j], 1 + max(dp[i-1][s-1],dp[i][j-s]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[K][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种类型的题目，求最值得问题，很可能用到动态规划。且随着变量的递增，后面的结果依赖于之前的过程。抽象出dp方程比较重要。<br>例如本题就比较难抽象，要完全理清题意，准确无误的抽象不容易：</p>
<p>dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x]))</p>
<ol>
<li>dp[i][j],i egg ;j floor</li>
<li>dp[i][j],保险值等于j</li>
<li>每次扔鸡蛋分两种情况，所以有max(dp[i-1][x-1],dp[i][j-x])，max是为了取最坏情况次数。加上当次扔鸡蛋， 所以有1 + max(dp[i-1][x-1],dp[i][j-x])</li>
<li>最终有dp[i][j] = min(dp[i][j],1 + max(dp[i-1][x-1],dp[i][j-x]))</li>
</ol>
<p>一般来说，有了初步的解题思路，再一步一步优化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/715. Range 模块191109.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/715. Range 模块191109.html" itemprop="url">leetcode 715. Range 模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-09T00:00:00+08:00">
                2019-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/715. Range 模块191109.html" class="leancloud_visitors" data-flag-title="leetcode 715. Range 模块">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,164
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">715. Range 模块</span><br><span class="line">Range 模块是跟踪数字范围的模块。你的任务是以一种有效的方式设计和实现以下接口。</span><br><span class="line"></span><br><span class="line">addRange(int left, int right) 添加半开区间 [left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 [left, right) 中尚未跟踪的任何数字到该区间中。</span><br><span class="line">queryRange(int left, int right) 只有在当前正在跟踪区间 [left, right) 中的每一个实数时，才返回 true。</span><br><span class="line">removeRange(int left, int right) 停止跟踪区间 [left, right) 中当前正在跟踪的每个实数。</span><br><span class="line"></span><br><span class="line">addRange(10, 20): null</span><br><span class="line">removeRange(14, 16): null</span><br><span class="line">queryRange(10, 14): true （区间 [10, 14) 中的每个数都正在被跟踪）</span><br><span class="line">queryRange(13, 15): false （未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）</span><br><span class="line">queryRange(16, 17): true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪）</span><br></pre></td></tr></table></figure>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>使用一个全局数组来存储已有的范围。对于添加，遍历数组，分两种情况判断，1.范围之间不存在交集，那么把rangs[i]加入到临时数组中；2.如果包含（被包含或包含）或者两者存在交集，那么更新left,right,值。重复该过程，直到遍历结束，此时把合成的left,right范围插入到临时数组中，赋值给全局数组，更新范围成功。对于删除，遍历数组，分三种情况判断，1.范围之间没有交集，那么把rangs[i]加入到临时数组中；2.如果存在交集（包括包含/被包含），这个时候，对范围进行拆分,那部分依然包含的范围加入到临时数组中，如果是包含的情况情况，要把两边的范围加入，如果是部分交集，只需把原范围不相交的一侧加入。在编码的时候，通过两个if处理了交集的情况。对于查询，就是遍历范围，判断边界，返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;int,int&gt;&gt; rangs;</span><br><span class="line"></span><br><span class="line">   void addRange(int left, int right) &#123;</span><br><span class="line">       vector&lt;pair&lt;int, int&gt;&gt; res;</span><br><span class="line">       int size = (int)rangs.size();</span><br><span class="line">       for(int i = 0; i &lt; size; i ++)&#123;</span><br><span class="line">          if(rangs[i].first &gt;= right || left &gt;= rangs[i].second)&#123;</span><br><span class="line">               //不包含，且没有交集</span><br><span class="line">               res.push_back(rangs[i]);</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               //包含或存在交集</span><br><span class="line">               left = min(left, rangs[i].first);</span><br><span class="line">               right = max(right, rangs[i].second);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       res.insert(res.begin(), &#123;left,right&#125;);</span><br><span class="line">       rangs = res;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   bool queryRange(int left, int right) &#123;</span><br><span class="line">       int size = (int)rangs.size();</span><br><span class="line">       for(int i = 0; i &lt; size; i ++)&#123;</span><br><span class="line">           if(rangs[i].first &lt;= left &amp;&amp; rangs[i].second &gt;= right)&#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   void removeRange(int left, int right) &#123;</span><br><span class="line">      vector&lt;pair&lt;int, int&gt;&gt; res;</span><br><span class="line">      int size = (int)rangs.size();</span><br><span class="line">      for(int i = 0; i &lt; size; i ++)&#123;</span><br><span class="line">          if(rangs[i].first &gt; right || left &gt; rangs[i].second)&#123;</span><br><span class="line">              //不包含 并且不连续(如果 &gt;= || &gt;=的话，对与相连的区间就少了合成的机会。某些情况下会导致边界的重复，如果发生，那么会导致删除函数的不准确)</span><br><span class="line">              res.push_back(rangs[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          else&#123;</span><br><span class="line">              //存在交集 或者 包含</span><br><span class="line">              if (rangs[i].first &lt; left) &#123;</span><br><span class="line">                  res.push_back(&#123;rangs[i].first,left&#125;);</span><br><span class="line">              &#125;</span><br><span class="line">              if (rangs[i].second &gt; right)</span><br><span class="line">              &#123;</span><br><span class="line">                  res.push_back(&#123;right,rangs[i].second&#125;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      rangs = res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>后记：这种方法没太大的技巧。情况较多和边界处理，是这道题的难点所在。</p>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二:"></a>解法二:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt; m;</span><br><span class="line">    /*</span><br><span class="line">     查找所在的范围。</span><br><span class="line">     1.add. 如果不存在，直接返回原范围。否则，返回需要更新的范围</span><br><span class="line">     2.remove 如果不存在，直接返回原范围。否则，返回交集的范围。</span><br><span class="line">     */</span><br><span class="line">    pair&lt;int, int&gt; find(int left,int right)&#123;</span><br><span class="line">        auto l = m.upper_bound(left);</span><br><span class="line">        auto r = m.upper_bound(right);</span><br><span class="line">        if (l != m.begin() &amp;&amp; (--l)-&gt;second &lt; left) &#123;</span><br><span class="line">            //不存在交集</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l==r) &#123;</span><br><span class="line">            return &#123;left,right&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = min(left,l-&gt;first);</span><br><span class="line">        int j = max(right,(--r)-&gt;second);</span><br><span class="line">        m.erase(l, ++r);</span><br><span class="line">        return &#123;i,j&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   void addRange(int left, int right) &#123;</span><br><span class="line">       pair&lt;int, int&gt; p = find(left,right);</span><br><span class="line">       //插入或调整范围</span><br><span class="line">       m[p.first] = p.second;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   bool queryRange(int left, int right) &#123;</span><br><span class="line">    //获取第一个大于left的pair,如果不是第一个，那么必然存在firs&lt;left的pair，如果这个pair的second大于等于right,那么返回true。</span><br><span class="line">       auto p = m.upper_bound(left);</span><br><span class="line">       return p != m.begin() &amp;&amp; (--p)-&gt;second &gt;= right;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   void removeRange(int left, int right) &#123;</span><br><span class="line">       pair&lt;int, int&gt; p = find(left,right);</span><br><span class="line">       //去除，[left,right)。更新范围，要保留左侧或右侧的相交的部分。</span><br><span class="line">       if(p.first &lt; left) m[p.first] = left;</span><br><span class="line">       if(p.second &gt; right) m[right] = p.second;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>后记：使用map这样的有序的结构，从而使用二分提高查找效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-11-4leetcode719. 找出第 k 小的距离对.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-11-4leetcode719. 找出第 k 小的距离对.html" itemprop="url">719. 找出第 k 小的距离对</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-04T00:00:00+08:00">
                2019-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-11-4leetcode719. 找出第 k 小的距离对.html" class="leancloud_visitors" data-flag-title="719. 找出第 k 小的距离对">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  527
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums = [1,3,1]</span><br><span class="line">k = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">所有数对如下：</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。</span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line">2 &lt;= len(nums) &lt;= 10000.</span><br><span class="line">0 &lt;= nums[i] &lt; 1000000.</span><br><span class="line">1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2.</span><br></pre></td></tr></table></figure>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>非常规的思路。如果对数组排序后，可以得出绝对值的区间范围。这是一个有序的区间范围,对于有序的范围，就可以考虑二分法去缩小范围。设定一个目标值，然后根据目标值在子函数中查找符合题目的条件，本题在子函数中计算小于等于目标值的绝对值个数，以作为二分的判断依据和获取答案的第K个最小距离。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int smallOrEquarK(vector&lt;int&gt;&amp; nums,long mid)&#123;</span><br><span class="line">    int res  = 0;</span><br><span class="line">    for (int right = 0; right &lt; nums.size(); right ++) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        ///滑动窗口，计算个数</span><br><span class="line">        while (nums[right] - nums[left] &gt; mid) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += right - left;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int smallestDistancePair(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    long left = 0;</span><br><span class="line">    long right = nums[nums.size() - 1] - nums[0];</span><br><span class="line">    while (left&lt; right) &#123;</span><br><span class="line">        long  mid = left + (right - left)/2;</span><br><span class="line">        int count = smallOrEquarK(nums,mid);</span><br><span class="line">        if(count &gt;= k)&#123;</span><br><span class="line">        ///如果大于等于mid,那么有可能mid是题解，所以right = mid,作为最新的右边界。</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">        //如果小于，那边mid一定不是题解，所以left = mid + 1,作为左边界。</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记：<br>如果不是熟悉二分法的解题特征，应该比较难想到这种方法吧。这不是一种正向思路的常规解法。包括子函数中使用的滑动窗口，都是优化的技巧。另外二分的，while的条件，边界的重新赋值都是有所依据的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-11-3leetcode778水位上升的泳池中游泳本.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-11-3leetcode778水位上升的泳池中游泳本.html" itemprop="url">778. 水位上升的泳池中游泳</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-03T00:00:00+08:00">
                2019-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-11-3leetcode778水位上升的泳池中游泳本.html" class="leancloud_visitors" data-flag-title="778. 水位上升的泳池中游泳">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  773
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。</span><br><span class="line"></span><br><span class="line">现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</span><br><span class="line"></span><br><span class="line">你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [[0,2],[1,3]]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">时间为0时，你位于坐标方格的位置为 (0, 0)。</span><br><span class="line">此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。</span><br><span class="line"></span><br><span class="line">等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置</span><br></pre></td></tr></table></figure>
<h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>解读问题可知，要求的是能到达右下角的所有路径的每条路径的最大值，这个最大值集合的最小值。目标值是一个已知的范围，[格子中的最小值，格子中的最大值]。那么可以通过二分在目标区间查找目标值。根据目标值值，进行dfs或bfs来获取是否存在此路径来调整二分区间，逼近目标值。</p>
<p>后记：已知有限区间，不妨考虑下二分是否可行，关键字（有限区间、有序）。dfs一般涉及到递归,可以使用栈来实现。而bfs，需要队列来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int t,vector&lt;vector&lt;int&gt;&gt;&amp; grid,int i , int j ,vector&lt;vector&lt;bool&gt;&gt; &amp;visit)&#123;</span><br><span class="line">    long size = grid.size();</span><br><span class="line">    //超出范围，或者不符合条件，或者已经访问。返回。</span><br><span class="line">    if(i &lt; 0</span><br><span class="line">       ||i &gt; size - 1</span><br><span class="line">       ||j &lt; 0</span><br><span class="line">       ||j &gt; size - 1</span><br><span class="line">       ||grid[i][j] &gt; t</span><br><span class="line">       ||visit[i][j])&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[i][j] = true;</span><br><span class="line">    dfs(t, grid, i + 1, j, visit);</span><br><span class="line">    dfs(t, grid, i, j + 1, visit);</span><br><span class="line">    dfs(t, grid, i - 1, j, visit);</span><br><span class="line">    dfs(t, grid, i, j - 1, visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int swimInWater(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = 0;</span><br><span class="line">    //left,right分别获取方块中最小和最大的水的深度。</span><br><span class="line">    for (int r = 0; r &lt; grid.size(); ++r) &#123;</span><br><span class="line">        for (int c = 0; c &lt; grid.size(); ++c) &#123;</span><br><span class="line">            right = max(right, grid[r][c]);</span><br><span class="line">            left = min(left, grid[r][c]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    long size = grid.size();</span><br><span class="line">    int res = right;</span><br><span class="line">    //此条件为什么是&lt;=。 因为是查找点，而非查找区间</span><br><span class="line">    while (left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left)/2;</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; visit(size,vector&lt;bool&gt;(size,false));</span><br><span class="line">        dfs(mid, grid, 0, 0, visit);</span><br><span class="line">        if(visit[size-1][size-1])&#123;</span><br><span class="line">            res = mid;</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-10-31leetcode658找到 K 个最接近的元素.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-10-31leetcode658找到 K 个最接近的元素.html" itemprop="url">658. 找到 K 个最接近的元素</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-31T00:00:00+08:00">
                2019-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-10-31leetcode658找到 K 个最接近的元素.html" class="leancloud_visitors" data-flag-title="658. 找到 K 个最接近的元素">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  853
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5], k=4, x=3<br>输出: [1,2,3,4]</p>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>找到k个最接近的元素，实际上是返回原数组的一个子数组。那么可以通过两头向中间获取原数组的元素，然后跟x对比，舍弃差值较大的。直到舍弃size - k 个元素为止。然后通过一个数组返回这些帅选过后的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123;</span><br><span class="line">    vector&lt;int&gt; res(k,0);</span><br><span class="line">    int len = arr.size();</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = len - 1;</span><br><span class="line">    while(len &gt; k)&#123;</span><br><span class="line">        if(abs(arr[left] - x) &gt; abs(arr[right] - x))&#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            right --;</span><br><span class="line">        &#125;</span><br><span class="line">        len --;</span><br><span class="line">    &#125;</span><br><span class="line">    ///新数值index从0开始</span><br><span class="line">    int index = 0;</span><br><span class="line">    for(int i = left; i &lt;= right; i ++)&#123;</span><br><span class="line">        res[index++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h5><p>1.把问题转化为查找子数组。确定了这一点，然后想到解法一的思路。分析题目，对信息进行有效的解读，非常有利于思路的推进，或者找到新的思路。例如此题转化为查找子数组。</p>
<h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>采用二分法，查找最合适的子数组的起始坐标。二分开始的范围为(0,size - k),保证右边只至少存在k个元素。然后二分，获取arr[mid] - x,arr[mid + k ] -x 的值来比较，判断arr[mid]是否被舍弃，如果舍弃那么 left = mid +1,反之right = mid.最后达到临界条件left = right。然后获取 left .. left + k(不包含)下标的元素集合返回。</p>
<p>比较难理解的点分析：<br>当abs(arr[mid] - x) &gt; abs(arr[mid + k] - x)时，舍弃mid这个点,start = mid + 1，这个很好理解。<br>但当abs(arr[mid] - x) &gt;= abs(arr[mid + k] - x)是，end = mid，这个就不太好理解了。根据对比条件可得，要舍弃[mid+k]这个点。那么就算end作为start，那么返回的区间就是[mid, mid + k -1]。从个角度来看，这个二分的过程，实际上是确定start的过程，由始至终目标start都在[start,end]这个区间中，然后不断二分，逼近最合适的start。这样好像就理解了这个解法的关键点了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123;</span><br><span class="line">    vector&lt;int&gt; res(k,0);</span><br><span class="line">    int start = 0;</span><br><span class="line">     //end的初始值，设定二分开始区间为(0,size -k),所以下面用到mid + k 是不会越界的;</span><br><span class="line">    int end = arr.size() - k;</span><br><span class="line">    int mid;</span><br><span class="line">    while (start &lt; end) &#123;</span><br><span class="line">        mid = start + (end - start)/2;</span><br><span class="line">        if(abs(arr[mid] - x) &gt; abs(arr[mid + k] - x))&#123;</span><br><span class="line">        ///这里是mid这个点已经不符合要求，舍弃，调整start</span><br><span class="line">            start = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">        ///这是是</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int index = 0;</span><br><span class="line">    for (int i = start; i &lt; start + k; i ++) &#123;</span><br><span class="line">        res[index++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记：二分法并不是想象中的那么简单。某些场景下并不是那么好理解。就如此题的，目的是获取目标起始坐标，二分的区间也是起始坐标所在的区间。而比较的条件是能确定区间移动方向的两个边界值的比较。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-07-20iOS  证书校验的几种嵌入方式，公钥证书pem的读取.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-07-20iOS  证书校验的几种嵌入方式，公钥证书pem的读取.html" itemprop="url">iOS  证书校验的几种嵌入方式，公钥证书pem的读取</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T00:00:00+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-07-20iOS  证书校验的几种嵌入方式，公钥证书pem的读取.html" class="leancloud_visitors" data-flag-title="iOS  证书校验的几种嵌入方式，公钥证书pem的读取">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  654
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="嵌入的几种方式"><a href="#嵌入的几种方式" class="headerlink" title="嵌入的几种方式"></a>嵌入的几种方式</h4><p>使用公有协议https进行网络传输，为了避免数据被抓包，需要实现客户端的证书校验功能。而证书校验可能存在几种实现的方式。分别如下：<br>A. 直接把客户端证书cer,嵌入到bundle中。<br>B. 提取客户端证书的公钥，生成pem格式文件，嵌入到bundle中。<br>C. 把cer证书pem格式的文本硬编码到代码中。<br>D. 把pem格式公钥硬编码到代码中。</p>
<h4 id="差别分析"><a href="#差别分析" class="headerlink" title="差别分析"></a>差别分析</h4><p>实际上，以上的实现方式都能实现证书校验的功能，只是对应的证书数据解析哪一步的代码处理有点差异。让我感到疑惑的是，为什么会存在这几种方式，特别是A和B。</p>
<p>使用B而不使用A的原因猜测：</p>
<ol>
<li>开发团队可能不愿意泄漏过多的证书信息，只是为了实现功能必要的嵌入公钥信息。</li>
<li>证书信息不常驻内存，存在频繁读取的场景，此时考虑效率，只使用必要的公钥信息。</li>
</ol>
<p>而C,D与A，B没有多大区别，主要是转成了base64硬编码到代码中。从安全性的角度来说，可能比直接把文件嵌入安全一点。文件直接砸壳就能拿到，很直接。而硬编码需要分析二进制，并且还要在一堆字符串查找，不那么直接。</p>
<h4 id="公钥证书pem的读取"><a href="#公钥证书pem的读取" class="headerlink" title="公钥证书pem的读取"></a>公钥证书pem的读取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 从公钥证书文件中获取到公钥的SecKeyRef指针。 Base64String-&gt;NSData</span><br><span class="line">+ (id)publicSecKeyFromKeyBits:(NSData *)givenData &#123;</span><br><span class="line">    NSMutableDictionary *options = [NSMutableDictionary dictionary];</span><br><span class="line">    options[(__bridge id)kSecAttrKeyType] = (__bridge id) kSecAttrKeyTypeRSA;</span><br><span class="line">    options[(__bridge id)kSecAttrKeyClass] = (__bridge id) kSecAttrKeyClassPublic;</span><br><span class="line"></span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    CFErrorRef ee = (__bridge CFErrorRef)error;</span><br><span class="line">    ///但这个方法在iOS10才支持。</span><br><span class="line">    id ret = (__bridge_transfer id)SecKeyCreateWithData((__bridge CFDataRef)givenData, (__bridge CFDictionaryRef)options, &amp;ee);</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法存在一个比较明显的缺点，只支持iOS10及其以上。我看到一些嵌入pem格式的公钥证书的app是支持到8.0的，但没能找到能支持低版本的生成SecKeyRef的方法，也许其作用并不是用来做证书校验的。</p>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>在后台不能提供客户端证书的情况下，可以在浏览器使用对应的域名下得网址进行请求，把证书拿到。macOS可以这么操作：1.请求相应的地址，2点击地址栏左边的小锁头，3点击证书，4出现证书详情的时候，点击拖动证书图标保存到本地。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-07-17回了一趟学校.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-07-17回了一趟学校.html" itemprop="url">回了一趟校园</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-14T00:00:00+08:00">
                2019-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/记事/" itemprop="url" rel="index">
                    <span itemprop="name">记事</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-07-17回了一趟学校.html" class="leancloud_visitors" data-flag-title="回了一趟校园">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,313
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="回了一趟学校"><a href="#回了一趟学校" class="headerlink" title="回了一趟学校"></a>回了一趟学校</h3><p>大概是五月份的时候回了趟学校。再次回去还是比较感慨，想去的地方很多，但时间缺有限，就选了几个比较有回忆又比较便捷的地方去走走。也许是因为大学时代值得回忆的事情太多了，又或者是怀念作为学生的时候的那份心情和青春，总之很难说清。但每每想到这些，总会非常感叹，有些事情，有些年纪只能经历一次，心态会伴随着年纪而变化，又或者其他的一些原因，总之过去的那个特定的阶段特定的事情和那份特定的心情，是后面阶段无法再重新获取的。这确实是个比较无奈的事情，但这应该是合理的，人生就应该要有不同的阶段。</p>
<h5 id="13路车"><a href="#13路车" class="headerlink" title="13路车"></a>13路车</h5><p>有些事情还是没变，但变化总是在不断的发生。熟悉的13路车还在，还是要从东区走过20分钟的上山路才到尧山校区，我很享受在车上的感受，特别是坐窗旁的位置，吹着风，看着窗外的风景。但13路好像已经都变成了空调车，窗都没了。</p>
<h5 id="尧山"><a href="#尧山" class="headerlink" title="尧山"></a>尧山</h5><p>再次上尧山， 还是爬着上。记得大一第一次爬好像是中秋节节日，那时候很多人，而再爬的当天的人很少，感觉比较冷清，可能是时间的问题吧。山上也有了不少变化，山顶走向盘山公路的路变了，中间被围起来私用了。下山的时候和朋友一起走盘山公路下山，我同样很喜欢尧山的盘山公路，有很长的一段泊油路，干净美丽。这里还是会见到小年轻，小情侣骑着小电瓶，游盘山公路。</p>
<h5 id="尧山校区"><a href="#尧山校区" class="headerlink" title="尧山校区"></a>尧山校区</h5><p>傍晚回到了尧山校区，最让我震惊的是，食堂不允许使用现金了，其实早在第一天逛东区的时候，就发现这个坑爹的问题了，比较失望，无法再尝一遍食堂的味道，但同时发现了一个事情，因为学校的数字校园毕业了依然可以用，而且还能通过支付宝充值，我尝试充了一块钱，还真可以，但我没把我的校园卡带过来，还有我也不知道我的校园卡是否还能用了，也许我的校园卡还没消磁，还有就是学校系统确实还支持，这让留给了我一些待挖掘的事情，下次我可要验证下这个问题，真够有意思的。回到话题，晚上和朋友只能去商业街吃饭了，比较随性，但同样让我震惊的是，之前的商业街那么热闹，咋这么冷清。后面了解到，学校领导做了某些限制，更规范了，但这里面可能存在很多利益问题吧，反正没了之前的热闹了。遥想当年，哪里还是很热闹，买西瓜，买菠萝，买奶茶，哎，一去不复还。大学那几年，最开始有男生宿舍那边的阳光商业街，有靠近女生宿舍的职工宿舍楼下的店铺。特别是教职工楼下的奶茶店之类的店铺，那时候那些地方就有一些特殊的气氛，仿佛有一种爱情的荷尔蒙，是谈情说爱的地方，也是经常见到情侣的地方，当然更多的是虐狗的地方了。可悲的是，大学四年，我被虐足四年，还乐此不疲。<br>如今，阳光商业街没了，有了新商业街，现在新商业街又被搞萧条，职工楼下的小店也都禁止了营业，另外又在原阳光商业街哪里搞了一个新阳光商业街。对比这些吃吃喝喝的，仿佛当年更气氛更好，但他们没有经历过当年，所以就算真的如我所想的那样，对于他们来说最丰富有趣的依然是他们现在所感受到的。</p>
<h5 id="花江"><a href="#花江" class="headerlink" title="花江"></a>花江</h5><p>还有的是，以前可以在学校旁的花江划竹筏，烧烤，现在由于建了新的教职工园区，在花江上搭了座桥，导致不能划竹筏了。那些年满是笑语的地方没了。另外那些烧烤场地，也无法烧烤了，看到这样，有点说不出味道。也许因为这些没有了，会失去一些趣味吧。不可否认可能是因为现在的娱乐方式变得跟以前不太一样了，才导致这些变化，但具体怎么样，就不太清楚了，毕竟现在已经是00后的大学时代了。最后，最后，让我不得不吐槽的是，学习的男女比例好像更均衡了，情侣比例好像更高了，虽然这是好事啊，但这让我失去了一种熟悉感。</p>
<p><img src="/personImg/guet1.jpeg" alt="guet1.jpeg"></p>
<p>这里承载了一生仅有的一次大学时光，也是我人生中的一段美好时光，怀念、感恩。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-07-14本地加密方案.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-07-14本地加密方案.html" itemprop="url">iOS 本地数据安全存储方案探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-14T00:00:00+08:00">
                2019-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-07-14本地加密方案.html" class="leancloud_visitors" data-flag-title="iOS 本地数据安全存储方案探索">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,063
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>一般app都支持本地记录登录状态，并支持离线的情况下加载用户数据，为了满足这样的场景，就需要把相关信息保存到本地。对于iOS持久化方面，无论使用userDefault、plist文件、归档、数据库等存储方式，都需要考虑一个问题，如何安全的存储数据？对于这个问题，可以对数据加密保存，至于选择哪种持久化方式，并不是那么重要。</p>
<h5 id="加密方案"><a href="#加密方案" class="headerlink" title="加密方案"></a>加密方案</h5><p>说到对数据进行加密，那么肯定是要有一套安全的加密方案才行。以下是一些方案例子：<br>A. 一些摘要算法或编码处理。<br>B. 使用特定的秘钥执行某种对称加密。<br>C. 使用特定的公私钥执行某种非对称加密。<br>D. 某种自定义加密算法。<br>对于A，这只是一种把明文转为非明文的一种方式。摘要算法不可逆，但数据无法还原，不符合需求。编码处理，可以反编码还原明文，实际上数据并没有变得更安全，也是不符合需求。但采用编码的方式，还是比直接使用明文要好那么一点点。<br>对于B.使用公开的对称算法进行加解密，只要保证秘钥的安全，是可行的。<br>对于C.同B，但相对于对称加密，非对称加密效率较低，所以在保证秘钥安全的前提下，选择B，而不是选择C。但C的安全系数会比B高。两者都已经满足数据破解的成本超过其获取的价值的要求。<br>对于D，自定义算法，就要具体分析了， 破解难度因算法本身设计有关，但这个一般都是比较有实力的公司才这么搞吧，但一般都安全性比较高。是最好的方案之一，但其存在一定设计成本和测试成本。</p>
<h5 id="从安全范围的角度去考虑"><a href="#从安全范围的角度去考虑" class="headerlink" title="从安全范围的角度去考虑"></a>从安全范围的角度去考虑</h5><p>到了这里，又面临了一个秘钥安全的问题，一般来说，我们可能会把秘钥硬编码到代码中，但我们的二进制文件存在一个字符串常量区，只要这个字符串在代码中被引用了，那么编译器就会把其写进字符串常量区。如果这样，稍微的分析下二进制文件，就可能把秘钥获取。所以秘钥硬编码是比较危险的。面对这个问题，可以通过把秘钥分拆成多个字符串，再通过某些处理生成真正的秘钥，来提高安全性。这里会存在一个更值得思考的问题，为了引出这个问题，先回归到方案的探索。</p>
<p>到目前为止讨论到的都是本地怎么安全保存数据，到如何安全保存秘钥，都是围绕着单体方案去考虑，而没有从整体上去考虑。从安全范围的角度去考虑，如果在每一个客户端都是同样的加密算法，同样的秘钥，那么只要其中一个被破解，整个大厦立马倒塌。</p>
<p>为此，可以给安卓和苹果分别分配不同的秘钥，这样就能把两个平台，这块的安全性隔离。既然有了这样的想法，那么前进一步，如果每个客户端都拥有不同的秘钥，并且是一种随机秘钥（随机安全性更高，当然可能伪随机，虽然伪随机实际上是通过算法来生成的，有规律，但其破解难度很大），那么就能把这块的安全性做到客户端隔离。</p>
<h5 id="最终选择的方案："><a href="#最终选择的方案：" class="headerlink" title="最终选择的方案："></a>最终选择的方案：</h5><p>使用AES对称加密算法；使用随机算法生成本地秘钥，秘钥中添加时效性信息，并保存到keyChain中。</p>
<p>优点：客户端隔离、对称加解密效率高，随机秘钥破解难度大。<br>缺点：由于客户端隔离，秘钥都不一样，数据无法统一分析，因此也影响了适用场景。</p>
<p>demo:<a href="https://github.com/zmubai/LocalEncryptDemo" target="_blank" rel="noopener">LocalEncryptDemo</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-07-14安全思考.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-07-14安全思考.html" itemprop="url">iOS 移动端 安全思考与总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-02T00:00:00+08:00">
                2019-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-07-14安全思考.html" class="leancloud_visitors" data-flag-title="iOS 移动端 安全思考与总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,577
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="iOS-移动端-安全思考"><a href="#iOS-移动端-安全思考" class="headerlink" title="iOS 移动端 安全思考"></a>iOS 移动端 安全思考</h3><p><img src="https://upload-images.jianshu.io/upload_images/1690665-9e69d9eb90759663.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="v2-510e2d2a1aae6e5ced9f1b142b33af0a_r (1).jpg"></p>
<p>这是一遍安全知识总结的博客，并涉及相关知识的延伸，以作知识备忘和总结。</p>
<ul>
<li>安全相关的几个方面：</li>
</ul>
<ol>
<li>敏感数据输入安全</li>
<li>外部调用，和对外数据安全</li>
<li>本地数据存储安全</li>
<li>网络数据传输安全</li>
<li>app代码安全</li>
</ol>
<h4 id="以下分别对每一点展开"><a href="#以下分别对每一点展开" class="headerlink" title="以下分别对每一点展开"></a>以下分别对每一点展开</h4><h3 id="1-敏感数据输入安全"><a href="#1-敏感数据输入安全" class="headerlink" title="1.敏感数据输入安全"></a>1.敏感数据输入安全</h3><ul>
<li><p>textField密码模式与自定义键盘</p>
<p>  敏感数据主要是指密码信息或者使用户的个人信息、交易信息等。当我们输入密码的时候一般会打开textField的密码输入模式，这时候是会强制使用系统键盘，并且密码输入后不可见。如果苹果对系统键盘没有做数据获取，那么这相对安全的，不存在数据泄漏。但这个代码不是开源的，所以也是不敢打包票的。所以我们常见的一些银行app会去实现私有键盘，同时会打乱数字字母的位置。这里面大概有两个考虑，一个是防止键盘数据监听，另一个是防止第三者通过观察用户输入手势猜测密码。</p>
<p>  然而iOS是苹果的系统，如果苹果硬要监控数据，那么怎么都是没办法避免的，除非不用iOS系统。但这个本来就与苹果的立场相悖的。所以一些app实现私有键盘，个人认为主要是防止第三者通过观察用户输入手势的手段，猜测出密码。另外自定义键盘每个按钮点击的时候不显示视觉变化。如果在点击的时候样式发生变化，同时手机被录屏了，那么视频中就能看到密码输入的具体字符和顺序，导致密码泄露。</p>
</li>
<li><p>第三方键盘完全访问</p>
<p>  另外使用第三方键盘，特别是在运行完全访问之后，存在安全风险。允许完全访问后，第三方键盘能把用户输入的数据发送到自家后台（就算开始不允许完全访问，后面再允许，之前的输入数据也会被上传。因为不允许完全访问的时候，第三方键盘能把输入数据保存到本地，当获取到完全访问的时候再把这部分数据上传）。收集这个数据能对键盘的输入体验进行优化，主要是自动更正功能和根据用户的习惯匹配出更高频率的词语。但风险是时刻存在的，这个需要用户对体验的优化与承受的风险之间做权衡。但保守策略，安全起见，最好还是不允许键盘的完全访问。link:<a href="https://spiim.com/blog/about-full-access.html" target="_blank" rel="noopener">iOS 8 第三方键盘“完全访问”的那些事</a></p>
</li>
<li><p>键盘缓存</p>
<p>  当用户使用系统键盘，并开启自动更正功能的时候，系统就会把键盘的输入记录到系统的一个特定路径的文件中（/private/var/mobile/Library/Keyboard/dynamic-text.dat），并且该文件是明文存储。所以获取到文件内容，并加以分析，就有可能获取到用户的密码信息等。但这里有一个前提，必须是越狱手机才能获取，因为存在沙盒机制，应用是无法访问到该目录的文件的。基于这一点，使用自定义键盘就可以避免被输入被缓存。<br>link:<a href="https://www.ctolib.com/docs-ios-security-defense-c-keyboard-cache.html" target="_blank" rel="noopener">键盘缓存与安全键盘</a>    </p>
</li>
<li><p>安全策略：</p>
<ol>
<li>输入密码设置textField的密码输入模式。</li>
<li>安全性更好的，实现私有键盘，每次打乱键值顺序，控件不实现点击效果。</li>
<li>不允许第三方键盘的完全访问。</li>
</ol>
</li>
</ul>
<h3 id="2-外部调用，和对外数据安全"><a href="#2-外部调用，和对外数据安全" class="headerlink" title="2. 外部调用，和对外数据安全"></a>2. 外部调用，和对外数据安全<br></h3><ol>
<li>外部调用是指，其他应用唤起app的行为。主要是通过scheme来唤起。通常app内部是有处理外部调用的逻辑的，并能根据scheme后面拼接的参数来跳转到不同的业务模块。那么这里就有可能存在逻辑漏洞，特别对于重要的涉及用户金钱或隐私的模块，需要有一套严谨的参数校验规则，避免漏洞发生。个人认为这种提供给外部的入口，都是app安全的一个隐患，所有必须要有一个严谨的权限校验规则。</li>
<li><p>对外数据，指通过各种途径能被外部获知的数据。这里主要是app退到后台显示的截图，因为实在不知道这个归类到哪里，就归类到对外数据。系统截图是系统为了提供用户体验的手段，但可能无意中泄漏了重要信息。故这里要进行处理，第一种可以禁止截图，那么推到后台把keyWindows隐藏，那么系统的截图就变成黑色；另外一种就是手动替换截图，一般会对截图进行模糊化。</p>
</li>
<li><p>安全策略</p>
<ol>
<li>外部发起调用，需要有一套完善的鉴权机制。</li>
<li>系统截图，需要手动替换。</li>
</ol>
</li>
</ol>
<h3 id="3-本地数据存储安全"><a href="#3-本地数据存储安全" class="headerlink" title="3. 本地数据存储安全"></a>3. 本地数据存储安全</h3><p>本地数据如果明文保存的话，是不安全的。虽然有沙盒机制的保护，但如果手机被越狱了，那么数据就暴露了。所以，重要信息需要进行加密保存。可以采用aes进行加密，base64编码后进行保存。这样就算数据被获取，也无法得到有用信息。由于这里使用aes加密，那么如何安全保存加密秘钥是一个重要的问题。因为如果秘钥被破解了，那么数据就被破解了。因为本地数据加解密都在本地进行，所以秘钥作用范围也仅限于本地数据。一般可以使用两种方式提供秘钥：第一种hardCode秘钥，第二种本地生成秘钥，再保存本地。下面对安全性方案进行讨论：</p>
<ol>
<li><p>hanrdCode秘钥：<br></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//形如：</span><br><span class="line">static NSString *aesPriKey = @&quot;xxx0xxx0xxx0xxx0xxx0&quot;;</span><br></pre></td></tr></table></figure>
<p> 这看起来好像没什么问题，但这种hardCode的方式，很容易被获取。获取方式：使用逆向技术对app进行砸壳（例如pp助手下载的app已经砸壳），并使用使用machOViewer<br> 查看APP的二进制文件，就能获取到字符串常量（前提是这个字符有被引用，否则编译器貌似会优化掉。但我们加密的秘钥怎么可能会不引用呢，测试的时候发现的现象，顺便记录下）。</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1690665-28e536782b2bf45e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果写入到文件中，然后在运行过程中通过读文件的方式获取秘钥，那么也是不安全的，秘钥不能直接保存到文件中，但难道要把秘钥加密保存到文件中，那么用于加密的秘钥怎么保证安全，这就变成了鸡生蛋蛋生鸡的问题了。可以尝试直接对秘钥加盐然后编码存储到文件中，这样只要加盐规则和编码规则足够复杂也是相对安全的。</p>
<ol start="2">
<li><p>本地生成秘钥<br> 由于这个秘钥保存的问题，个人在开发中使用的方案是，本地生成随机秘钥，并把秘钥保存到系统keychain中,同时可以设置秘钥的有效时间。这样设计有两个好处，一个生成随机秘钥，能保证每台手机的秘钥不一样，这样能缩窄影响范围，第二个是由于时效性的存在，当然这个时效性只能引用于用户登录信息等功能，但它增加了秘钥破解的难度。除非破解了代码逻辑并成功获取到keychain的秘钥，同时破解苹果的加密算法，才有可能破解整套策略，所以是相对安全的。在这个过程中，我们甚至可以对生成的秘钥加盐，但我认为这个貌似没必要，如果加盐是常量字符串，反而能从分析二进制文件常量字符中顺藤摸瓜找到相关的加密逻辑，留下多余线索。</p>
</li>
<li><p>安全策略：    </p>
<ol>
<li>不使用常量字符串定义秘钥。如果确实是固定的秘钥，那么要使用一套混淆规则混淆秘钥，使用的时候再对秘钥进行反混淆，例如 salt1 +  原始秘钥 + salt2 再两次base64生成新的字符串作为常量保存。使用的时候，base64Decode两次再获取中间的元素秘钥。规则应该多变的，不要全部一致，否则这个混淆就没有意义了。</li>
<li>本地秘钥随机生成（可以使用arc4random(),这里不要使用时间戳作为随机种子，因为时间戳是有规律的。但时间戳可以作为信息添加到秘钥中，作为有效时间的判断。）同时生成的秘钥以密码的形式保存到系统的keyChain中，这样苹果会对秘钥进行加密并保存到keyChain中。可采用aes128/192/256(秘钥长度分别为16/24/32byte,128/192/256bit) + base64编码的加密方案。</li>
</ol>
</li>
</ol>
<p><strong>aes的相关说明</strong></p>
<p>aes是一种分组密码算法。   以下摘录维基百科对分组密码的一些重要描述,包括分组密码的概念，还有算法的设计原则中两个重要因素扩散和扰乱。其中还谈到每一轮都使用不同的子秘钥，这样会大大增加区块之间的关联性，让破解难度变高，而几种加密模式中ecb电密码本模式并没有使用这种设计思想去实现加密，下面会谈到多种加密模式。</p>
<blockquote>
<p>维基百科</p>
<blockquote>
<p>在密码学中，分组加密（英语：Block cipher），又称分块加密或块密码，是一种对称密钥算法。它将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>迭代产生的密文在每一轮加密中使用不同的子密钥，而子密钥生成自原始密钥。</p>
<p>设计原则:<br><strong>扩散（diffusion）</strong>和<strong>扰乱（confusion）</strong>是影响密码安全的主要因素。扩散的目的是让明文中的单个数字影响密文中的多个数字，从而使明文的统计特征在密文中消失，相当于明文的统计结构被扩散。扰乱是指让密钥与密文的统计信息之间的关系变得复杂，从而增加通过统计方法进行攻击的难度。扰乱可以通过各种代换算法实现。</p>
</blockquote>
</blockquote>
<p><strong>分组密码工作模式</strong></p>
<p>分组密码工作模式，常用模式有五种：电子密码本ECB、密码块链接CBC、填充密码块链接PCBC、密文反馈CFB、输出反馈OFB、计数器模式CTR。另外还有相关的很重要的几个概念，分别是加密向量IV和块填充模式PADDING。维基百科概关于分组密码工作模式的概要说的很精辟。</p>
<blockquote>
<p>维基百科 -分组密码工作模式</p>
<blockquote>
<p>密码学中，分组（block）密码的工作模式（mode of operation）允许使用同一个分组密码密钥对多于一块的数据进行加密，并保证其安全性。分组密码自身只能加密长度等于密码分组长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适填充方式将数据扩展到匹配密码块大小的长度。一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全[1]。</p>
</blockquote>
</blockquote>
<p>对于AES来说，块的固定长度为128bit,秘钥长度为128/192/256bit（这个涉及到编码细节，例如不知道这个，就不知道秘钥的长度，可能导致编码错误）。由于块的长度固定为128，所以就存在最后一个块填充的问题，这涉及到块的填充模式PADDING,加密解密都需要用同样的的块填充模式去处理最后的块（涉及到编程细节，块填充模式的选择）。加密的时候是对明文切分成若干组，每组长度都等于128位。aes会对每一组进行多轮加密。其过程包括若干步骤，轮秘钥加、字节替换、行位移、列混合、轮秘钥加，并且根据秘钥的位数不同分别对应不同的轮数（位数/轮数）128/10，192/12,256/14。密码学的东西不太好啃，数学渣渣表示啃不动，需要比较好的数学基础才能比较畅顺的理解其加密过程的每个步骤，但我觉得十几步的加密过程和多轮的加密，应该是围绕扩散和扰乱两点出发，来提高算法的破解难度的。</p>
<p><strong>ECB模式与CBC模式</strong></p>
<p>挑选ECB和CBC模式分析，加深对分组密码工作模式的理解，直观对比两模式的差异，并简要说明下使用IV的原因。</p>
<p>ECB模式：<br>把明文划分为长度相等的块128bit,并对每个块独立加密，最后拼接成为完整的加密密文。<br>由于每个块都是使用同一个秘钥独立加密，块与块之间没有关联性，对于同样的明文块（不管其在整个块集合中那个位置）加密产生的密文都是一样的，因此更有规律性，不能很好隐藏数据。</p>
<p>CBC模式：<br>同样先划分块，加密的时候CBC每个明文块与前一个密文块进行异或后再进行加密。这样每个块都依赖其前面的块，内部是联动的，这样的话，存在明文系统的块，加密出来的结果也是不一样的，从这一点来看比ECB安全性更高。但这里存在一个问题，就是如果第一个块内容一样，那么对于共同的明文前缀加密出来的结果也是一样的，如果这样，反而变成了破解的一个入口。为了解决这种情况，这个时候上面提到的重要元素向量IV就派上用场了，第一个块加密加入向量的参与，主要确保每一个条消息独有的一个向量，那么就能保证密文的唯一性。缺点：由于块之间存在依赖导致其加密过程是串行的，并且消息必须被填充到块大小的整数倍。</p>
<p>aes的加密原理：aes支持三种秘钥长度分别是128/192/256位，对应字符串长度为16/24/32。加密的时候是对明文切分成若干组，每组长度都等于128位。aes会对每一组进行多轮加密。其过程包括若干步骤，轮秘钥加、字节替换、行位移、列混合、轮秘钥加，并且根据秘钥的位数不同分别对应不同的轮数（位数/轮数）128/10，192/12,256/14。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86" target="_blank" rel="noopener">维基百科-AES</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科-分组密码工作模式</a></p>
<p><strong>关于随机数</strong></p>
<blockquote>
<p>维基百科-随机数</p>
<blockquote>
<p>根据密码学原理，随机数的随机性检验可以分为三个标准：<br><strong>1.统计学伪随机性</strong>。统计学伪随机性指的是在给定的随机比特流样本中，1的数量大致等于0的数量，同理，“10”“01”“00”“11”四者数量大致相等。类似的标准被称为统计学随机性。满足这类要求的数字在人类“一眼看上去”是随机的。<br><strong>2.密码学安全伪随机性</strong>。其定义为，给定随机样本的一部分和随机算法，不能有效的演算出随机样本的剩余部分。<br><strong>3.真随机性</strong>。其定义为随机样本不可重现。实际上衹要给定边界条件，真随机数并不存在，可是如果产生一个真随机数样本的边界条件十分复杂且难以捕捉（比如计算机当地的本底辐射波动值），可以认为用这个方法演算出来了真随机数。但实际上，这也只是非常接近真随机数的伪随机数，一般认为，无论是本地辐射、物理噪音、抛硬币……等都是可被观察了解的，任何基于经典力学产生的随机数，都只是伪随机数。</p>
</blockquote>
</blockquote>
<p>随机数分类：<br></p>
<ol>
<li>伪随机数：满足第一个条件的随机数。<br></li>
<li>密码学安全的伪随机数：同时满足前两个条件的随机数。可以通过密码学安全伪随机数生成器计算得出。<br></li>
<li>真随机数：同时满足三个条件的随机数。</li>
</ol>
<p><strong>重点是</strong>：随机数在密码学中非常重要，保密通信中大量运用的会话密钥的生成即需要真随机数的参与。如果一个随机数生成算法是有缺陷的，那么会话密钥可以直接被推算出来。真正的随机数是使用物理现象产生的：比如掷钱币、骰子、转轮、使用电子组件的噪音、核裂变等等。这样的随机数生成器叫做物理性随机数生成器，它们的缺点是技术要求比较高。<br>在实际应用中往往使用伪随机数就足够了。这些数列是“似乎”随机的数，实际上它们是通过一个固定的、可以重复的计算方法产生的。它们不真正地随机，因为它们实际上是可以计算出来的，但是它们具有类似于随机数的统计特征。这样的生成器叫做伪随机数生成器。<br>在真正关键性的应用中，比如在密码学中，人们一般使用真正的随机数。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0" target="_blank" rel="noopener">维基百科-随机数</a></p>
<p><strong>关于加盐</strong></p>
<blockquote>
<p>维基百科-盐</p>
<blockquote>
<p>盐（Salt），在密码学中，是指在散列之前将散列内容（例如：密码）的任意固定位置插入特定的字符串。这个在散列中加入字符串的方式称为“加盐”。其作用是让加盐后的散列结果和没有加盐的结果不相同，在不同的应用情景中，这个处理可以增加额外的安全性。</p>
</blockquote>
</blockquote>
<p>作用：提高数据安全性， 加盐后再通过散列算法得出特征值，不能直接通过彩虹表暴力破解出原数据，在验证用户密码的场景下，极大的提高了安全性。但同时因为要校验用户密码，所以需要保存这个盐值。</p>
<p>以下为维基百科相关描述<br><br>通常情况下，当字段经过散列处理（如MD5），会生成一段散列值，而散列后的值一般是无法通过特定算法得到原始字段的。但是某些情况，比如一个大型的彩虹表，通过在表中搜索该MD5值，很有可能在极短的时间内找到该散列值对应的真实字段内容。<br>加盐后的散列值，可以极大的降低由于用户数据被盗而带来的密码泄漏风险，即使通过彩虹表寻找到了散列后的数值所对应的原始内容，但是由于经过了加盐，插入的字符串扰乱了真正的密码，使得获得真实密码的概率大大降低。</p>
<p>所以在某些业务场景下可以考虑使用加盐的方式提高数据安全性。</p>
<h3 id="4-网络数据传输安全"><a href="#4-网络数据传输安全" class="headerlink" title="4. 网络数据传输安全"></a>4. 网络数据传输安全</h3><p>移动数据通过网络传输主要是面临几个风险：1.窃听风险。2.篡改风险。3.冒充风险。<br>那么可以认为如果没有以上风险，传输就是安全的。s<br>在民用领域网络通信一般都是使用http，https，又或者使用socket的tcp udp通讯，另外还有一些私有协议（微信、qq）。对于敏感数据的传输，使用http是不安全的（除非先自己加密一遍再传输），而在不使用私有协议的前提下，为了保证安全性，一般会使用https。https依赖于第三方权威机构证书认证和非对称算法，能使clien和server相互确认身份，安全生成第三个随机数，并协商出用于对称加密的会话密秘钥，进行安全的对称加密传输（<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">https原理说明</a>），我认为安全生成了会话秘钥后，在没有秘钥的情况下无法解开密文的，这样就能有效防止了窃听风险，篡改风险和冒充风险。首先无法解密就能避免窃听和冒充，而篡改，或者你可以把内容换掉，但这会导致解密失败，就算解密成功也是没有意义的内容，无关紧要。</p>
<p>但在使用https的情况下，有几个点还是需要注意一下：</p>
<ol>
<li>https可以使用自签名证书，这种情况通过浏览器请求，地址栏开头一般会出现一个✘的图标，代表这个请求是不授信的，有些浏览器会提示风险并询问是否继续访问。但如果你在系统中添加了相关的根证书并设置信任，那么这个请求就会被认为是合法的。所以，往系统中添加证书需要慎重。</li>
<li>客户端编码的时候，要根据服务器的证书情况（权威认证证书，还是自签名证书）设置合理的证书校验规则。编码涉及的点：1.是否校验域名；2.是否校验有效期；3.具体的校验策略。如果是使用AFNetWorking,涉及到的编码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//配置请求Manager是创建安全策略对象</span><br><span class="line">//暂时忽略PinningMode的选择</span><br><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:xxxx];</span><br><span class="line"></span><br><span class="line">//是否校验域名，3.0版本默认为YES。</span><br><span class="line">securityPolicy.validatesDomainName=NO;</span><br><span class="line"></span><br><span class="line">//是否允许无效证书（包括不校验证书有效期）。假设你想通过设置这里，来跳过校验有效期的话，在AFSSLPinningModeNone和AFSSLPinningModePublicKey是有效的，但AFSSLPinningModeCertificate是无效的，AFSSLPinningModeCertificate是一定会去校验证书是否有效，然后再去验证证书链，这里还是存在一定的疑惑，或许我可以给作者提一个issue。</span><br><span class="line">securityPolicy.allowInvalidCertificates=NO;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>简述AFSecurityPolicy三种模式</strong></p>
<ol>
<li>AFSSLPinningModeNone<br>选择该模式，当设置allowInvalidCertificates为YES时，会去校验证书有效期，会使用系统内置的权威机构根证书去校验客户端证书是否合法。但如果allowInvalidCertificates设置为NO，不进行合法性校验校验，方法返回值直接返回YES）。</li>
<li>AFSSLPinningModePublicKey<br>读取内嵌所有cer（DER编码）文件，并提取全部publicKey,判断客户端证书的publicKey是否被包含。<br>3.AFSSLPinningModeCertificate<br>读取内嵌所有cer（DER编码）文件，并判断端客户端证书内容是否被包含，只要证书链中其中一个证书被包含即可。因为客户端证书是由其上级证书签发的，而其上级证书是由服务器证书直接或者间接签发的，重点是上级证书能校验下级证书的合法性，换句话说如果客户端的上级证书被包含了，那么就能确认客户端证书的合法性。为了提高代码效率可以直接包含客户端证书或者客户端证书的上级证书。</li>
</ol>
<p><strong>小结：三种安全策略</strong></p>
<ol>
<li>allowInvalidCertificates = YES ;+ AFSSLPinningModeNone; + validatesDomainName = YES（必须为YES，否则不安全；这样可以防止数据被篡改，但可以被抓包，数据还是会泄漏。）; </li>
<li>allowInvalidCertificates = NO；+ AFSSLPinningModePublicKey; + validatesDomainName = YES/NO（某些情况下，证书域名不匹配所有客户端请求，此时需要配置为NO）;</li>
<li>AFSSLPinningModeCertificatev；+ alidatesDomainName = YES/NO（同上）;</li>
</ol>
<p>下图为越狱版支付宝包内容展示，可见里面内嵌了pem编码格式的证书，包含了base64格式的公钥。<br><img src="https://upload-images.jianshu.io/upload_images/1690665-b7286c7a9af90258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//命令行查看证书内容：</span><br><span class="line">zmubaiMacBook:AlipayWallet.app zengbailiang$ cat opensdk_public.pem </span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCtDVxvZhDT6FNaBqZ/Js2h7G7j</span><br><span class="line">v88UjsRlv2qDHpobSqzqe/PAbfmHZNvOOlR07l9k8GJMUp4v4z+hTy4pjypmB1St</span><br><span class="line">nt5nulRHIbcUSQ3LsT3rETJGVsGBEkvIeZXHFRDK5UmeUO9IgiviwAthgvLnDM9S</span><br><span class="line">ZOa9QCTROfibnpYWVQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>
<p>参考链接：<br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a><br><a href="https://baike.baidu.com/item/X.509/2817050" target="_blank" rel="noopener">X.509公钥证书格式标准，对证书链的验证过程有很好的说明</a><br><a href="http://www.cocoachina.com/ios/20140916/9632.html" target="_blank" rel="noopener">AF证书校验部分源码说明</a></p>
<h3 id="5-app代码安全"><a href="#5-app代码安全" class="headerlink" title="5. app代码安全"></a>5. app代码安全</h3><p>这部分主要是涉及到开发期的代码混淆、加固技术。逆向加固方面的知识了解的比较少，也就不做什么记录了。但仍然需要记录下一些主要的点。</p>
<p>提高代码安全，增强逆向难道的一些手段</p>
<ol>
<li>类名、方法名、属性名混淆。（但混淆过度，可能导致审核被拒）</li>
<li>重要函数使用c（依然能被hood，使用fishhook等工具），内联静态函数安全性更高。</li>
<li>加密重要的字符串，避免砸壳后直接分析获取重要信息。（这方面有开源库）</li>
<li>使用加固工具，或第三方加固服务（UAObfuscatedString编译插件、爱加密、360加固等。）</li>
</ol>
<p>相关文章参考：<br><a href="https://www.jianshu.com/p/bff550b3ead4" target="_blank" rel="noopener">对 iOS app 进行安全加固</a></p>
<h4 id="总结：孙子兵法有言知己知彼，方可百战百胜。安全攻防就是这样的一个东西，要去了解哪些攻击破解手段，才能更好的实施应对手段。"><a href="#总结：孙子兵法有言知己知彼，方可百战百胜。安全攻防就是这样的一个东西，要去了解哪些攻击破解手段，才能更好的实施应对手段。" class="headerlink" title="总结：孙子兵法有言知己知彼，方可百战百胜。安全攻防就是这样的一个东西，要去了解哪些攻击破解手段，才能更好的实施应对手段。"></a>总结：孙子兵法有言知己知彼，方可百战百胜。安全攻防就是这样的一个东西，要去了解哪些攻击破解手段，才能更好的实施应对手段。</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/icon.jpg"
                alt="zengbailiang" />
            
              <p class="site-author-name" itemprop="name">zengbailiang</p>
              <p class="site-description motion-element" itemprop="description">知行合一</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a rel="external nofollow" href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zmubai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zengbailiang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">52.6k</span>
  
</div>


  <div class="powered-by">由 <a rel="external nofollow" class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("7VSaCuGNNUXrDp0aOK65w7PQ-gzGzoHsz", "l1D8p6eriduqG6aqx1f8H7ia");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
