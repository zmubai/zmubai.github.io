<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="知行合一"><meta name="keywords" content><meta name="author" content="liang"><meta name="copyright" content="liang"><title>liang's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">liang</div><div class="author-info__description text-center">知行合一</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">51</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">14</span></a></div></div></div><nav id="nav" style="background-image: url(/personImg/topimg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">liang's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">about</a></span></div><div id="site-info"><div id="site-title">liang's blog</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018-07-22-leetcode.html">算法-不同路径</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/动态规划/">动态规划</a></span><div class="content">题目：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？

例如，上图是一个7 x 3 的网格。有多少可能的路径？
说明：m 和 n 的值均不超过 100。
示例 1:
输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右

示例 2:
输入: m = 7, n = 3输出: 28

题目分析：每个格子的路径数等于其上方的格子的路径数与其左方的路径数之和。dp公式为：dp(i,j) = dp(i - 1,j) + dp (j,i - 1)，其中( 0&lt;= i &lt;= m - 1, 0 &lt;= j &lt;= n -1 )。所以右下角的格子的的路径数为dp（i-1，j-1）。特殊情况处理，如果m == 1 或者 n == 1,那么路 ...</div><a class="more" href="/2018-07-22-leetcode.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018-07-07-15-0leetcode.html">算法-使用最小花费爬楼梯</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/动态规划/">动态规划</a></span><div class="content">题目：数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 costi。
每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。
您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
示例 1:输入: cost = [10, 15, 20]输出: 15解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。示例 2:输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。

注意：
cost 的长度将会在 [2, 1000]。每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。
题目分析：可以把每个阶梯当做一个节点，能走出消耗值小值得路径可能有几条。同时可能会存在一些节点你走错了无法走出最小值的路径。如何选择这些节点是个问题。这看起来有点像广度优先搜索，每一次选择都需要根据前面的两个节点和当前节点的消耗值 ...</div><a class="more" href="/2018-07-07-15-0leetcode.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018-07-07-14-10leetcode.html">算法-反转整数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/算法/">算法</a></span><div class="content">题目：给定一个 32 位有符号整数，将整数中的数字进行反转。
示例 1:输入: 123输出: 321 示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21

注意:假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。
题目分析：1.从低位开始获取位数，每次存储的时候把原有值*10，低位插入到最后面。直到处理完毕。如果中途超出了数值范围则直接返回0。2. 判断是否超出了数值范围    1. 已知 INT_MAX = 2147483647 ,  INT_MIN = -2147483648.    假设当前已有计算值为rev,尚未处理完毕且当前获取的准备插入的数值为pop。        1. 如果输入值为正数，那么当 rev &gt; INT_MAX/10 或者rev/10 == INT_MAX &amp;&amp; pop&gt;7，代表超出范围。        2. 如果输入值为负数，那么当 rev &lt; INT_MIN/10 或者rev/10 == INT_MIN ...</div><a class="more" href="/2018-07-07-14-10leetcode.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018-07-07-07-10leetcode.html">算法-最大子序和</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/动态规划/">动态规划</a></span><div class="content">题目：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:
输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

题目分析：思路1：贪心算法
连续子数组之和如果为负数，那么把它作为和的一部分反而减少了和的大小。所以当子数组之和为负数的时候进行舍弃，取下一个元素作为起点重新累加。但这样累加会存在一个问题，虽然知道起点，也知道终点，但过程中累加到哪一个元素的和为最大却不知道。只能通过每累加一个元素就计算一次和，这样就不会错过每个可能的最大值。
代码 int greedMaxSubArray(int* nums, int numsSize)&#123;    int maxSum = INT_MIN;    int thisMaxSum = INT_MIN;    for (int i = 0 ; i &lt; numsSize; i ++) &#123;            //如何和小于0代码表示这整块都可以舍弃，因为不起到增大和的作用        i ...</div><a class="more" href="/2018-07-07-07-10leetcode.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018-07-07-07-01leetcode.html">算法-Z字形变换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/blog/">blog</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/算法/">算法</a></span><div class="content">题目：将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：
P   A   H   NA P L S I I GY   I   R

之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR”
实现一个将字符串进行指定行数变换的函数:
string convert(string s, int numRows);示例 1:
输入: s = “PAYPALISHIRING”, numRows = 3输出: “PAHNAPLSIIGYIR”示例 2:
输入: s = “PAYPALISHIRING”, numRows = 4输出: “PINALSIGYAHRPI”解释:
P     I    NA   L S  I GY A   H RP     I

思路1：按行排序
题目要求有两个，一个是字符是按Z字形排序，一个由上而下按行输出。

分析下Z字形的排序规律。z字形先是由上而下，到了底部再向上，每到底部或者顶部就会反弹，程序中使用bool变量lineUp记录方向。遍历字符的同时，使用一个二维数组int a[row][strlen(s)]来存储行与元素原始下标的关系。遍历 ...</div><a class="more" href="/2018-07-07-07-01leetcode.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018-06-07-01-leetcode.html">算法-两最长回文子串</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/算法/">算法</a></span><div class="content">题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。
示例 1：输入: "babad"输出: "bab"注意: "aba"也是一个有效答案。示例 2：输入: "cbbd"输出: "bb"

思路
暴力法。2层循环嵌套，遍历所有子串。在判断子串是否为回文并对比保存最大的起止下标。通过前后同时截取字符串对比的方式来判断子串是否为回文。如果相等，就向两边靠拢，直对比的下标相等并且值也相等位置。如果不相等，子串非回文。
中心扩展算法。回文字符串有一个特点，就是左右对称。如果是奇数长度的回文字符串，中间的字符作为对称点，如aba中的a。如果是偶数长度的回文字符串，会以中间两个字符作为对称点,如abba中的bb。那么比较的时候，找到中心点，两边扩展对比就可以了。直到打破对称，通过暂存的历史最长回文子串的起止坐标比对当前长度，如果当前子串的长度较大，更新起止坐标。由于存在奇偶两种长度，对应的中心点不一样，但两种模式都可能产生回问子串，所有匹配的时候两种模式都要进行匹配，并取同一个中心点的两种模式中长度更长的更新起止坐标，这个是编码时需要处理的细节问题。

编码细 ...</div><a class="more" href="/2018-06-07-01-leetcode.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018-06-30-01-leetcode.html">算法-两个排序数组的中位数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/算法/">算法</a></span><div class="content">题目两个排序数组的中位数
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。
请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。
示例 1:nums1 = [1, 3]nums2 = [2]中位数是 2.0示例 2:nums1 = [1, 2]nums2 = [3, 4]中位数是 (2 + 3)/2 = 2.5

思路：
中位数下标 （假设数组为arr，长度为len，下标范围[0 ,len - 1]）
如果len % 2 = 1 （为奇数），那么中位数的值为arr[mindIndex = len /2] 。
如果len % 2 - 0 (为偶数)，那么中位数的值为(arr[len/2]+arr[len/2 - 1])/2.0的值的和的平均值。


思路一：最简单的思路把两个有序数组合并成一个有序的数组，再通过规则1.获取中位数的值。优化：结合题目要求，只需要获取中位数的值，并不需要真的要把两个数组排序成一个有序数组。那么通过两数组间隔读取，下标后移，直到累加到位置为为len/2即可获取到结果。这里如何更快地把找到len/2的位置是效率 ...</div><a class="more" href="/2018-06-30-01-leetcode.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018-06-28-01-leetcode.html">算法-两数相加</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/算法/">算法</a></span><div class="content">/* 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。
 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807
 */
/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     struct ListNode *next; * &#125;; */struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123;    struct ListNode* l3 = (struct ListNode*)malloc(sizeof(struct ListNode));    struct ListNode* n1 = l1;    struc ...</div><a class="more" href="/2018-06-28-01-leetcode.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018-06-28-02-leetcode.html">算法-无重复字符的最长子串</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/字符串处理/">字符串处理</a></span><div class="content">
给定一个字符串，找出不含有重复字符的最长子串的长度。
示例：给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。
给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。
给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列  而不是子串。

思路：
从字符串第一个元素起，从左到右获取子串。
每前进一个字符(下标为j)，就在当前子串中查找是否存在与当前字符重复的字符，如果存在(重复字符的下标为i)，那么能确定一个包含不重复字符的子串，其长度为j - i 对比已存储的最大长度并把两者的最大值存储。
现在下一个子串的起点为当前重复的字符下标j.重复执行2、3操作，直到最后一个字符。

其实这是滑动窗口的思路。左闭右开。
int lengthOfLongestSubstring(char* s) &#123;    int len = strlen(s);    //长度为0 的情况的处理    if(len == 0) return 0;    int max = 1;    int sta ...</div><a class="more" href="/2018-06-28-02-leetcode.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018-06-27-01-leetcode.html">算法-两数之和</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/算法/">算法</a></span><div class="content">题目
给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。

你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。
示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]/** * Note: The returned array must be malloced, assume caller calls free(). */ //面向过程的解法；这是最直接的思路。int* twoSum(int* nums, int numsSize, int target) &#123;    int *a=(int *)malloc(2*sizeof(int));    //外层index从0开始遍历    int index = 0;    while (index &lt; numsSize - 1) &#123;    //内层从外层当前下标index的下一个元素开始遍历即i= index + 1        int i = index + 1;       ...</div><a class="more" href="/2018-06-27-01-leetcode.html#more" style="margin-top: 14px">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/personImg/topimg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By liang</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>