<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="知行合一"><meta name="keywords" content><meta name="author" content="liang"><meta name="copyright" content="liang"><title>liang's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">liang</div><div class="author-info__description text-center">知行合一</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">50</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">14</span></a></div></div></div><nav id="nav" style="background-image: url(/personImg/topimg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">liang's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">about</a></span></div><div id="site-info"><div id="site-title">liang's blog</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/1249. 移除无效的括号.html">1249. 移除无效的括号</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"> 给你一个由 '('、')' 和小写字母组成的字符串 s。你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。请返回任意一个合法字符串。有效「括号字符串」应当符合以下 任意一条 要求：空字符串或只包含小写字母的字符串可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」 示例 1：输入：s = "lee(t(c)o)de)"输出："lee(t(c)o)de"解释："lee(t(co)de)" , "lee(t(c)ode)" 也是一个可行答案。

解1：利用栈来处理括号的匹配问题。遍历字符串，遇到”(“入栈，遇到”)”,那么需要查看栈里面是否为空，分两种情况：

如果栈不为空，那么存在匹配的”(“，那么出栈，继续遍历。
如果栈为空，那么此”)”找不到匹配，此”)”，必然是需要删除的，把其标记到map中。可能不同的思路处理的方式不一样，有些处理方式可能把其放入栈中，最后的时候在拿出来，删除。

最后获取到需要删除的map集合，创建临时字 ...</div><a class="more" href="/1249. 移除无效的括号.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/744. 寻找比目标字母大的最小字母.html">744. 寻找比目标字母大的最小字母</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"> 给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。数组里字母的顺序是循环的。举个例子，如果目标字母target = 'z' 并且有序数组为 letters = ['a', 'b']，则答案返回 'a'。

解1:遍历，然后对比target,记录比target大且差值最小的元素的下标bigIndex，如果存在那么返回letters[bigIndex]。如果没有比traget大的元素，那么根据题意，字母是循环的，那么返回letters[0]。
char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123;    int big = -1;    int bigIndex = -1;        for(int i = 0; i &lt; letters.size(); i ++)&#123;            int len = letters[i] - target;            if(len &gt;= 0)   ...</div><a class="more" href="/744. 寻找比目标字母大的最小字母.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/807. 保持城市天际线.html">807. 保持城市天际线</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"> 在二维数组grid中，grid[i][j]代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。 请看下面的例子。建筑物高度可以增加的最大总和是多少？例子：输入： grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]输出： 35解释： The grid is:[ [3, 0, 8, 4],   [2, 4, 5, 7],  [9, 2, 6, 3],  [0, 3, 1, 0] ]从数组竖直方向（即顶部，底部）看“天际线”是：[9, 4, 8, 7]从水平水平方向（即左侧，右侧）看“天际线”是：[8, 7, 9, 3]在不影响天际线的情况下对建筑物进行增高后，新数组如下：gridNew = [ [8, 4, 8, 7],            [7, 4, 7, 7],            [9, 4, 8 ...</div><a class="more" href="/807. 保持城市天际线.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/1123最深叶节点的最近公共祖先191115.html">leetcode 1123 最深叶节点的最近公共祖先</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"> 给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。回想一下：叶节点 是二叉树中没有子节点的节点树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1如果我们假定 A 是一组节点 S 的 最近公共祖先，&lt;font color="#c7254e" face="Menlo, Monaco, Consolas, Courier New, monospace"&gt;S&lt;/font&gt; 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。 示例 1：输入：root = [1,2,3]输出：[1,2,3]示例 2：输入：root = [1,2,3,4]输出：[4]示例 3：输入：root = [1,2,3,4,5]输出：[2,4,5] 提示：给你的树中将有 1 到 1000 个节点。树中每个节点的值都在 1 到 1000 之间。

解法一：最近公共祖先，是指，其下面的节点全部都是他的孩子。那么对应题目,有一种情况比较刺手，当存在不止一个分支的深度都等于树的最大深度，此时，就需要返回他们的共同祖先，而一般使用递归 ...</div><a class="more" href="/1123最深叶节点的最近公共祖先191115.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/887. 鸡蛋掉落 191112.html">leetcode 887. 鸡蛋掉落</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content">887. 鸡蛋掉落你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。你的目标是确切地知道 F 的值是多少。无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？示例 1：输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。

解法一：动态规划。dp[i][j]表示i个鸡蛋 ,j层需要的次数。当某个时刻楼层为x,仍下鸡蛋，会出现两种情况1.鸡蛋碎了，那么调整范围dp[i-1][x-1]。2.鸡蛋没碎，那么调整范 ...</div><a class="more" href="/887. 鸡蛋掉落 191112.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/715. Range 模块191109.html">leetcode 715. Range 模块</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content">715. Range 模块Range 模块是跟踪数字范围的模块。你的任务是以一种有效的方式设计和实现以下接口。addRange(int left, int right) 添加半开区间 [left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 [left, right) 中尚未跟踪的任何数字到该区间中。queryRange(int left, int right) 只有在当前正在跟踪区间 [left, right) 中的每一个实数时，才返回 true。removeRange(int left, int right) 停止跟踪区间 [left, right) 中当前正在跟踪的每个实数。addRange(10, 20): nullremoveRange(14, 16): nullqueryRange(10, 14): true （区间 [10, 14) 中的每个数都正在被跟踪）queryRange(13, 15): false （未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）queryRange(16, 17 ...</div><a class="more" href="/715. Range 模块191109.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019-11-4leetcode719. 找出第 k 小的距离对.html">719. 找出第 k 小的距离对</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content">给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。示例 1:输入：nums = [1,3,1]k = 1输出：0解释：所有数对如下：(1,3) -&gt; 2(1,1) -&gt; 0(3,1) -&gt; 2因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。提示:2 &lt;= len(nums) &lt;= 10000.0 &lt;= nums[i] &lt; 1000000.1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2.

解法一：非常规的思路。如果对数组排序后，可以得出绝对值的区间范围。这是一个有序的区间范围,对于有序的范围，就可以考虑二分法去缩小范围。设定一个目标值，然后根据目标值在子函数中查找符合题目的条件，本题在子函数中计算小于等于目标值的绝对值个数，以作为二分的判断依据和获取答案的第K个最小距离。
int smallOrEquarK(vector&lt;int&gt;&amp; nums,long mid)&#123;    int r ...</div><a class="more" href="/2019-11-4leetcode719. 找出第 k 小的距离对.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019-11-3leetcode778水位上升的泳池中游泳本.html">778. 水位上升的泳池中游泳</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content">在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？示例 1:输入: [[0,2],[1,3]]输出: 3解释:时间为0时，你位于坐标方格的位置为 (0, 0)。此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置

解法一解读问题可知，要求的是能到达右下角的所有路径的每条路径的最大值，这个最大值集合的最小值。目标值是一个已知的范围，[格子中的最小值，格子中的最大值]。那么 ...</div><a class="more" href="/2019-11-3leetcode778水位上升的泳池中游泳本.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019-10-31leetcode658找到 K 个最接近的元素.html">658. 找到 K 个最接近的元素</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/算法/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content">给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。
示例 1:
输入: [1,2,3,4,5], k=4, x=3输出: [1,2,3,4]
解法一：找到k个最接近的元素，实际上是返回原数组的一个子数组。那么可以通过两头向中间获取原数组的元素，然后跟x对比，舍弃差值较大的。直到舍弃size - k 个元素为止。然后通过一个数组返回这些帅选过后的元素。
vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123;    vector&lt;int&gt; res(k,0);    int len = arr.size();    int left = 0;    int right = len - 1;    while(len &gt; k)&#123;        if(abs(arr[left] - x) &gt; abs(arr[ri ...</div><a class="more" href="/2019-10-31leetcode658找到 K 个最接近的元素.html#more" style="margin-top: 14px">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019-07-20iOS  证书校验的几种嵌入方式，公钥证书pem的读取.html">iOS  证书校验的几种嵌入方式，公钥证书pem的读取</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/安全/">安全</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/安全/">安全</a></span><div class="content">嵌入的几种方式使用公有协议https进行网络传输，为了避免数据被抓包，需要实现客户端的证书校验功能。而证书校验可能存在几种实现的方式。分别如下：A. 直接把客户端证书cer,嵌入到bundle中。B. 提取客户端证书的公钥，生成pem格式文件，嵌入到bundle中。C. 把cer证书pem格式的文本硬编码到代码中。D. 把pem格式公钥硬编码到代码中。
差别分析实际上，以上的实现方式都能实现证书校验的功能，只是对应的证书数据解析哪一步的代码处理有点差异。让我感到疑惑的是，为什么会存在这几种方式，特别是A和B。
使用B而不使用A的原因猜测：

开发团队可能不愿意泄漏过多的证书信息，只是为了实现功能必要的嵌入公钥信息。
证书信息不常驻内存，存在频繁读取的场景，此时考虑效率，只使用必要的公钥信息。

而C,D与A，B没有多大区别，主要是转成了base64硬编码到代码中。从安全性的角度来说，可能比直接把文件嵌入安全一点。文件直接砸壳就能拿到，很直接。而硬编码需要分析二进制，并且还要在一堆字符串查找，不那么直接。
公钥证书pem的读取// 从公钥证书文件中获取到公钥的SecKeyRef指针。 B ...</div><a class="more" href="/2019-07-20iOS  证书校验的几种嵌入方式，公钥证书pem的读取.html#more" style="margin-top: 14px">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/personImg/topimg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By liang</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>