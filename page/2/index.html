<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta name="google-site-verification" content="xdxP4Om7Pxp3OMC73kRMv2emRoA91RXOEPaKMivB_zg" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="沐白的个人博客">
<meta property="og:url" content="https://zengbailiang.cn/page/2/index.html">
<meta property="og:site_name" content="沐白的个人博客">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="沐白的个人博客">
<meta name="twitter:description" content="知行合一">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zengbailiang.cn/page/2/"/>





  <title> Hexo, NexT - 沐白的个人博客知行合一 </title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沐白的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-07-14-10leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-07-14-10leetcode.html" itemprop="url">算法-反转整数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-14T00:00:00+08:00">
                2018-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-07-14-10leetcode.html" class="leancloud_visitors" data-flag-title="算法-反转整数">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  542
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>给定一个 32 位有符号整数，将整数中的数字进行反转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"> </span><br><span class="line">示例 2:</span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p>
<p>注意:<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>1.从低位开始获取位数，每次存储的时候把原有值*10，低位插入到最后面。直到处理完毕。如果中途超出了数值范围则直接返回0。</p>
<ol start="2">
<li><p>判断是否超出了数值范围</p>
<ol>
<li>已知 INT_MAX = 2147483647 ,  INT_MIN = -2147483648.<br>假设当前已有计算值为rev,尚未处理完毕且当前获取的准备插入的数值为pop。<ol>
<li>如果输入值为正数，那么当 rev &gt; INT_MAX/10 或者rev/10 == INT_MAX &amp;&amp; pop&gt;7，代表超出范围。</li>
<li>如果输入值为负数，那么当 rev &lt; INT_MIN/10 或者rev/10 == INT_MIN &amp;&amp; pop &lt; -8,代表超出范围。</li>
</ol>
</li>
</ol>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x) &#123;</span><br><span class="line"> // int max = INT_MAX;//2147483647</span><br><span class="line"> // int min = INT_MIN;//-2147483648</span><br><span class="line"> int rev = 0;</span><br><span class="line"> </span><br><span class="line"> while (x != 0) &#123;</span><br><span class="line">     //获得最后一位</span><br><span class="line">     int pop = x % 10;</span><br><span class="line">     //把倒数第二位后移到第一位</span><br><span class="line">     x /= 10;</span><br><span class="line">     //判断溢出情况  结合max 和min 的值 就知道 为什么是 7 和 -8 了</span><br><span class="line">     if (rev &gt; INT_MAX / 10 || (rev/10 == INT_MAX &amp;&amp; pop &gt; 7)) &#123; return 0; &#125;</span><br><span class="line">     if (rev &lt; INT_MIN / 10|| (rev/10 == INT_MIN &amp;&amp; pop &lt; -8)) &#123;  return 0; &#125;</span><br><span class="line">     //*10整体后移一位 ，pop插入到第一位</span><br><span class="line">     rev = rev * 10 + pop;</span><br><span class="line"> &#125;</span><br><span class="line"> return rev;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li>复杂度分析<ol>
<li>时间复杂度 O(n), n为字符的长度</li>
<li>空间复杂度 O(1)，固定数量的变量。</li>
</ol>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>主要是数值范围判断的处理。也可以用一个long型来存储，最后的时候再跟INT_MAX判断。开始的想法是从高位开始获取，然后新数值先填充低位再填充高位。这个处理起来没有从低位开始获取的方便，因为新数值前移只需要乘以10即可，非常方便。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-07-07-10leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-07-07-10leetcode.html" itemprop="url">算法-最大子序和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T00:00:00+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-07-07-10leetcode.html" class="leancloud_visitors" data-flag-title="算法-最大子序和">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,350
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure></p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><h4 id="思路1：贪心算法"><a href="#思路1：贪心算法" class="headerlink" title="思路1：贪心算法"></a>思路1：贪心算法</h4><ol>
<li>连续子数组之和如果为负数，那么把它作为和的一部分反而减少了和的大小。所以当子数组之和为负数的时候进行舍弃，取下一个元素作为起点重新累加。但这样累加会存在一个问题，虽然知道起点，也知道终点，但过程中累加到哪一个元素的和为最大却不知道。只能通过每累加一个元素就计算一次和，这样就不会错过每个可能的最大值。</li>
<li>代码 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int greedMaxSubArray(int* nums, int numsSize)</span><br><span class="line">&#123;</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">    int thisMaxSum = INT_MIN;</span><br><span class="line">    for (int i = 0 ; i &lt; numsSize; i ++) &#123;</span><br><span class="line">    </span><br><span class="line">        //如何和小于0代码表示这整块都可以舍弃，因为不起到增大和的作用</span><br><span class="line">        if (thisMaxSum &lt;= 0) &#123;</span><br><span class="line">            thisMaxSum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            thisMaxSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(maxSum &lt; thisMaxSum)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSum = thisMaxSum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li>复杂度分析<ol>
<li>时间复杂度 O(n), n = strlen(s)，一层循环;</li>
<li>空间复杂度 O(1)，固定数量的变量。</li>
</ol>
</li>
</ol>
<h4 id="思路2：动态规划DP"><a href="#思路2：动态规划DP" class="headerlink" title="思路2：动态规划DP"></a>思路2：动态规划DP</h4><ol>
<li>运行到当前步骤获取到的可用和值为当前元素的值以及累加上当前元素所得的和中的最大值。获取的DP公式： maxSub(i) = getMaxSub(maxSub(i - 1) + nums[i],nums[i]);</li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//  maxSub(i) = getMaxSub(maxSub(i - 1) + nums[i],nums[i]);</span><br><span class="line">int dpMaxSubArray(int* nums, int numsSize)</span><br><span class="line">&#123;</span><br><span class="line">    int max = nums[0];</span><br><span class="line">    int sum = nums[0];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0 ; i &lt; numsSize; i ++) &#123;</span><br><span class="line">        int currentValue = nums[i];</span><br><span class="line">        if (sum + currentValue &lt; currentValue) &#123;</span><br><span class="line">            sum += currentValue;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            sum = currentValue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum&gt;max) &#123;</span><br><span class="line">            max = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ol>
<li>时间复杂度 O(n), n = strlen(s)，一层循环;</li>
<li>空间复杂度 O(1)，少量的固定的额外空间。</li>
</ol>
</li>
</ol>
<h4 id="思路3：分治递归"><a href="#思路3：分治递归" class="headerlink" title="思路3：分治递归"></a>思路3：分治递归</h4><ol>
<li>把数组分成左右两部分，那么对于这个范围，最大和可能出现在左边或者右边或者跨越两个左右部分。本轮中先给出分割点，从分割点向两边扩散遍历，获取跨越中心点最大的和值（只需要把左右部分的遍历最大值相加，有可能左边最大值为正，右边最大值为负，不用管只管相加，左边最大值会在分割后的左边某次递归中参与比较。递归有时候就是在一轮中考虑的情况变少了，有些情况是否在递归的过程中已被处理，或者说递归入参的改变就能计算出这些情况。）。方法的返回值为递归左部分、递归右部分、本轮跨越中心的最大和值三者的最大值。比较难理解的还是每一轮只计算跨越分割点的最大和值，随着范围的缩小递归起来就涵盖了所有的情况。</li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int max(int a ,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxSubArray(int* nums, int numsSize) &#123;</span><br><span class="line">    int maxSubLeft = 0;</span><br><span class="line">    int maxSUbRight = 0;</span><br><span class="line">    int maxLeft = INT_MIN;</span><br><span class="line">    int maxRight = INT_MIN;</span><br><span class="line">    </span><br><span class="line">    //推出递归条件</span><br><span class="line">    if (left == right) &#123;</span><br><span class="line">        return nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int center = (left + right) / 2 ;</span><br><span class="line">    int maxTempLeft = 0;</span><br><span class="line">    //计算当前的左相加最大值,右到左</span><br><span class="line">    for (int i = center; i &gt;= left; i --) &#123;</span><br><span class="line">        maxTempLeft += nums[i];</span><br><span class="line">        if (maxLeft &lt; maxTempLeft) &#123;</span><br><span class="line">            maxLeft = maxTempLeft;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (maxLeft == INT_MIN) &#123;</span><br><span class="line">        maxLeft = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //计算当maxTempRight   当前前右相加最大值，左到右</span><br><span class="line">    //每一个子数组都独自全部累加左右部分，那么久含括了所有的情况。</span><br><span class="line">    int  maxTempRight = 0;</span><br><span class="line">    for (int i = center + 1; i &lt;= right; i ++) &#123;</span><br><span class="line">        maxTempRight += nums[i];</span><br><span class="line">        if (maxRight &lt; maxTempRight) &#123;</span><br><span class="line">            maxRight = maxTempRight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (maxRight == INT_MIN) &#123;</span><br><span class="line">        maxRight = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    maxSubLeft = maxsubArrayRe(nums, left, center);</span><br><span class="line">    maxSUbRight = maxsubArrayRe(nums, center + 1,right);</span><br><span class="line">    </span><br><span class="line">    return max(max(maxSUbRight,maxSubLeft),maxLeft + maxRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ol>
<li>时间复杂度O(NlogN)。</li>
</ol>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol>
<li>贪心算法中，一边累加一边记录最大值，通过这样的方式而不会错过可能的最大值。我开始想的是如何确定起点和终点，想通过舍弃头尾部分获取中间部分的方式来解题，分析出舍弃的条件是累加值少于0，就是对中间部分为负增益。这个思路也许可行，但我没搞出来。而DP，就是要分析规律，关注于步骤与步骤之间的共性，得出dp方程，通过代码实现思路。分治方法中，注意的是中心向两边扩散才能正确的计算跨越左右两边之和。递归中必不可少的是，退出递归条件，上下层递归之间的联系交互是如何的（每一轮都计算出当前范围中跨越左右两边的最大值，而下一轮递归中他会计算出，左边的最大值和右边的最大值），是否涵盖是全部情况。如果采用二分法，因为是分割了范围，那么本轮处理中需要保证那些跨越切割范围的情况。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-07-07-01leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-07-07-01leetcode.html" itemprop="url">算法-Z字形变换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-07T00:00:00+08:00">
                2018-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/blog/" itemprop="url" rel="index">
                    <span itemprop="name">blog</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-07-07-01leetcode.html" class="leancloud_visitors" data-flag-title="算法-Z字形变换">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,228
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure></p>
<p>之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR”</p>
<p>实现一个将字符串进行指定行数变换的函数:</p>
<p>string convert(string s, int numRows);<br>示例 1:</p>
<p>输入: s = “PAYPALISHIRING”, numRows = 3<br>输出: “PAHNAPLSIIGYIR”<br>示例 2:</p>
<p>输入: s = “PAYPALISHIRING”, numRows = 4<br>输出: “PINALSIGYAHRPI”<br>解释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p>
<h4 id="思路1：按行排序"><a href="#思路1：按行排序" class="headerlink" title="思路1：按行排序"></a>思路1：按行排序</h4><ol>
<li>题目要求有两个，一个是字符是按Z字形排序，一个由上而下按行输出。</li>
<li>分析下Z字形的排序规律。z字形先是由上而下，到了底部再向上，每到底部或者顶部就会反弹，程序中使用bool变量lineUp记录方向。遍历字符的同时，使用一个二维数组int a[row][strlen(s)]来存储行与元素原始下标的关系。遍历完毕后，按行拼接字符串并输出。</li>
<li><p>元素的下标与输出后所在的行有这样的对应关系。</p>
<pre><code>#row #数字对应元素下标。
 0   0P      6I       12N
 1   1A   5L 7S   11I 13G
 2   2Y 4A   8H 10R
 3   3P      9I     
</code></pre></li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">char* convert(char* s, int numRows) &#123;</span><br><span class="line">if (numRows == 1) &#123;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool lineUp = true;</span><br><span class="line">int len = strlen(s);</span><br><span class="line">//记录字符的二维数组。其实可以使用int的二维数组，因为字符能自动转成asscii对应的int数字。</span><br><span class="line">char **pArr = (char**)malloc(sizeof(char*) * numRows);</span><br><span class="line"></span><br><span class="line">//这个数组是为了记录当前行最大下标，用于后面遍历。其实可以不用，在记录字符串的时候末尾添加&apos;\0&apos;用于判断就行。</span><br><span class="line">int *indexArr = (int*)malloc(sizeof(int) * numRows);</span><br><span class="line">memset(indexArr, -1, sizeof(int) * numRows);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; numRows; i++ ) &#123;</span><br><span class="line">//开始的时候设置长度为len 。在leetcode上执行报超出内存限制。分析后改为len /2 + 1,因为两行的时候最多为len / 2 + 1；超过三行字符被分散到其他行行，也不会超过len /2 + 1。修改后执行通过。</span><br><span class="line">    char *a = (char*)malloc(sizeof(char*) * (len / 2 + 1));</span><br><span class="line">    memset(a, &apos;#&apos;, sizeof(char*) * (len / 2  + 1));</span><br><span class="line">    pArr[i] = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int j = 0;</span><br><span class="line">for (int i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">    int currentIndex = indexArr[j] + 1;</span><br><span class="line">    indexArr[j] = currentIndex;</span><br><span class="line">    pArr[j][currentIndex] = s[i];</span><br><span class="line">    if (lineUp) &#123;</span><br><span class="line">        if (j == numRows - 1) &#123;</span><br><span class="line">            j --;</span><br><span class="line">            lineUp = false;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (j == 0) &#123;</span><br><span class="line">            j ++;</span><br><span class="line">            lineUp = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p = (char*)malloc(sizeof(char*) * len);</span><br><span class="line">memset(p, 0, sizeof(char*) * len);</span><br><span class="line">int jj = 0;</span><br><span class="line">for (int ii = 0; ii &lt; numRows ; ii ++)&#123;</span><br><span class="line">    char *temp = pArr[ii];</span><br><span class="line">    for (int k = 0; k &lt;= indexArr[ii]; k++) &#123;</span><br><span class="line">        p[jj++] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">free(pArr);</span><br><span class="line">free(indexArr);</span><br><span class="line"></span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li>复杂度分析<ol>
<li>时间复杂度 O(n), n = strlen(s);</li>
<li>空间复杂度 O(n)。</li>
</ol>
</li>
</ol>
<h4 id="思路2：按行访问"><a href="#思路2：按行访问" class="headerlink" title="思路2：按行访问"></a>思路2：按行访问</h4><ol>
<li>这个是对字符输入的方式分析后得出的数学规律。首尾两行成等比关系，中间的行除了等比的位置填充元素外，另外还需要在等比距离倒退一定长度offset的位置填充，offset = currentRow。</li>
<li><p>代码</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">char* convert(char* s, int numRows) &#123;</span><br><span class="line">int len = strlen(s);</span><br><span class="line">//特殊情况特殊处理</span><br><span class="line">if (len == 0 || numRows == 0 || numRows == 1 || numRows == len)</span><br><span class="line">&#123;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p = (char*)malloc(sizeof(char) * len);</span><br><span class="line">//等比间隔</span><br><span class="line">int cycleLen = 2 * numRows - 2;</span><br><span class="line">int pIndex = 0;</span><br><span class="line">for (int i = 0 ; i &lt; numRows; i ++) &#123;</span><br><span class="line">    for (int j = 0; j + i &lt; len ; j += cycleLen) &#123;</span><br><span class="line">        //获取等比位置的字符</span><br><span class="line">        p[pIndex ++] = s[i + j];</span><br><span class="line">        //获取中间行非等比位置的字符</span><br><span class="line">        if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp;  j + cycleLen - i &lt; len) &#123;</span><br><span class="line">            p[pIndex ++] = s[ j + cycleLen - i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
<li><p>复杂度分析</p>
<ol>
<li>时间复杂度 O(n), n = strlen(s);</li>
<li>空间复杂度 O(n)。如果返回字符不视为额外空间，那么空间复杂度为O(1)。</li>
</ol>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol>
<li>这道题开始也是用分析规律的方法去做，但举的例子少了点，写出来运行才发现规律是错的。后面也就没继续找数学规律。 为了避免下次犯错，找规律需要论证不少于3个例子。同时规律需要分情况讨论，例如该题的首尾两行作为一类，中间行作为一类。另外别想着用简单的规律就能处理全部问题，一般这类问题都是二级或者多级的，例如多种情况对应不同的规律，或者同一个规律要处理的多个问题。还有如果一类问题按一定方式呈现，一般会存在规律。</li>
<li>注意的地方：二维数组初始化问题；meset的使用；字符串、ASCII码、int之间的关系等。</li>
<li>部分代码可以写的更简洁，但为了更好的描述过程，暂时还是保持这个风格，有利于学习和理解。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-06-07-01-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-06-07-01-leetcode.html" itemprop="url">算法-两最长回文子串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-01T00:00:00+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-06-07-01-leetcode.html" class="leancloud_visitors" data-flag-title="算法-两最长回文子串">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  828
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>暴力法。2层循环嵌套，遍历所有子串。在判断子串是否为回文并对比保存最大的起止下标。通过前后同时截取字符串对比的方式来判断子串是否为回文。如果相等，就向两边靠拢，直对比的下标相等并且值也相等位置。如果不相等，子串非回文。</li>
<li>中心扩展算法。回文字符串有一个特点，就是左右对称。如果是奇数长度的回文字符串，中间的字符作为对称点，如aba中的a。如果是偶数长度的回文字符串，会以中间两个字符作为对称点,如abba中的bb。那么比较的时候，找到中心点，两边扩展对比就可以了。直到打破对称，通过暂存的历史最长回文子串的起止坐标比对当前长度，如果当前子串的长度较大，更新起止坐标。由于存在奇偶两种长度，对应的中心点不一样，但两种模式都可能产生回问子串，所有匹配的时候两种模式都要进行匹配，并取同一个中心点的两种模式中长度更长的更新起止坐标，这个是编码时需要处理的细节问题。</li>
</ol>
<h4 id="编码细节问题"><a href="#编码细节问题" class="headerlink" title="编码细节问题"></a>编码细节问题</h4><p>1.为了获取最后的子串，需要通过暂存起止坐标startIndex、endIndex。<br>2.默认奇数匹配方式，通过判断当前元素与其后面的元素是否相等来决定是否满足偶数匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">char* longestPalindrome(char* s) &#123;</span><br><span class="line"></span><br><span class="line">    int startIndex = 0 ;</span><br><span class="line">    int endIndex = 0;</span><br><span class="line"></span><br><span class="line">    int len = strlen(s);</span><br><span class="line">    for (int i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">        int frontIndex = i ;</span><br><span class="line">        int nextIndex = i;</span><br><span class="line"></span><br><span class="line">        bool evenSerech = true;</span><br><span class="line">        //满足偶数匹配方式</span><br><span class="line">        if (s[i] == s[nextIndex + 1]) &#123;</span><br><span class="line">            evenSerech = true;</span><br><span class="line">        &#125;</span><br><span class="line">        while (frontIndex &gt; -1 &amp;&amp; nextIndex &lt; len &amp;&amp; s[frontIndex] == s[nextIndex]) &#123;</span><br><span class="line">            frontIndex --;</span><br><span class="line">            nextIndex ++;</span><br><span class="line">        &#125;</span><br><span class="line">        int current = --nextIndex  + 1 - ++frontIndex ;</span><br><span class="line">        if (current &gt; (endIndex + 1 - startIndex)) &#123;</span><br><span class="line">            startIndex = frontIndex;</span><br><span class="line">            endIndex = nextIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (evenSerech) &#123;</span><br><span class="line">            frontIndex = i ;</span><br><span class="line">            nextIndex = i + 1;</span><br><span class="line">            while (frontIndex &gt; -1 &amp;&amp; nextIndex &lt; len &amp;&amp; s[frontIndex] == s[nextIndex]) &#123;</span><br><span class="line">                frontIndex --;</span><br><span class="line">                nextIndex ++;</span><br><span class="line">            &#125;</span><br><span class="line">            int current = --nextIndex  + 1 -  ++frontIndex ;</span><br><span class="line">            if (current &gt; (endIndex + 1 - startIndex)) &#123;</span><br><span class="line">                startIndex = frontIndex;</span><br><span class="line">                endIndex = nextIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    char *p = (char*)malloc(sizeof(char*) * (endIndex + 1 - startIndex));</span><br><span class="line">    int j = 0;</span><br><span class="line">    for (int i = startIndex; i &lt;= endIndex; i ++) &#123;</span><br><span class="line">        p[j ++] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：需要认真的分析回文的特点，回文串分偶数长度与奇数长度两种情况（认真审题并分析题目所求,不能忽略了一些必要的点，这一点很重要，卡时间比较多的是想通过修改起止指针的位置来适配偶数的模式，发现怎么都不能同时适配奇偶两种情况，如果是两类情况不能简单的统一处理的话，要变回单独处理）。另外这题能反转字符串取相同子串的方法（有坑）、动态规划和Manacher 算法来处理，后面再学习学习。</p>
<p>待完善L(‘ω’)┘三└(‘ω’)｣….</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-06-30-01-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-06-30-01-leetcode.html" itemprop="url">算法-两个排序数组的中位数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-30T00:00:00+08:00">
                2018-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-06-30-01-leetcode.html" class="leancloud_visitors" data-flag-title="算法-两个排序数组的中位数">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,750
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>两个排序数组的中位数</p>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。</p>
<p>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">中位数是 2.0</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ol>
<li>中位数下标 （假设数组为arr，长度为len，下标范围[0 ,len - 1]）<ol>
<li>如果len % 2 = 1 （为奇数），那么中位数的值为arr[mindIndex = len /2] 。</li>
<li>如果len % 2 - 0 (为偶数)，那么中位数的值为(arr[len/2]+arr[len/2 - 1])/2.0的值的和的平均值。</li>
</ol>
</li>
<li>思路一：最简单的思路把两个有序数组合并成一个有序的数组，再通过规则1.获取中位数的值。优化：结合题目要求，只需要获取中位数的值，并不需要真的要把两个数组排序成一个有序数组。那么通过两数组间隔读取，下标后移，直到累加到位置为为len/2即可获取到结果。这里如何更快地把找到len/2的位置是效率的关键。</li>
<li>思路二：假定数组A、B、长度分别为Alen、Blen。那么排序后的新数组为C、Clen。Clen = (Alen + Blen + 1）/ 2。因为A和B都是有序的，如果C是由A和B的一部分元素组成的。那么可以想象，C必然是A左边一定长度为ALefPairLen和B的左边一定长度为BLeftPairLen的两部分组成.ALefPairLen和BLeftPairLen是联动关系，ALefPairLen + BLeftPairLen =  (Alen + Blen + 1）/ 2,一增一减，一减一增，总长度是固定的。然后为了获得中位数，只需要获取其中一个数组的用于合并那部分的末尾Index，或者index + 1 （index + 1 = LefPairLen） ；这就变成了一个查找指定下标的问题了。</li>
</ol>
<h4 id="继续思路二（切换到程序中的变量，便于理解）"><a href="#继续思路二（切换到程序中的变量，便于理解）" class="headerlink" title="继续思路二（切换到程序中的变量，便于理解）"></a>继续思路二（切换到程序中的变量，便于理解）</h4><ol>
<li><p>定义：<br>假定，A数组的用于合并的长度为i，，那么最后一个元素的下标为i-1，i为用于合并的最后一个元素的下一个元素的下标。B的数组的长度j = (Alen + Blen + 1）/ 2 - i,那么B数组的最后一个元素的下标为j-1，j为用于合并的最后一个元素的下一个元素的下标。</p>
</li>
<li><p>结束条件：<br>要获取合法的i值，需要满足 A[i -1 ] &lt;= B[j] &amp;&amp; A[j] &gt;= B[j -1]；<br>如果leftPairA的最后一个元素少于leftPairB在原数组中最后一个元素的下一个元素，那么leftPairA是符合要求的。反过来B数组也一样。要达到在leftPairA和leftPairB右边的元素都比这两部分大，不然就需要继续调整。</p>
</li>
<li><p>特殊情况：代码注释中记录。</p>
</li>
<li>数的获取：<br>因为取长度的时候为halfLen = (Alen + Blen + 1）/ 2。如果总长度为奇数，最后一位就是中位fmax(a[i-1],B[j-1])。如果总长度为偶数，需要取处于中间的两个数，最后一位(fmax(a[i-1],B[j-1])为左边的一个，右边一个为halfLen之外的fmin(A[i],B[j]))。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) &#123;</span><br><span class="line">    int* A = nums1;</span><br><span class="line">    int* B = nums2;</span><br><span class="line">    int m = nums1Size;</span><br><span class="line">    int n = nums2Size;</span><br><span class="line">    </span><br><span class="line">    if (m &gt; n ) &#123;</span><br><span class="line">        int* tmp = A;</span><br><span class="line">        A = B;</span><br><span class="line">        B = tmp;</span><br><span class="line">        int k = m;</span><br><span class="line">        m = n;</span><br><span class="line">        n = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int iMin = 0;</span><br><span class="line">    int iMax = m;</span><br><span class="line">    //halfLen 偶数等于实际的一半，奇数等于向上取整</span><br><span class="line">    int halfLen = (m + n + 1) / 2 ;</span><br><span class="line">    </span><br><span class="line">    while (iMin &lt;= iMax) &#123;</span><br><span class="line">        //偶数index[i-1 , i ],奇数[i]</span><br><span class="line">        int i = (iMin + iMax) /2;</span><br><span class="line">        //长度之外的第一个元素</span><br><span class="line">        int j = halfLen - i;</span><br><span class="line">        if (i &lt; iMax &amp;&amp; A[i] &lt; B[j - 1] )</span><br><span class="line">        &#123;</span><br><span class="line">            //太小了，下限提高</span><br><span class="line">            iMin = iMin + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( i &gt; iMin &amp;&amp; A[i- 1] &gt; B[j]) &#123;</span><br><span class="line">            //太大了,上限降低</span><br><span class="line">            iMax = iMax - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            //满足需求 (A[i - 1] &lt; B[j] &amp;&amp; A[i] &gt; B[j - 1]) || i == 0 || j == 0 || i == m || j == n</span><br><span class="line">            int leftMax = 0;</span><br><span class="line">            //m &gt; n</span><br><span class="line">            if (i == 0) &#123;</span><br><span class="line">                //在A被选中的长度为0</span><br><span class="line">                leftMax = B[j - 1];</span><br><span class="line">            &#125;else if (j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //在B中被选中的长度为0</span><br><span class="line">                leftMax = A[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //i = m;代表A数组都被选中</span><br><span class="line">                //j = n;代表整个B数组都被选中</span><br><span class="line">                //包含 j == n || i == m 的情况</span><br><span class="line">                leftMax = fmax(A[i - 1], B[j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if ((m + n) % 2 == 1) &#123;</span><br><span class="line">                return leftMax;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            int rightMin = 0;</span><br><span class="line">            if (i == m)</span><br><span class="line">            &#123;</span><br><span class="line">                //A全部被选中。那么总长度为偶数时，中位数为中间两数的平均值，选中的最后一个数为leftMax，rightMin为hanlflen之外的第一个数B[j]；</span><br><span class="line">                rightMin = B[j];</span><br><span class="line">            &#125;else if (j == n)</span><br><span class="line">            &#123;</span><br><span class="line">                //B全部被选中。那么总长度为偶数时，中位数为中间两数的平均值，选中的最后一个数为leftMax，rightMin为hanlflen之外的第一个数A[j]；</span><br><span class="line">                rightMin = A[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //包含j == 0 || i == 0 的情况</span><br><span class="line">                rightMin = fmin(A[i], B[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return (leftMax + rightMin) / 2.0 ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//另外一种效率不错的解法</span><br><span class="line">double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) &#123;</span><br><span class="line">    int* A = nums1;</span><br><span class="line">    int* B = nums2;</span><br><span class="line">    int m = nums1Size;</span><br><span class="line">    int n = nums2Size;</span><br><span class="line">    </span><br><span class="line">    if (m &lt; n ) &#123;</span><br><span class="line">        int* tmp = A;</span><br><span class="line">        A = B;</span><br><span class="line">        B = tmp;</span><br><span class="line">        int k = m;</span><br><span class="line">        m = n;</span><br><span class="line">        n = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int iMin = 0;</span><br><span class="line">    int iMax = m;</span><br><span class="line">    int halfLen = (m + n + 1) / 2 ;</span><br><span class="line">    </span><br><span class="line">    while (iMin &lt;= iMax) &#123;</span><br><span class="line">        //偶数index[i-1 , i ],奇数[i]</span><br><span class="line">        int i = (iMin + iMax) /2;</span><br><span class="line">        //长度之外的第一个元素</span><br><span class="line">        int j = halfLen - i;</span><br><span class="line">        if ( A[i- 1] &gt; B[j] &amp;&amp; i &gt; iMin ) &#123;</span><br><span class="line">            //太大了,上限降低</span><br><span class="line">            iMax = iMax - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (A[i] &lt; B[j - 1] &amp;&amp; i &lt; iMax)</span><br><span class="line">        &#123;</span><br><span class="line">            //太小了，下限提高</span><br><span class="line">            iMin = iMin + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            //满足需求 A[i - 1] &lt; B[j] &amp;&amp; A[i] &gt; B[j - 1]</span><br><span class="line">            int leftMax = 0;</span><br><span class="line">            //m &gt; n</span><br><span class="line">            if (i == 0) &#123;</span><br><span class="line">                //在A中无法找到符合的数值</span><br><span class="line">                leftMax = B[j - 1];</span><br><span class="line">            &#125;else if (j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //在B中无法找到符合的数值</span><br><span class="line">                leftMax = A[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //包含 j == n || i == m 的情况</span><br><span class="line">                leftMax = fmax(A[i - 1], B[j - 1]);</span><br><span class="line">                if ((m + n) % 2 == 1) &#123;</span><br><span class="line">                    return leftMax;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            int rightMin = 0;</span><br><span class="line">             if (i == m)</span><br><span class="line">            &#123;</span><br><span class="line">                rightMin = B[j];</span><br><span class="line">            &#125;else if (j == n)</span><br><span class="line">            &#123;</span><br><span class="line">                rightMin = A[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //包含j == 0 || i == 0 的情况</span><br><span class="line">                rightMin = fmin(A[i], B[j]);</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">            return (leftMax + rightMin) / 2.0 ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结:这道理题要处理的细节比较多。切割长度halfLen = (m + n + 1) / 2，最后一位是哪一位，是刚好是中位数呢，还是中位数左移一位，还是右移一位呢。这个会影响到后面的中位数下标取值。还要搞懂每个临界条件代表的意义。总的来说如果每一句代码都是必须的，那么必然要做到对代码的含义了然于心，才能保证程序的正确性。对的思路+对的编码 = 对的答案。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-06-28-01-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-06-28-01-leetcode.html" itemprop="url">算法-两数相加</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T00:00:00+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-06-28-01-leetcode.html" class="leancloud_visitors" data-flag-title="算法-两数相加">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  357
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>/*<br> 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。<br> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p> 示例：<br> 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br> 输出：7 -&gt; 0 -&gt; 8<br> 原因：342 + 465 = 807</p>
<p> */</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    struct ListNode* l3 = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">    struct ListNode* n1 = l1;</span><br><span class="line">    struct ListNode* n2 = l2;</span><br><span class="line">    struct ListNode* n3 = l3;</span><br><span class="line">    int carry = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        int c1 = 0;</span><br><span class="line">        int c2 = 0;</span><br><span class="line">        if (n1 != NULL) &#123;</span><br><span class="line">            c1 = n1-&gt;val;</span><br><span class="line">            n1 = n1 -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n2 != NULL) &#123;</span><br><span class="line">            c2 = n2-&gt;val;</span><br><span class="line">            n2 = n2 -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = c1 + c2 + carry;</span><br><span class="line">        carry = sum /10;</span><br><span class="line">        int currentValue = sum % 10;</span><br><span class="line">        n3-&gt;val = currentValue;</span><br><span class="line">        //考虑进位有值得情况需要进入下一个循环</span><br><span class="line">        if(n1 != NULL || n2 != NULL || carry)</span><br><span class="line">        &#123;</span><br><span class="line">            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">            n3-&gt;next = newNode;</span><br><span class="line">            n3 = n3 -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">        //最后一个节点为NULL</span><br><span class="line">            n3 -&gt;next = NULL;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    return l3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：面向过程的思路。<br>注意的几个问题：</p>
<ol>
<li>进位问题，低位相加得出进位值提供给高位计算。</li>
<li>最后一轮相加的时候可能会产生进位，这个时候需要进入下一轮循环，计算下一位的值。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-06-28-02-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-06-28-02-leetcode.html" itemprop="url">算法-无重复字符的最长子串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T00:00:00+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-06-28-02-leetcode.html" class="leancloud_visitors" data-flag-title="算法-无重复字符的最长子串">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  718
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p>
<p>示例：<br>给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。</p>
<p>给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。</p>
<p>给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列  而不是子串。</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ol>
<li>从字符串第一个元素起，从左到右获取子串。</li>
<li>每前进一个字符(下标为j)，就在当前子串中查找是否存在与当前字符重复的字符，如果存在(重复字符的下标为i)，那么能确定一个包含不重复字符的子串，其长度为j - i 对比已存储的最大长度并把两者的最大值存储。</li>
<li>现在下一个子串的起点为当前重复的字符下标j.重复执行2、3操作，直到最后一个字符。</li>
</ol>
<p>其实这是滑动窗口的思路。左闭右开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLongestSubstring(char* s) &#123;</span><br><span class="line">    int len = strlen(s);</span><br><span class="line">    //长度为0 的情况的处理</span><br><span class="line">    if(len == 0) return 0;</span><br><span class="line">    int max = 1;</span><br><span class="line">    int statrIndex = 0;</span><br><span class="line">    for (int i = 1; i &lt; len; i ++) &#123;</span><br><span class="line">        char subStr = s[i];</span><br><span class="line">        for(int j = statrIndex; j &lt;i; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            char ssubStr = s[j];</span><br><span class="line">            //如果找到重复字符串</span><br><span class="line">            if (subStr == ssubStr ) &#123;</span><br><span class="line">                if (max &lt; i  - statrIndex) &#123;</span><br><span class="line">                    max = i  - statrIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                statrIndex = j + 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //长度没添加一位，更新最大值</span><br><span class="line">        if (max &lt; i + 1 - statrIndex) &#123;</span><br><span class="line">            max = i + 1 - statrIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//每个字符都有唯一字符串ASCII的作为唯一标识，这是个技巧性问题。最多256个</span><br><span class="line">int lengthOfLongestSubstring(char* s) &#123;</span><br><span class="line">    //算法：用book标记出现过的字符的index，用max标记最大长度，用start标记当前不重复开始的index，用num表示当前不重复的个数</span><br><span class="line">    //遍历数组，若book[]大于start，说明遇到相同元素，则从其相同处重新计算长度和起始位置</span><br><span class="line">    if(NULL == s)</span><br><span class="line">        return NULL;</span><br><span class="line">    int len=strlen(s);</span><br><span class="line">    int book[255]=&#123;0&#125;;</span><br><span class="line">    //memset(book,0xff,255*sizeof(int));//将book初始化为-1</span><br><span class="line">    if (0==len)</span><br><span class="line">        return 0;</span><br><span class="line">    int start=0,max=0;//max_start=0;</span><br><span class="line">    int num=0;</span><br><span class="line">    for (int i=0;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(book[s[i]]==0 || book[s[i]]&lt;start+1)</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            if(num&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                //max_start=start;</span><br><span class="line">                max=num;</span><br><span class="line">            &#125;</span><br><span class="line">            book[s[i]]=i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            start=book[s[i]];</span><br><span class="line">            num=i-start+1;</span><br><span class="line">            book[s[i]]=i+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//写得好屌啊</span><br><span class="line">int lengthOfLongestSubstring(char* s) &#123;</span><br><span class="line">    int len=0;</span><br><span class="line">    char *end=s,*temp;</span><br><span class="line">    char* addressTable[128]=&#123;NULL&#125;;</span><br><span class="line">    while(*end)&#123;</span><br><span class="line">        temp = addressTable[*end];</span><br><span class="line">        addressTable[*end]=end;</span><br><span class="line">        if(temp&gt;=s)&#123;</span><br><span class="line">        len=end-s&gt;len?end-s:len;</span><br><span class="line">        s = temp+1;</span><br><span class="line">        &#125;end++;</span><br><span class="line">    &#125;</span><br><span class="line">    len=end-s&gt;len?end-s:len;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：这里又存在查找问题，可以考虑使用哈希Map提高效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-06-27-01-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-06-27-01-leetcode.html" itemprop="url">算法-两数之和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-27T00:00:00+08:00">
                2018-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-06-27-01-leetcode.html" class="leancloud_visitors" data-flag-title="算法-两数之和">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  668
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p>
</blockquote>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<pre><code>示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="line"> */</span><br><span class="line"> //面向过程的解法；这是最直接的思路。</span><br><span class="line">int* twoSum(int* nums, int numsSize, int target) &#123;</span><br><span class="line">    int *a=(int *)malloc(2*sizeof(int));</span><br><span class="line">    //外层index从0开始遍历</span><br><span class="line">    int index = 0;</span><br><span class="line">    while (index &lt; numsSize - 1) &#123;</span><br><span class="line">    //内层从外层当前下标index的下一个元素开始遍历即i= index + 1</span><br><span class="line">        int i = index + 1;</span><br><span class="line">        while (i &lt; numsSize) &#123;</span><br><span class="line">        //判断两个元素之和是否等于target,如果相等，保存值并返回。</span><br><span class="line">            if (*(nums + i) + *(nums + index) == target) &#123;</span><br><span class="line">                *(a + 0)= index;</span><br><span class="line">                *(a + 1) = i;</span><br><span class="line">                return a;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        index ++;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//思路升级</span><br><span class="line">//c++ 哈希map  空间换时间</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int,int&gt; valueMap;</span><br><span class="line">        for (int i = 0 ; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            int searchValue = target - nums[i];</span><br><span class="line">            map&lt;int,int&gt;::iterator it ;</span><br><span class="line">            //通过value查找是否存在，该操作时间复杂度为O(1);</span><br><span class="line">            it = valueMap.find(searchValue);</span><br><span class="line">            if (it != valueMap.end()) &#123;</span><br><span class="line">                vector&lt;int&gt; collect;</span><br><span class="line">                collect.push_back(valueMap[searchValue]);</span><br><span class="line">                collect.push_back(i);</span><br><span class="line">                return collect;</span><br><span class="line">            &#125;</span><br><span class="line">            valueMap.insert(pair&lt;int, int&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; collect;</span><br><span class="line">        return collect; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>小结：</p>
<ol>
<li>该题难度不大，直接使用面向过程的方法就能求解。</li>
<li>该问题步骤分解中，因为已知和以及其中一个加数求另外一个加数，转换到程序中就是一个查找的问题-&gt;一个已知集合查找特定值得问题.</li>
</ol>
<p>一个已知集合查找特定值得问题，会直接导致两种思路：</p>
<ol>
<li>遍历查找-&gt;优化遍历方法</li>
<li>空间换时间-&gt;哈希查找(这里会产生一种数据结构，它会把一个数值和数值的索引存储【起到存储的作用】，并能快速通过索引查找到对应的数值。另外由于不存在相同索引，所以可以【存储同一索引最后状态的值】,这个性质可以对某类问题做优化，例如最长不重复字符子串问题，通过值替换能保存相同字符的最后位置j(当前位置)，假设被替换前的值为i ，那么当前子串长度len = j - i )。</li>
</ol>
<p>思维路线：<br>-&gt;常规思路是否可解；<br>-&gt;是否存查找问题-&gt;是否可以使用空间换时间(哈希查找，备忘录等)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-06-22-01.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-06-22-01.html" itemprop="url">ffmpeg iOS平台编译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-22T00:00:00+08:00">
                2018-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ffmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">ffmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-06-22-01.html" class="leancloud_visitors" data-flag-title="ffmpeg iOS平台编译">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,232
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、编译过程"><a href="#一、编译过程" class="headerlink" title="一、编译过程"></a>一、编译过程</h3><ul>
<li>1.下载源码</li>
<li>2.预先编译作为插件的库fdk-aac，x264等。</li>
<li>3.安装yasm</li>
<li>4.安装编译工具</li>
<li>5.编写脚本</li>
<li>6.执行脚本<br><img src="https://upload-images.jianshu.io/upload_images/1690665-644b8174001f2013.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ffmpeg-ios流程.png"></li>
</ul>
<h3 id="二、脚本注解-包含fdk-x264库的集成，如果不包含编译，需要移除configure相关编译参数"><a href="#二、脚本注解-包含fdk-x264库的集成，如果不包含编译，需要移除configure相关编译参数" class="headerlink" title="二、脚本注解(包含fdk,x264库的集成，如果不包含编译，需要移除configure相关编译参数)"></a>二、脚本注解(包含fdk,x264库的集成，如果不包含编译，需要移除configure相关编译参数)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># directories</span><br><span class="line">#赋值源码版本</span><br><span class="line">SOURCE=&quot;ffmpeg-4.0.1&quot;</span><br><span class="line">#FAT文件夹名称</span><br><span class="line">FAT=&quot;FFmpeg-iOS&quot;</span><br><span class="line">#文件夹名称</span><br><span class="line">SCRATCH=&quot;scratch&quot;</span><br><span class="line"># must be an absolute path</span><br><span class="line">#THIN路径</span><br><span class="line">THIN=`pwd`/&quot;thin&quot;</span><br><span class="line">#架构类型数组</span><br><span class="line">ARCHS=&quot;arm64 armv7&quot;</span><br><span class="line"></span><br><span class="line"># absolute path to x264 library</span><br><span class="line">X264=`pwd`/x264-ios</span><br><span class="line"></span><br><span class="line"># absolute path to fdk-aac library</span><br><span class="line">FDK_AAC=`pwd`/fdk-aac-ios</span><br><span class="line"></span><br><span class="line">#编译选项</span><br><span class="line">CONFIGURE_FLAGS=&quot;--enable-gpl --disable-shared --disable-stripping --disable-ffmpeg --disable-ffplay  --disable-ffprobe --disable-avdevice --disable-indevs --disable-filters --disable-devices --disable-parsers --disable-postproc --disable-debug --disable-asm --disable-yasm --disable-doc --disable-bsfs --disable-muxers --disable-demuxers --disable-ffplay --disable-ffprobe  --disable-indevs --disable-outdevs --enable-cross-compile --enable-filter=aresample --enable-bsf=aac_adtstoasc --enable-small --enable-dct --enable-dwt --enable-lsp --enable-mdct --enable-rdft --enable-fft --enable-static --enable-version3 --enable-nonfree --disable-encoders --enable-encoder=pcm_s16le --enable-encoder=aac --enable-encoder=libx264 --enable-encoder=mp2 --disable-decoders --enable-decoder=aac --enable-decoder=mp3 --enable-decoder=h264 --enable-decoder=pcm_s16le --disable-parsers --enable-parser=aac --enable-parser=mpeg4video --enable-parser=mpegvideo --enable-parser=mpegaudio --enable-parser=aac --disable-muxers --enable-muxer=flv --enable-muxer=mp4 --enable-muxer=wav --enable-muxer=adts --disable-demuxers --enable-demuxer=flv --enable-demuxer=mpegvideo --enable-demuxer=mpegtsraw --enable-demuxer=mpegts --enable-demuxer=mpegps --enable-demuxer=h264 --enable-demuxer=y4m --enable-demuxer=wav --enable-demuxer=aac --enable-demuxer=hls --enable-demuxer=mov --enable-demuxer=m4v --disable-protocols --enable-protocol=rtmp --enable-protocol=http --enable-protocol=file --enable-libx264 --enable-libfdk-aac --enable-libfdk_aac --enable-encoder=libfdk_aac&quot;</span><br><span class="line"></span><br><span class="line">COMPILE=&quot;y&quot;</span><br><span class="line">LIPO=&quot;y&quot;</span><br><span class="line"></span><br><span class="line">#支持的iOS最低版本</span><br><span class="line">DEPLOYMENT_TARGET=&quot;8.0&quot;</span><br><span class="line"></span><br><span class="line">#赋值部分结束</span><br><span class="line"></span><br><span class="line">if [ &quot;$*&quot; ]</span><br><span class="line">then</span><br><span class="line">    if [ &quot;$*&quot; = &quot;lipo&quot; ]</span><br><span class="line">    then</span><br><span class="line">        # skip compile</span><br><span class="line">        COMPILE=</span><br><span class="line">    else</span><br><span class="line">        ARCHS=&quot;$*&quot;</span><br><span class="line">        if [ $# -eq 1 ]</span><br><span class="line">        then</span><br><span class="line">            # skip lipo</span><br><span class="line">            LIPO=</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$COMPILE&quot; ]</span><br><span class="line">then</span><br><span class="line">#是否安装yasm，x86汇编反汇编器 支持16位、32位、64位</span><br><span class="line">    if [ ! `which yasm` ]</span><br><span class="line">    then</span><br><span class="line">        echo &apos;Yasm not found&apos;</span><br><span class="line">        #是否安装brew软件包管理工具</span><br><span class="line">        if [ ! `which brew` ]</span><br><span class="line">        then</span><br><span class="line">            echo &apos;Homebrew not found. Trying to install...&apos;</span><br><span class="line">                        ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; \</span><br><span class="line">                || exit 1</span><br><span class="line">        fi</span><br><span class="line">        echo &apos;Trying to install Yasm...&apos;</span><br><span class="line">        brew install yasm || exit 1</span><br><span class="line">    fi</span><br><span class="line">    #是否已经安装ffmpeg编译工具</span><br><span class="line">    if [ ! `which gas-preprocessor.pl` ]</span><br><span class="line">    then</span><br><span class="line">        echo &apos;gas-preprocessor.pl not found. Trying to install...&apos;</span><br><span class="line">        (curl -L https://github.com/libav/gas-preprocessor/raw/master/gas-preprocessor.pl \</span><br><span class="line">            -o /usr/local/bin/gas-preprocessor.pl \</span><br><span class="line">            &amp;&amp; chmod +x /usr/local/bin/gas-preprocessor.pl) \</span><br><span class="line">            || exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if [ ! -r $SOURCE ]</span><br><span class="line">    then</span><br><span class="line">        echo &apos;FFmpeg source not found. Trying to download...&apos;</span><br><span class="line">        #尝试下载对于的ffmpeg源码并解压，如果失败就退出</span><br><span class="line">        curl http://www.ffmpeg.org/releases/$SOURCE.tar.bz2 | tar xj \</span><br><span class="line">            || exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">#赋值当前路径</span><br><span class="line">    CWD=`pwd`</span><br><span class="line">    #遍历需要编译的架构</span><br><span class="line">    for ARCH in $ARCHS</span><br><span class="line">    do</span><br><span class="line">        echo &quot;building $ARCH...&quot;</span><br><span class="line">        #创建/scratch/$ARCH目录</span><br><span class="line">        mkdir -p &quot;$SCRATCH/$ARCH&quot;</span><br><span class="line">        #进入目录</span><br><span class="line">        cd &quot;$SCRATCH/$ARCH&quot;</span><br><span class="line"></span><br><span class="line">        CFLAGS=&quot;-arch $ARCH&quot;</span><br><span class="line">        if [ &quot;$ARCH&quot; = &quot;i386&quot; -o &quot;$ARCH&quot; = &quot;x86_64&quot; ]</span><br><span class="line">        then</span><br><span class="line">        #如果是模拟器</span><br><span class="line">            PLATFORM=&quot;iPhoneSimulator&quot;</span><br><span class="line">            #编译参数 最低系统版本</span><br><span class="line">            CFLAGS=&quot;$CFLAGS -mios-simulator-version-min=$DEPLOYMENT_TARGET&quot;</span><br><span class="line">        else</span><br><span class="line">            #如果是真机</span><br><span class="line">            PLATFORM=&quot;iPhoneOS&quot;</span><br><span class="line">            CFLAGS=&quot;$CFLAGS -mios-version-min=$DEPLOYMENT_TARGET&quot;</span><br><span class="line">            if [ &quot;$ARCH&quot; = &quot;arm64&quot; ]</span><br><span class="line">            then</span><br><span class="line">                EXPORT=&quot;GASPP_FIX_XCODE5=1&quot;</span><br><span class="line">            fi</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        #PLATFORM变量转换为小写并赋值给XCRUN_SDK</span><br><span class="line">        XCRUN_SDK=`echo $PLATFORM | tr &apos;[:upper:]&apos; &apos;[:lower:]&apos;`</span><br><span class="line">        CC=&quot;xcrun -sdk $XCRUN_SDK clang&quot;</span><br><span class="line">        CXXFLAGS=&quot;$CFLAGS&quot;</span><br><span class="line">        LDFLAGS=&quot;$CFLAGS&quot;</span><br><span class="line">        if [ &quot;$X264&quot; ]</span><br><span class="line">        then</span><br><span class="line">        #指定头文件路径</span><br><span class="line">            CFLAGS=&quot;$CFLAGS -I$X264/include&quot;</span><br><span class="line">            #指定库路径</span><br><span class="line">            LDFLAGS=&quot;$LDFLAGS -L$X264/lib&quot;</span><br><span class="line">        fi</span><br><span class="line">        if [ &quot;$FDK_AAC&quot; ]</span><br><span class="line">        then</span><br><span class="line">            CFLAGS=&quot;$CFLAGS -I$FDK_AAC/include&quot;</span><br><span class="line">            LDFLAGS=&quot;$LDFLAGS -L$FDK_AAC/lib&quot;</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        #修改configure编译参数</span><br><span class="line">        TMPDIR=$&#123;TMPDIR/%\/&#125; $CWD/$SOURCE/configure \</span><br><span class="line">            --target-os=darwin \</span><br><span class="line">            --arch=$ARCH \</span><br><span class="line">            --cc=&quot;$CC&quot; \</span><br><span class="line">            $CONFIGURE_FLAGS \</span><br><span class="line">            --extra-cflags=&quot;$CFLAGS&quot; \</span><br><span class="line">            --extra-ldflags=&quot;$LDFLAGS&quot; \</span><br><span class="line">            --prefix=&quot;$THIN/$ARCH&quot; \</span><br><span class="line">        || exit 1</span><br><span class="line">        #清除之前编译的可执行文件及配置文件。 </span><br><span class="line">        echo &apos;build-ffmpeg:make clean&apos;</span><br><span class="line">        make clean</span><br><span class="line">        echo &apos;build-ffmpeg:make&apos;</span><br><span class="line">        #make || exit 1</span><br><span class="line">        echo &apos;build-ffmpeg:make install&apos;</span><br><span class="line">        #make install $EXPORT || exit 1</span><br><span class="line">        make -j3 install $EXPORT || exit 1</span><br><span class="line">        cd $CWD</span><br><span class="line">    done</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ &quot;$LIPO&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;building fat binaries...&quot;</span><br><span class="line">    mkdir -p $FAT/lib</span><br><span class="line">    set - $ARCHS</span><br><span class="line">    CWD=`pwd`</span><br><span class="line">    cd $THIN/$1/lib</span><br><span class="line">    for LIB in *.a</span><br><span class="line">    do</span><br><span class="line">        cd $CWD</span><br><span class="line">        echo lipo -create `find $THIN -name $LIB` -output $FAT/lib/$LIB 1&gt;&amp;2</span><br><span class="line">        #合并.a库</span><br><span class="line">        lipo -create `find $THIN -name $LIB` -output $FAT/lib/$LIB || exit 1</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    cd $CWD</span><br><span class="line">    cp -rf $THIN/$1/include $FAT</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo Done</span><br></pre></td></tr></table></figure>
<h3 id="三、相关命令"><a href="#三、相关命令" class="headerlink" title="三、相关命令"></a>三、相关命令</h3><table>
<thead>
<tr>
<th>命令/参数</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>which</td>
<td>查看可执行文件的位置</td>
</tr>
<tr>
<td>curl</td>
<td>下载相关资源</td>
</tr>
<tr>
<td>tar xj</td>
<td>解压相关资源</td>
</tr>
<tr>
<td>make</td>
<td>对源代码包进行编译</td>
</tr>
<tr>
<td>make install</td>
<td>安装编译后的代码包</td>
</tr>
<tr>
<td>configure</td>
<td>生成makefile文件，并可在后面指定相关编译选项</td>
</tr>
</tbody>
</table>
<h4 id="configure-编译选项，可用-configure-–help查看"><a href="#configure-编译选项，可用-configure-–help查看" class="headerlink" title="configure 编译选项，可用 ./configure –help查看"></a>configure 编译选项，可用 ./configure –help查看</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明 [默认]</th>
</tr>
</thead>
<tbody>
<tr>
<td>–target-os</td>
<td>compiler targets OS []</td>
</tr>
<tr>
<td>–prefix=PREFIX</td>
<td>install in PREFIX [/usr/local]</td>
</tr>
<tr>
<td>–cc=CC</td>
<td>use C compiler CC [gcc]</td>
</tr>
<tr>
<td>–extra-cflags=ECFLAGS</td>
<td>指定头文件路径 add ECFLAGS to CFLAGS []</td>
</tr>
<tr>
<td>–extra-ldflags=ELDFLAGS</td>
<td>指定库文件路径 add ELDFLAGS to LDFLAGS []</td>
</tr>
</tbody>
</table>
<p>参考：<br>configure/make/make install的作用<br><a href="https://www.linuxidc.com/Linux/2011-02/32211.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2011-02/32211.htm</a></p>
<p>CFLAGS LDFLAGS详解<br><a href="https://blog.csdn.net/xinyuan510214/article/details/50457433" target="_blank" rel="noopener">https://blog.csdn.net/xinyuan510214/article/details/50457433</a></p>
<p><a href="https://blog.csdn.net/shenhuxi_yu/article/details/79788760" target="_blank" rel="noopener">https://blog.csdn.net/shenhuxi_yu/article/details/79788760</a></p>
<p><a href="https://www.jianshu.com/p/e590f041c5f6" target="_blank" rel="noopener">https://www.jianshu.com/p/e590f041c5f6</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-05-12-01.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-05-12-01.html" itemprop="url">iOS 指纹解锁 检测指纹信息变更</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T00:00:00+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/blog/" itemprop="url" rel="index">
                    <span itemprop="name">blog</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-05-12-01.html" class="leancloud_visitors" data-flag-title="iOS 指纹解锁 检测指纹信息变更">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,303
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通过LAContext evaluatedPolicyDomainState属性可以获取到当前data类型的指纹信息数据，当指纹增加或者删除，该data就会发生变化，通过记录这个TouchIdData与最新的data做对比就能判断指纹信息是否变更，从而定制app功能。</p>
<h3 id="存在的疑问："><a href="#存在的疑问：" class="headerlink" title="存在的疑问："></a>存在的疑问：</h3><ol>
<li>TouchIdData可能为空吗？<br>官方文档说明：<blockquote>
<p>Discussion<br>This property returns a value only when the canEvaluatePolicy(<em>:error:) method succeeds for a biometric policy or the evaluatePolicy(</em>:localizedReason:reply:) method is called and a successful biometric authentication is performed. Otherwise, nil is returned.<br>只有当canEvaluatePolicy方法执行并返回YES或者evaluatePolicy执行并指纹识别通过，这个属性才能有值，否则为空。</p>
</blockquote>
</li>
<li>TouchIdData能否获取具体的指纹信息？<blockquote>
<p>The returned data is an opaque structure. It can be used to compare with other values returned by this property to determine whether the authorized database has been updated. However, the nature of the change cannot be determined from this data.<br>返回的数据是一个不透明的结构。它可以用来与此属性返回的其他值进行比较，以确定是否更新了授权数据库。然而，变化的性质不能从这些数据中确定。</p>
</blockquote>
</li>
</ol>
<ol start="3">
<li>在指纹信息没有修改的时候，不同app获取到的TouchIdData是一样的吗?<br>实测不同的app，在指纹没有变化的情况下TouchIdData是不一样的。但这个是不能打包票的，如果苹果修改了这部分的算法，返回一个相同值也是有可能的。</li>
</ol>
<ol start="4">
<li>添加一个新指纹，再删除刚添加的那个指纹，TouchIdData相对一轮操作之前变化了吗？<br>实测TouchIdData没有变化，也就是说TouchIdData是面向结果的，而不是面向过程的，只要最终结果指纹集合一样，TouchIdData就一样。</li>
</ol>
<p>代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">    static var IDENTIFY:String? = nil</span><br><span class="line">    static let SERVICE = &quot;TOUCHID_SERVICE&quot;</span><br><span class="line">    static let ACCOUNT_PREFIX = &quot;TOUCHID_PERFIX&quot;</span><br><span class="line">    open class func setCurrentTouchIdDataIdentity(identity:String )</span><br><span class="line">    &#123;</span><br><span class="line">        //设定当前身份用于存储data</span><br><span class="line">        TouchIdManager.IDENTIFY = identity</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">//获取当前时刻的data</span><br><span class="line">  class func currentOriTouchIdData() -&gt; Data?&#123;</span><br><span class="line">        let context = LAContext()</span><br><span class="line">        var error:NSError? = nil;</span><br><span class="line">//先使用canEvaluatePolicy方法进行评估</span><br><span class="line">        if context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &amp;error) &#123;</span><br><span class="line">            </span><br><span class="line">            return context.evaluatedPolicyDomainState</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;errorMsg:&quot; + self.errorMessageForFails(errorCode:(error?.code)! ))</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用keychain保存当前身份的data</span><br><span class="line">open class func setCurrentIdentityTouchIdData()-&gt; Bool</span><br><span class="line">    &#123;</span><br><span class="line">        if self.currentTouchIdDataIdentity() == nil</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if self.currentOriTouchIdData() != nil</span><br><span class="line">            &#123;</span><br><span class="line">                //storage by keychain</span><br><span class="line">                SAMKeychain.setPasswordData(self.currentOriTouchIdData()!, forService:SERVICE, account: ACCOUNT_PREFIX + self.currentTouchIdDataIdentity()!)</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取当前身份的上一次存储的data，用于对比</span><br><span class="line"> class func currentIdentityTouchIdData()-&gt;Data?</span><br><span class="line">    &#123;</span><br><span class="line">        guard (self.currentTouchIdDataIdentity() != nil) else &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return  SAMKeychain.passwordData(forService: TouchIdManager.SERVICE, account: TouchIdManager.ACCOUNT_PREFIX + self.currentTouchIdDataIdentity()!)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//检测以这个身份设置开始到当前时刻指纹信息是否变更</span><br><span class="line">open class func touchIdInfoDidChange()-&gt;Bool</span><br><span class="line">    &#123;</span><br><span class="line">        let data = self.currentOriTouchIdData()</span><br><span class="line">        if data == nil &amp;&amp; self.isErrorTouchIDLockout() &#123;</span><br><span class="line">            //lock after unlock failed many times,and the fingerprint is not changed.</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            let oldData = self.currentIdentityTouchIdData()</span><br><span class="line">            </span><br><span class="line">            if oldData == nil</span><br><span class="line">            &#123;</span><br><span class="line">                //never set</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">            else if oldData == data</span><br><span class="line">            &#123;</span><br><span class="line">                //not change</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//检测当前是否为biometryLockout状态</span><br><span class="line">    class func isErrorTouchIDLockout()-&gt;Bool</span><br><span class="line">    &#123;</span><br><span class="line">        let context = LAContext()</span><br><span class="line">        var error:NSError?</span><br><span class="line">        context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &amp;error)</span><br><span class="line">        </span><br><span class="line">        guard error != nil else &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if error!.code == LAError.biometryLockout.rawValue &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="指纹识别的两种LAPolicy："><a href="#指纹识别的两种LAPolicy：" class="headerlink" title="指纹识别的两种LAPolicy："></a>指纹识别的两种LAPolicy：</h3><ul>
<li>deviceOwnerAuthenticationWithBiometrics<br>这个类型不能弹出密码解锁界面，但能更精准的反馈用户操作的状态：如指纹识别三次失败等。</li>
<li>deviceOwnerAuthentication<br>对识别行为的结果做了简化，无法判断具体状态。但能弹出密码解锁界面。<br>结合两者可以使指纹解锁做的更友善一点。</li>
<li>最终效果[正常流程]：指纹识别错误三次回调失败-&gt;再点击再识别错误两次-&gt;弹出密码解锁界面-&gt;密码错误5次-&gt;锁定1分钟-&gt;再输错-&gt;锁定五分钟。</li>
</ul>
<p>代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">open class func showTouchId(title:String,fallbackTitle:String?, fallbackBlock:TouchIdFallBackBlokc?,resultBlock:TouchIdResultBlock?)</span><br><span class="line">   &#123;</span><br><span class="line">       let context = LAContext();</span><br><span class="line">       context.localizedFallbackTitle = fallbackTitle</span><br><span class="line">       var useableError:NSError?</span><br><span class="line">       if context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &amp;useableError) &#123;</span><br><span class="line">           context.evaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, localizedReason: title) &#123; (success, error) in</span><br><span class="line">               DispatchQueue.main.async &#123;</span><br><span class="line">                   if success</span><br><span class="line">                   &#123;</span><br><span class="line">                       if resultBlock != nil</span><br><span class="line">                       &#123;</span><br><span class="line">                           resultBlock!(true,success,error)</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   else</span><br><span class="line">                   &#123;</span><br><span class="line">                       guard let error = error else</span><br><span class="line">                       &#123;</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                       </span><br><span class="line">                       print(&quot;errorMsg:&quot; + self.errorMessageForFails(errorCode: error._code))</span><br><span class="line">                       </span><br><span class="line">                       if error._code == LAError.userFallback.rawValue</span><br><span class="line">                       &#123;</span><br><span class="line">                           if fallbackBlock != nil</span><br><span class="line">                           &#123;</span><br><span class="line">                               fallbackBlock!()</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       else if error._code == LAError.biometryLockout.rawValue</span><br><span class="line">                       &#123;</span><br><span class="line">                           //try to show password interface</span><br><span class="line">                           self.tryShowTouchIdOrPwdInterface(title: title, resultBlock: resultBlock)</span><br><span class="line">                       &#125;</span><br><span class="line">                       else</span><br><span class="line">                       &#123;</span><br><span class="line">                           if resultBlock != nil</span><br><span class="line">                           &#123;</span><br><span class="line">                               resultBlock!(true,success,error)</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       else</span><br><span class="line">       &#123;</span><br><span class="line">           print(&quot;errorMsg:&quot; + self.errorMessageForFails(errorCode:(useableError?.code)! ))</span><br><span class="line">           </span><br><span class="line">           if useableError?.code == LAError.biometryLockout.rawValue</span><br><span class="line">           &#123;</span><br><span class="line">               //try to show password interface</span><br><span class="line">               self.tryShowTouchIdOrPwdInterface(title: title, resultBlock: resultBlock)</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               if resultBlock != nil</span><br><span class="line">               &#123;</span><br><span class="line">                   resultBlock!(false,false,useableError)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   class func tryShowTouchIdOrPwdInterface(title:String,resultBlock:TouchIdResultBlock?)</span><br><span class="line">   &#123;</span><br><span class="line">       let context = LAContext();</span><br><span class="line">       context.localizedFallbackTitle = &quot;&quot;</span><br><span class="line">       var useableError:NSError?</span><br><span class="line">       if context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthentication, error: &amp;useableError) &#123;</span><br><span class="line">           context.evaluatePolicy(LAPolicy.deviceOwnerAuthentication, localizedReason: title) &#123; (success, error) in</span><br><span class="line">               </span><br><span class="line">               DispatchQueue.main.async &#123;</span><br><span class="line">                   if resultBlock != nil</span><br><span class="line">                   &#123;</span><br><span class="line">                       resultBlock!(true,success,error)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               guard let error = error else</span><br><span class="line">               &#123;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               print(&quot;errorMsg:&quot; + self.errorMessageForFails(errorCode: error._code))</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       else</span><br><span class="line">       &#123;</span><br><span class="line">           print(&quot;errorMsg:&quot; + self.errorMessageForFails(errorCode:(useableError?.code)! ))</span><br><span class="line">           </span><br><span class="line">           if resultBlock != nil</span><br><span class="line">           &#123;</span><br><span class="line">               resultBlock!(false,false,useableError)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>测试demo:     </p>
<p>swift:<a href="https://github.com/zmubai/TouchIDTest-swift" target="_blank" rel="noopener">https://github.com/zmubai/TouchIDTest-swift</a></p>
<p>object-c:<a href="https://github.com/zmubai/TouchIDTest-OC" target="_blank" rel="noopener">https://github.com/zmubai/TouchIDTest-OC</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/icon.jpg"
                alt="zengbailiang" />
            
              <p class="site-author-name" itemprop="name">zengbailiang</p>
              <p class="site-description motion-element" itemprop="description">知行合一</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a rel="external nofollow" href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zmubai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zengbailiang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">45.3k</span>
  
</div>


  <div class="powered-by">由 <a rel="external nofollow" class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("7VSaCuGNNUXrDp0aOK65w7PQ-gzGzoHsz", "l1D8p6eriduqG6aqx1f8H7ia");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
