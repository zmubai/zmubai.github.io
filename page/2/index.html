<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta name="google-site-verification" content="xdxP4Om7Pxp3OMC73kRMv2emRoA91RXOEPaKMivB_zg" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="沐白的个人博客">
<meta property="og:url" content="https://zengbailiang.cn/page/2/index.html">
<meta property="og:site_name" content="沐白的个人博客">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="沐白的个人博客">
<meta name="twitter:description" content="知行合一">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zengbailiang.cn/page/2/"/>





  <title> Hexo, NexT - 沐白的个人博客知行合一 </title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沐白的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-01-01-2018总结泛篇.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-01-01-2018总结泛篇.html" itemprop="url">2018年终总结泛篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-01T00:00:00+08:00">
                2019-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-01-01-2018总结泛篇.html" class="leancloud_visitors" data-flag-title="2018年终总结泛篇">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,883
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="2018年的不足"><a href="#2018年的不足" class="headerlink" title="2018年的不足"></a>2018年的不足</h3><p>2018年对自己而言是比较失意的一年，但也未尝没有收获。尽力而为，果上随缘可以概况了这一年的总基调。虽然内心如此想，但尽力真的很难，个人的劣根性，懒惰、目光不够长远，低估自己等等不足，为这一年带来了很多挫折。</p>
<p>就各个不足回顾下：</p>
<ol>
<li><p>懒惰：也不知道是不是懒惰，就是如果让你来啃教科书，或者让你去看部电影,或者睡懒觉，那个舒服，其他人的选择尚不清楚，但我想有一部分人会选择舒服的方式去消磨掉时间，就这样舒服成为了懒惰的一大原因。另外一个是，即使深知如此，依然很难摆脱这个劣根性，很难，就算你有一定的目标，但这种长远的考虑，在短期内没有收获，意志就会被慢慢消磨。查阅网上资料，发现实坚持真的不容易，也有一些通过奖励的方式去辅助等等。总之，这方面，自己做的很差，一定程度上的原因有贪图安逸、目标不够坚定、缺乏长期规划、实际可行的执行方案等。</p>
</li>
<li><p>目光短浅：虽然我试图想象，我把这些要做的事情全部做完，会变成怎么样，是否与自己的初衷相符，或者是否达到自己目标的预期，等等。但未来是很不明显的，当所掌握的信息极其的有限，很有可能会在这极其有限的信息中做出不那么正确的判断，在基于这样的判断下预期很难想象。这样就导致，中途可能会变换目标，或者使本来执行的事情搁置或放弃。另外目标短浅，就当前比较突出的是缺乏短期计划、中期计划、长期计划。</p>
</li>
<li><p>低估自己：如果没有上面两大缺点，或者上面两大缺点没有那么大，可能就不会过分的低估自己。这里面实际是存在些矛盾。客观来说，一些看似遥不可及的东西，也许通过一些努力，慢慢靠近也并非所想的难以靠近，通常来说这些东西本来就是需要努力去获取的，而差距和鸿沟需要努力去一步一步填补的。一个一直努力的人，和一个吊儿郎当的人差距是很大的，即使两个人的资质相差不大。当你有想法的时候，却发现能力不够，是悔恨浪费的时光，还是坦然面对过去，努力迎接未来?就算此刻努力，却有更多的患得患失，因为最好的时机已经错过，你没有在最该走这条路的时候走好，是挣扎还是要放弃呢？如果一些你本来能做到的事情，到最后却没法做到，一定会很悔恨与不甘吧。过去低估自己，现在是否还要低估自己？2018年对自我的认识依然不够，性格上依然有很大的问题，导致一些判断和考虑错误。其实这里并不是低估自己，而是人的潜力是很大的，忽略这一点，就如低估自己一样。</p>
</li>
</ol>
<h3 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h3><p>失败后的失落会让你面对现实，也许是这样的经历比较锻炼心智，让人变得成熟，大概是类似吃一堑长一智。经历过才印象深刻，才把这回事当成一回事。所以从这一点看，老人家说的很多是良言善语，只是我们的经历不够，难以深刻体会，依然要继续走弯路，直到吃了苦，才真正的明白个中的意思。这个也许是个生物特征的东西，很难改变，调整思维或者更早去经历，都是对的。但我更多的是那种把回事不当回事的人，所以啊，吃了不少暗亏。而这个收获就是经历后、体会过之后，思想的改变。在这个阶段，总之对比以前的自己，我更喜欢现在的自己。因此我对自己说过，经历过生活的洗礼后，要变得越来越喜欢自己。这个也是作为检测自己的一个标准。</p>
<h3 id="2019目标："><a href="#2019目标：" class="headerlink" title="2019目标："></a>2019目标：</h3><ol>
<li>定好学习目标与计划，持续提高。</li>
<li>改善懒惰。</li>
<li>目光放长远点，职业/生活/理财等。</li>
<li>对自己的认识，依然要不断改善，要努力积极向上。</li>
</ol>
<h5 id="比较重要的几点记录下来："><a href="#比较重要的几点记录下来：" class="headerlink" title="比较重要的几点记录下来："></a>比较重要的几点记录下来：</h5><ol>
<li><p>对于比较重要的事情，一定要考虑周全，查询一切可以查询的资料，把一件事情当做打仗来看，分清双方形势，考虑冒进/稳妥/更稳妥的三套以上的方案，同时要分清楚自己的情况与事件的关系。来自外界的意见要以主观为主加以分析，思前想后，分清主次，稳妥为主，否则可能会出现捡了芝麻丢了西瓜，甚至竹篮打水一场空的尴尬境地。</p>
</li>
<li><p>一直以来，都有不少与人争论的场合，通常对于一个问题，不同的人可能会有不同的意见，达成共识有时候并不是一件容易的事情。2019非原则问题，尽量避免争论。当然要继续保持包容和开放的心去接纳不同的意见。尊重事实，而不是奉承。这里其实有一个值得深思的问题，导致辩论的一大原因可能不是因为坚持自己的意见，甚至不是因为还是觉得自己的意见正确。而是来自人性的一部分，也许跟性格也是相关的。如果被别人纠正，意味着自己的不对，意味者局部性的不如人，也许是个性中的好强，这样内心就会难受，所以会出于这种理由要继续辩解并固执己见。这不过是一个个人的看法，实际上如何，原因应该很多样化，但如果自己本身去探究下为何会这样，大概多少能理解别人为何如此了。至少我要做到以事实为准，以更合理的为准，包容与接纳，减少争论。</p>
</li>
<li><p>君子之交淡如水，给与各自恰当的距离与空间，让大家都保持一种舒适的状态，这个是要往后学习与实践的。</p>
</li>
<li><p>情商需要提高，结合场景多思考合适的回答，形成思维回路，加强矛盾场景的锻炼。</p>
</li>
<li><p>提高专注度，做自己的事情，外界信息，要为自己所用，而不是要被外界影响。</p>
</li>
<li><p>今日事今日毕。改善拖延症，要做的事就是一个队列，如果拖，有些事就变得不了了之了，所有要改善拖延症。</p>
</li>
<li><p>踏实向上，加强时间管理，缄默慎言。</p>
</li>
</ol>
<h4 id="修心养性方面："><a href="#修心养性方面：" class="headerlink" title="修心养性方面："></a>修心养性方面：</h4><ol>
<li>可以的话2019要去多出去看看风景，留下多点关于旅途的回忆。</li>
<li>要学会照顾自己，品味生活。</li>
</ol>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>以上感觉总结的很泛，但也是一些心里话，记录下来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018_08_05_iosSaftThread.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018_08_05_iosSaftThread.html" itemprop="url">iOS 多线程安全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-05T00:00:00+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018_08_05_iosSaftThread.html" class="leancloud_visitors" data-flag-title="iOS 多线程安全">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,091
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程安全的概念"><a href="#线程安全的概念" class="headerlink" title="线程安全的概念"></a>线程安全的概念</h3><p>如果在多线程的场景下，运行一段程序，不会出现预料之外的结果。可以认为这段程序是线程安全的。</p>
<h3 id="导致线程不安全的原因"><a href="#导致线程不安全的原因" class="headerlink" title="导致线程不安全的原因"></a>导致线程不安全的原因</h3><p>当多线程访问同一个代码段的时候，共享变量的信息可以被各个访问它的线程所修改，以致于某个线程执行完代码块后出现期望之外的结果，甚至使线程崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__block int i = 0;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">        for (int j= 0 ; j &lt; 1000; j++) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot; a thread: %d&quot;,i);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        for (int j= 0 ; j &lt; 1000; j++) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;b thread: %d&quot;,i);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>其中一种结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-08-05 15:30:10.299750+0800 safeThreadTest[16566:2770764]  a thread: 1055</span><br><span class="line">2018-08-05 15:30:10.299750+0800 safeThreadTest[16566:2770766] b thread: 1965</span><br></pre></td></tr></table></figure></p>
<p>与期待的1000 和2000 不一致。</p>
<h3 id="避免线程不安全"><a href="#避免线程不安全" class="headerlink" title="避免线程不安全"></a>避免线程不安全</h3><p>避免线程不安全的关键是在原子操作，对需要原子操作的代码片段，通过加锁保证其线程安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__block int i = 0;</span><br><span class="line">NSLock *lock = [NSLock new];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    [lock lock];</span><br><span class="line">    for (int j= 0 ; j &lt; 1000; j++) &#123;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot; a thread: %d&quot;,i);</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    [lock lock];</span><br><span class="line">    for (int j= 0 ; j &lt; 1000; j++) &#123;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;b thread: %d&quot;,i);</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>稳定的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-08-05 15:34:46.495629+0800 safeThreadTest[16758:2774646]  a thread: 1000</span><br><span class="line">2018-08-05 15:34:46.495806+0800 safeThreadTest[16758:2774644] b thread: 2000</span><br></pre></td></tr></table></figure></p>
<h3 id="iOS中的atomic与nonatomic"><a href="#iOS中的atomic与nonatomic" class="headerlink" title="iOS中的atomic与nonatomic"></a>iOS中的atomic与nonatomic</h3><p>使用atomic定义的属性，系统为其默认生成的setter和getter方法是加锁的，setter操作与getter操作是互斥的原子操作。而使用nonatomic定义的属性，系统为其默认生产的setter和getter是不加锁的，两者的操作不互斥，同时也不具备原子性。</p>
<p>由于nonatomic是不加锁的，所以性能是比atomic高。而我们在开发过程中一般也是使用该属性。因为atomic只能保证属性的读写原子操作，并不能保证线程安全，在多线程编程中依然要根据代码的具体功能划分原子操作的范围，通过加锁来保证线程安全。除非原子操作范围就是这个属性的读与写，否则是没有必要定义成atomic，因为线程安全已经通过外层加锁处理。</p>
<p>系统是通过地址总线寻址，数据总线存取数据的。而且数据总线只有一个，其访问内存是串行操作。假定数据总线宽度为64位，数据长度超过64位，那么数据总线就必须多次访问内存。如果数据长度少于数据总线宽度，读写总是串行的，也即是其操作是原子的。int、bool、float、double等操作总是原子操作，同时在定义时无需指定atomic，避免系统增加不必要的加锁操作。而不定长度的数据类型，就有必要根据实际情况定义atomic或nonatomic。</p>
<h3 id="iOS中锁的使用"><a href="#iOS中锁的使用" class="headerlink" title="iOS中锁的使用"></a>iOS中锁的使用</h3><table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">性能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">OSSPinLock</td>
<td style="text-align:left">自旋锁</td>
<td style="text-align:left">高</td>
</tr>
<tr>
<td style="text-align:left">dispatch_semaphore_t</td>
<td style="text-align:left">信号量</td>
<td style="text-align:left">高</td>
</tr>
<tr>
<td style="text-align:left">pthread_mutex</td>
<td style="text-align:left">linux提供的互斥锁</td>
<td style="text-align:left">高</td>
</tr>
<tr>
<td style="text-align:left">NSLock</td>
<td style="text-align:left">OC提供的互斥锁</td>
<td style="text-align:left">一般</td>
</tr>
<tr>
<td style="text-align:left">pthread_mutex(recursive)</td>
<td style="text-align:left">linux提供的互斥锁</td>
<td style="text-align:left">一般</td>
</tr>
<tr>
<td style="text-align:left">NSCondition</td>
<td style="text-align:left">作为锁和线程检查器，有wait/signal方法</td>
<td style="text-align:left">一般</td>
</tr>
<tr>
<td style="text-align:left">NSRecursiveLock</td>
<td style="text-align:left">递归锁</td>
<td style="text-align:left">一般</td>
</tr>
<tr>
<td style="text-align:left">NSConditionLock</td>
<td style="text-align:left">条件锁，内部包含一个NSCondition对象</td>
<td style="text-align:left">低</td>
</tr>
<tr>
<td style="text-align:left">@synchronized</td>
<td style="text-align:left">互斥锁</td>
<td style="text-align:left">低</td>
</tr>
</tbody>
</table>
<p>加锁性能不能代表具体程序运行锁的性能。加锁快可能跟锁的实现简单，费时少有关。但使用中锁的性能跟线程等待采用的方式是休眠还是忙等有关。自旋锁由于优先级反转的问题已经不能使用，iOS10有替代版本。常规开发使用简单的NSLock、@synchronized等已经能满足大部分需求，性能要求高再考虑使用信号量等。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上线程安全、锁做简单的总结和理解。如果在开发中，还是要尽量避免多线程设计，搞不好出现死锁，也不好调试。程序的稳定安全比程序的性能更重要。要在确保程序的稳定和线程安全的情况下，再去提高程序的性能。</p>
<p>参考：<br><br><a href="http://mrpeak.cn/blog/ios-thread-safety/" target="_blank" rel="noopener">iOS多线程到底不安全在哪里？</a><br><br><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018_08_04_processAndThread.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018_08_04_processAndThread.html" itemprop="url">进程与线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-04T00:00:00+08:00">
                2018-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机基础/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018_08_04_processAndThread.html" class="leancloud_visitors" data-flag-title="进程与线程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,933
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ol>
<li>定义：是一个程序及其数据在处理机上执行时所发生的活动。</li>
<li>程序与进程的区别：程序是一组有序指令的集合，是静态的。而进程是动态的，由创建而产生，由调度而执行，由撤销而消亡。进程具有并发性，可并发执行。进程具备独立性，是接受资源和接受调度的基本单位（是资源分配的最小单位，而调度的最小单位是线程）。进程具有异步性，即按各自独立和不可预知的速度向前推进。<h5 id="进程的三种基本状态："><a href="#进程的三种基本状态：" class="headerlink" title="进程的三种基本状态："></a>进程的三种基本状态：</h5></li>
<li>就绪：已获取除cpu执行权以外的所有资源，只要获得cpu执行权，便可立即执行。就绪线程通常放到一个就绪队列中。</li>
<li>执行：获取cpu执行权，处于执行状态中。</li>
<li>阻塞：当进程执行被打断时，处理器会发起调度，把执行权给予其他就绪进程，而当前进程进入阻塞状态。阻塞状态的进程，会被放进系统的阻塞队列中，等待被唤醒。导致阻塞的几种情况。<ol>
<li>向系统请求共享资源失败。</li>
<li>等待某种操作完成。发起IO-》阻塞-》需等IO任务执行完成-》中断处理程序唤醒-》就绪</li>
<li>等待新任务到达。</li>
</ol>
</li>
</ol>
<p>进程的挂起与唤醒：当系统资源不足的时候，会去挂起就绪或堵塞进程，把它们放入外存以释放内存资源。同时执行挂起原语suspend能主动挂起进程。就绪进程挂起变为静态就绪状态，阻塞进程挂起变为静态阻塞状态，执行中的进程被挂起进入静态就绪状态。当静态就绪状态被激活，加载到内存中，就恢复到活动就绪状态。静态阻塞被激活醒就变为活动阻塞。</p>
<p>状态转换如下图：</p>
<p><img src="/personImg/进程状态转换.png" alt="进程状态转换.png"></p>
<p>阻塞与唤醒过程：</p>
<p><img src="/personImg/进程阻塞唤醒过程.png" alt="进程阻塞唤醒过程.png"></p>
<p>挂起与激活过程：</p>
<p><img src="/personImg/进程挂起激活过程.png" alt="进程挂起激活过程.png"></p>
<h4 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h4><h5 id="pcb的作用"><a href="#pcb的作用" class="headerlink" title="pcb的作用"></a>pcb的作用</h5><ol>
<li>作为进程实体的一部分，记录了操作系统所需的，用于描述进程当前情况及管理进程运行的全部信息，是操作系统中最中最重要的记录型数据结构。</li>
<li>能实现间断性运行方式，能保存运行的上下文，用于下次执行。</li>
<li>提供进程管理所需的信息。记录了程序和数据在内存或外存中的地址指针。</li>
<li>提供进程调度所需的信息，进程优先级、所处状态等。</li>
<li>实现与其他进程同步与通信。如果使用信号量，进程中必须都设置相应的用于同步的信号量。关于通信，pcb中有用于实现进程通信的区域或通信队列指针等。</li>
</ol>
<h5 id="pcb中的信息"><a href="#pcb中的信息" class="headerlink" title="pcb中的信息"></a>pcb中的信息</h5><ol>
<li>进程唯一标识符，外部标识符（用户调用）和内部标识符（系统调用）。</li>
<li>处理机状态，也称处理机上下文。主要由处理机的各种寄存器中的内容组成的。寄存器类型包括：1.通用寄存器，用于暂存信息。2.指令计数器，存放下一条指令的地址。3.程序状态字PSW，包含状态信息（条件码、执行方式、中断屏蔽标志）。4.用户栈指针，指向的栈中，存放调用参数和调用地址。</li>
</ol>
<p>当进程被切换时，处理机信息都必须保存在pcb中，当再次运行的时候，能从原状态恢复。同时，如果进程频繁切换，带来的时空开销是很大的。</p>
<h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>临界资源：一次只允许一个进程使用的资源。例如一些硬件资源，打印机、磁带机等。进程间应采用互斥方式，实现对这种资源的共享。</p>
<p>临界区：访问公共资源的代码片段。</p>
<p>原则：</p>
<ol>
<li>空闲让进：无程序处于临界区时，代表临界资源空闲，允许请求进入的进程访问。</li>
<li>忙则等待：如果临界资源被访问中，请求访问必须等待，实现互斥。</li>
<li>有限等待：保证在有限时间内能进入自己的临界区，避免死等。</li>
<li>让权等待：当进程无法进入临界区时，释放处理机，避免陷入忙等。此原则应该是在有限等待无法实现的情况下执行。</li>
</ol>
<p>信号量机制</p>
<p>wait(s),signal(s)基本操作，属于原子操作，执行过程不可中断。当s = 1的时候可以实现互斥同步功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;</span><br><span class="line">    ...</span><br><span class="line">    wait(mutex);    </span><br><span class="line">    //临界区</span><br><span class="line">    signal(mutex);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>通过wait，signal能保证临界区同时只能允许一个进程进入。当临界区繁忙时，其他行程访问临界区，执行wait操作会失败，同时进程会进入阻塞。</p>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ol>
<li>管道系统pipe,接收发送通过共享文件（pipe文件）的方式进行通信。</li>
<li>消息传递系统，send(receiver,message),receive(sender,message)</li>
<li>客户机-服务器系统，通过socket套接字</li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁：如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p>
<p>进程饥饿：进程一直获取不到资源。</p>
<p>可抢占资源：能被其他线程抢占的资源。该类资源的抢占不会导致死锁的产生。如处理机、内存空间等。</p>
<p>不可抢占资源：一旦被分配了，不能强行回收，只能等线程释放。如打印机、刻录机等。</p>
<p>死锁产生的几种情况：</p>
<ol>
<li>竞争不可抢占资源，导致互相等待对方释放资源。双方都必须拥有对方要访问的资源。不能通过调整代码顺序解决。</li>
<li>竞争可消耗资源（中断信号、系统通知等）。循环等待消息的接受，才执行消息的发送，导致死锁。能通过调整代码的执行顺序解决。大家都想获取到消息资源，而等待的消息资源，只有其他人能发出。由于循环等待，导致消息无法发出。属于可消耗资源的竞争。</li>
<li>程序的推进顺序非法。该情况不属于资源使用，但导致死锁也就是出现互相等待的局面或则循环等待的局面。</li>
</ol>
<p>死锁产生的条件：</p>
<ol>
<li>互斥条件：分配的资源，同一时间只能被一个进程访问，直到其释放。</li>
<li>请求和保存条件：请求新的资源，同时保存自己已拥有的某个资源不释放,这个不释放的资源就是别人要获取的资源。</li>
<li>不可抢占条件：访问的资源不可被抢占。这样就无法通过抢占的方式解决阻塞。</li>
<li>循环等待条件：这是出现死锁的一个结果，由于前面的几个条件的同时存在才有可能出现这个循环等待的结果，如果这个结果出现，那么意味着出现死锁。</li>
</ol>
<p>死锁的处理方法：</p>
<ol>
<li>预防死锁：通过某些限制条件破坏死锁的四个条件，防止死锁的产生。属于事先预防。</li>
<li>避免死锁：在系统资源动态分配的过程中，通过某种方式，防止进程进入不安全区域，避免死锁的发生。输入事先预防。</li>
<li>检测与解除死锁：使用某些方式检测死锁的产生并解除死锁。可通过撤销进程，终止进程等方式，释放资源。</li>
</ol>
<hr>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>20世纪60年代OS系统引入进程解决程序并发问题，80年代提出比进程更小的单位线程。90年代出现多核处理机，线程能更好的发挥处理机的性能。线程是为了提高并发性以及进行相互之间合作而创建的。而现在进程更多的是作为线程的容器，程序的并发执行通过线程来实现。</p>
<p>进程与线程的比较：<br>1.调度角度： 进程过重，是独立运行的基本单位，进程每次调度都需要切换上下文，时空开销大。而线程切换仅仅需要保持和设置少量的寄存器内容，切换代价远低于进程。</p>
<ol start="2">
<li>资源角度：作为资源调度的基本单位，进程拥有独立资源。而线程本身不拥有系统资源，其仅有一点必不可少的能保证独立运行的资源（TCB、程序计数器、保留局部变量、状态参数、返回地址等一组寄存器和堆栈）。</li>
<li>独立性角度：进程间相对独立，出了通过少量的全局变量实现共享。线程资源允许别的线程共享，同一进程的所有线程共享同一个内存地址空间和进程资源。</li>
<li>稳定性：进程之间除了共享全局变量外，不允许其他进程访问。而线程因为共享同一个进程的内存地址空间和资源，甚至其线程堆栈都能被其他线程读取和清楚。多进程比多线程稳定，但协同能力多线程更强。</li>
</ol>
<h4 id="线程控制块TCB"><a href="#线程控制块TCB" class="headerlink" title="线程控制块TCB"></a>线程控制块TCB</h4><p>包含信息：</p>
<ol>
<li>线程标识符</li>
<li>线程运行状态（就绪、阻塞、执行）</li>
<li>优先级</li>
<li>堆栈指针（调用过程的局部变量和返回地址）</li>
<li>线程专有存储区，用于保存切换时的线程上下文和一些统计信息。</li>
<li>信号屏蔽，对某些信号加以屏蔽。</li>
<li>一组寄存器，程序计数器寄存器PC、通用寄存器。<ol>
<li>程序计数器寄存器，用于存储下一条程序指令地址。</li>
<li>通用寄存器，用于存送和暂存数据，也可参与算术逻辑运算并保存结果。</li>
</ol>
</li>
<li>两个指向堆栈的指针，执行自己堆栈的指针和指向核心栈的指针。前者是当线程运行在用户态时使用自己的堆栈来保存局部变量和函数返回地址，后者是线程运行在核心态的时候使用系统核心栈。</li>
</ol>
<h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><h5 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h5><p>创建、阻塞、撤销和切换都在内核空间实现。</p>
<p>优点：</p>
<ol>
<li>对多处理器系统来说，内核能调度同一进程中的多个线程实现真正意义的并发执行。</li>
<li>当进程中的一个线程阻塞了，能调度进程中的其他线程执行，甚至能调度其他进程中的线程执行，前提是这个线程必须是核心态。</li>
<li>内核线程具有很小的数据结构和堆栈，切换开销小。</li>
</ol>
<p>缺点：<br>用户如果要切换进程中的线程，需要把线程从用户态切换到核心态，因为线程调度由内核控制，系统开销较大。</p>
<h5 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h5><p>在用户空间中实现。用户级线程的一切操作对内核都是透明的。但是这种线程就不能实现真正意义的并发，系统调度以进程为单位。如果A进程实现了1个用户级线程，而B进程实现了100个用户级线程，那么A中线程获得的执行时间是B中线程的100倍。而内核支持线程，以线程为调度单位。</p>
<h5 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h5><ol>
<li>一对多。用户线程映射到一个核心线程。如果核心线程阻塞了，就无法正常工作。</li>
<li>一对一。核心线程的数据与用户线程的数量一样，一一映射。发送阻塞能调度其他线程，但每个用户线程就对应一个核心线程，导致系统开销大，需要全局限制线程的数量。</li>
<li>多对多。存在多个核心线程用于映射用户线程，避免了系统开销过大，也避免了阻塞导致不能正常工作的问题。集合了1和2的优点。</li>
</ol>
<h5 id="内核支持线程的实现"><a href="#内核支持线程的实现" class="headerlink" title="内核支持线程的实现"></a>内核支持线程的实现</h5><p>创建进程的时候，分配一个PTDA(per task data area),其中包含若干线程控制块TCB空间。当一个新内核线程被创建时，系统会分配TCB和相关资源。线程销毁时资源被回收，但也可以先不回收，等候新的线程被创建时服用其TCB。</p>
<h5 id="用户级线程的实现"><a href="#用户级线程的实现" class="headerlink" title="用户级线程的实现"></a>用户级线程的实现</h5><p>在用户空间实现的，线程运行在运行时系统上（runtime system）。线程切换时不需要切换到核心态，切换速度快。申请资源需要通过runtime system间接申请。</p>
<p>内核控制线程：又称lwp（light weight process）。lwp可通过系统调用来获得内核提供的服务，当用户级线程连接到lwp上，就能具有内核支持线程的所有属性（调度方式，按线程调度）。lwp是用户线程与内核线程沟通得桥梁，同时起到用户线程与内核线程的隔离作用。用户线程可能很多，为了节省系统开销，不能设置过多的lwp，通过多路复用的方式实现lwp线程池，如果没有可用lwp那么用户线程进入等待。lwp阻塞可用去连接别的lwp，就算lwp全部阻塞也不妨碍线程执行任务，但不能访问内核了。</p>
<h5 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h5><p>当优先级高的线程访问临界资源，而这个临界资源被优先级低的线程占用。此时就会发生优先级倒置。如果此时存在三个优先级a,b,c,c 为低优先级且占用临界资源，a为高优先级需要访问临界资源，b为中优先级不需要访问临界资源。当a去访问资源的时候，发现无法访问，因为被c占用了，同时又存在b线程，b优先级比c高，系统调度去执行b，b执行完毕后，才有可能执行c，c释放临界资源后a才有可能执行。但如果存在多个如b2,b3,b4，那么a线程执行的时刻就会被大大延长。且a的执行被延长的时间不可预知和无法限定。</p>
<p>解决方案1：如果线程正在访问临界资源，设定为不可被抢占，这样其就能更快的退出临界区。但如果这样，当线程访问临界区时，调度对他是失效的。就算有很多优先级比他高的不需要访问临界资源的线程都没机会执行。如果其临界区很长，那么必然是不能接受和不合理的。</p>
<p>解决方案2：当高优先级线程因为访问临界资源被阻塞时，拥有临界资源的低优先级的线程继承高优先级线程的优先级，直到其退出临界区。这样既能不影响系统的正常调度，比他们更高的优先级的线程依然能执行，同时能避免介于他们中间的优先级的线程插入执行。</p>
<p>相比两个方案，方案二更优。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018_07_29_Memory.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018_07_29_Memory.html" itemprop="url">谈谈计算机内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-29T00:00:00+08:00">
                2018-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机基础/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018_07_29_Memory.html" class="leancloud_visitors" data-flag-title="谈谈计算机内存">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,316
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="内存的访问"><a href="#内存的访问" class="headerlink" title="内存的访问"></a>内存的访问</h4><ol>
<li>通过地址总线将地址送到内存，然后数据总线会把数据送到微处理器供给cpu使用。</li>
<li>32位总线可寻找范围为[0,2^32 - 1]相当于[0,4294967296]，即4GB。</li>
</ol>
<h4 id="物理地址到虚拟地址"><a href="#物理地址到虚拟地址" class="headerlink" title="物理地址到虚拟地址"></a>物理地址到虚拟地址</h4><p>早期计算机是使用物理地址的，但是使用物理地址会存在以下几个问题：</p>
<ol>
<li><p>地址空间不隔离</p>
<p> 所有的程序都是使用物理地址访问，程序所使用的内存空间是不隔离的。程序可以被其他程序访问，对恶意访问或修改没有防护措施。程序的稳定性难以保证。</p>
</li>
<li><p>内存使用效率低</p>
<p> 直接使用物理地址，必须是连续的。如果剩余的物理内存无法满足程序的空间分配，那么就需要把当前运行的某些程序写入磁盘，释放内存空间以供给需要运行的程序。当写入磁盘的程序被唤醒，系统会以同样的策略给该程序分配内存，内存条件满足后把程序读入内存。这里面存在很多的磁盘读写操作，导致内存使用效率低。原因1，使用物理地址，必须是连续的，不能充分的利用内存碎片，颗粒很大。原因2，磁盘读写的操作比较耗时，内存分配必须等待该操作的完成，这样相当于把内存使用的效率变低了。</p>
</li>
<li><p>程序运行地址不确定</p>
<p> 系统给程序分配的空间不固定与程序编写时固定地址的数据访问和指令跳转产生冲突。这个冲突增加了编程难度。</p>
</li>
</ol>
<h4 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h4><p>为了解决使用物理地址存的问题，加入中间层，通过使用虚拟地址的方式访问程序。然后通过地址映射转换成成物理地址。由于每个程序只能访问自己的虚拟地址，只要妥善的控制这个映射关系，确保程序间的地址不重叠，就能实现程序间的内存地址相互隔离。</p>
<p>三、内存的存储管理方式</p>
<ol>
<li><p>分段存储管理方式</p>
<ul>
<li><p>地址的整块映射。物理地址分配也是连续的。</p>
</li>
<li><p>解决了地址空间不隔离、程序运行地址不确定的问题。但由于是连续地址，分配空间不足的情况下，需要对某些程序进行磁盘写入以释放空间，导致内存使用效率低的问题。</p>
</li>
</ul>
</li>
<li><p>分页存储管理方式</p>
<ul>
<li><p>解决了内存使用效率低的问题。对于每个程序来说，在某个时间段内，只会频繁的用到某部分数据。那么可以把那些不常用的数据存储于磁盘中并释放内存空间。通过分页的存储方式实现更细粒度的控制。内存的分页需要硬件支持，同时在硬件支持的基础上通过系统选择使用的方式。例如硬件支持4k和8k每页，系统选择4k。但是在运行过程中是不能切换分页方式的，也即是说，任意时刻分页方式都是确定的。目前几乎所有pc系统都使用4k大小的页。</p>
</li>
<li><p>内存共享：通过两个程序中的某些地址指向同一个物理页的方式实现。</p>
</li>
<li><p>写入磁盘的数据唤醒：当程序通过虚拟地址对写入磁盘的数据发起调用的时候，内存中并不存在并会发出页错误（pageFault），然后系统接管线程并把磁盘中的页数据读入内存，并恢复正常访问。</p>
</li>
<li><p>页的部分映射表会存储在一个叫TLB(Translation Look Aside Buffer)的寄存器，以提高内存的使用效率。因为把所有的映射表存储在内存中，cpu读取的时候需要两次访问内存。第一次访问页表，第二次才访问目标内存。这样会使访问效率变低。如果通过TLB保存常用的映射表，读取寄存器获取物理地址，能大大提高内存使用效率。TLB的容量有效，如果表满了会淘汰最老的不使用的页映射条目，这里应该有某类的淘汰算法来实现。</p>
</li>
<li><p>一般来说，只有当内存不足的时候才会把数据读入磁盘，也即是虚拟内存。</p>
</li>
</ul>
</li>
<li><p>段页存储管理方式</p>
<ul>
<li><p>分页和分段两种方式的结合，同时具备两者的优点。是应用最广泛的存储管理方式。</p>
</li>
<li><p>物理地址与虚拟地址直接的转换时通过硬件实现的。但几乎都是通过MMU（Memory Management Unit）这样的硬件实现的。MMU一般集成于cpu内部。</p>
</li>
</ul>
</li>
</ol>
<h4 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h4><ol>
<li>内核空间。<ul>
<li>内存的部分空间分配给内核使用，这部分空间程序是无法访问的。例如，内存总量为4G，分配1~2G作内核使用。</li>
</ul>
</li>
<li><p>栈</p>
<ul>
<li>栈的作用：用于维护函数调用的上下文，离开栈函数的调用就无法执行。</li>
<li><p>栈的地址增长方向：跟cpu和os的实现方式有关，Linux是向下增长的，但在程序中显示的都是虚拟地址，不能用于判断其增长方向。</p>
<p>内存分布图：</p>
<p><img src="/personImg/linux程序内存分布.png" alt="内存分布.png"></p>
<p>栈保存了函数调用所需要维护的信息：</p>
</li>
</ul>
<ol>
<li>函数返回地址和参数</li>
<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。</li>
<li>保存上下文：包括函数调用前后要保持不变的寄存器。</li>
<li>i386中使用ebp和esp两个寄存器来为函数活动记录划分范围。esp始终指向栈的顶部，也即当前函数活动记录的顶部。而ebp则会指向函数的栈帧底部。<br>当一个新的函数调用时压栈过程大概如下：<ul>
<li>它的参数会先压栈(push params)</li>
<li>然后对其函数执行函数调用（call func），并把返回值地址填入栈。</li>
<li>保存之前的函数ebp，push ebp。</li>
<li>设置当前函数的栈帧底部mov esp, ebp。当前位置的栈顶esp就是当前函数的栈帧底部ebp。<br>-然后执行新的栈帧，当栈帧执行完之后会用ret 返回参数。此时通过读取ebp的值，ebp就能返回到之前函数的栈帧底部，同时esp划过函数参数恢复到之前函数的栈顶。</li>
</ul>
</li>
<li><p>另外还有一个eip寄存器，记录cpu下一次执行指令的地址。</p>
<p><img src="/personImg/stackframe-cdecl.png" alt="stackframe-cdecl.png"></p>
</li>
</ol>
</li>
<li><p>堆</p>
<ol>
<li>堆的作用：用来容纳应用程序动态分配内存。</li>
<li>堆内存的分配可以通过程序控制（malloc()），当内存不足的时候会交由系统分配（brk（）、mmap()）。</li>
<li><p>堆分配算法：</p>
<ul>
<li><p>空闲链表</p>
<p>  每个节点为包含起始地址和空闲大小。查找空闲空间的时候，通过遍历空闲链表查找合适空间。返回地址和大小，用于内存分配和释放。<br>  存在缺点：链表被破坏，或者返回数据被破坏，那么会导致程序错误、甚至整个堆无法工作。因为空闲链表只记录空闲的数据，而不是全堆信息。如果大小字段错误，确实会导致整个堆无法工作，因为这种情况是无法判断出来的，无法估量整个堆的内存使用情况。</p>
</li>
<li><p>位图</p>
<p>  把空闲内存划分为多个块，使用2个字节存储。假设每个块大小为x。堆空间大小为Y,那么数组的元素个数为y/x。每个块的地址也能通过公式计算出。那么我们返回数据的时候，会把第一个元素标记为头块（返回头快和后面跟随的块个数），后面的元素标记为主体块。那么块是有3种状态，空闲/头/主体，用用2bit表示。</p>
<p>  优点：1. 只要分配块的大小适中，那么cache命中率会很高，速度快。2. 稳定性好，避免用户越界读写破败位图，作简单备份。即使部分数据受到破坏，也不会导致整个堆无法工作。因为位图是记录了整个堆的内存使用情况，就算部分数据受到破坏，使用保守策略不使用破坏的部分，而不会导致整个堆不可用。</p>
<p>  缺点：1. 容易产生碎片。2. 块的大小太小，会导致cache命中率变低。可使用多级位图解决。</p>
</li>
<li><p>对象池</p>
<p>  某些场合被分配的对象大小为固定的几个值。那么就按照这个大小分配块。可用位图或空闲链表实现。</p>
</li>
</ul>
<p>而实际中，堆分配算法往往是采用多种算法复合而成的。</p>
</li>
</ol>
</li>
</ol>
<hr>
<p>ps：部分图片来源于网络，如有侵权，请联系马上删除。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018_07_24_ios.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018_07_24_ios.html" itemprop="url">iOS 深复制与浅复制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-24T00:00:00+08:00">
                2018-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018_07_24_ios.html" class="leancloud_visitors" data-flag-title="iOS 深复制与浅复制">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,284
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="官方文档翻译"><a href="#官方文档翻译" class="headerlink" title="官方文档翻译"></a>官方文档翻译</h3><p>Protocol<br>NSCopying(swift)</p>
<p>A protocol that objects adopt to provide functional copies of themselves.<br>对象采用的一种协议，用来提供拷贝自身元素的功能。</p>
<p>Overview</p>
<blockquote>
<p>The exact meaning of “copy” can vary from class to class, but a copy must be a functionally independent object with values identical to the original at the time the copy was made. A copy produced with NSCopying is implicitly retained by the sender, who is responsible for releasing it.</p>
</blockquote>
<p>拷贝的确切意义会因类而异，但拷贝的必须是一个功能独立的对象并且其值在复制时跟 元素对象的值一样。通过NSCopying生成的副本会被发送者隐式持有，发送者负责其释放。</p>
<blockquote>
<p>NSCopying declares one method, copy(with:), but copying is commonly invoked with the convenience method copy(). The copy() method is defined for all objects inheriting from NSObject and simply invokes copy(with:) with the default zone.</p>
</blockquote>
<p>NSCopying声明一个方法copy(with:)，但拷贝通常被便利方法copy()调用。copy()方法被所的继承NSObject的对象定义，并通过默认zone直接调用copy(with:)。</p>
<blockquote>
<p>Your options for implementing this protocol are as follows:</p>
</blockquote>
<p>您实现本协议的选项如下:</p>
<ul>
<li><p>Implement NSCopying using alloc and init… in classes that don’t inherit copy(with:).</p>
<ul>
<li>在不继承copy(with:)的类中，使用alloc和init方法。</li>
</ul>
</li>
<li><p>Implement NSCopying by invoking the superclass’s copy(with:) when NSCopying behavior is inherited. If the superclass implementation might use the NSCopyObject function, make explicit assignments to pointer instance variables for retained objects.</p>
<ul>
<li>当NSCopying行为被继承时，通过调用父类的copy(with:)实现NSCopying。如果父类实现可能使用NSCopyObject方法，显式分配指针实例变量来持有对象。</li>
</ul>
</li>
<li><p>Implement NSCopying by retaining the original instead of creating a new copy when the class and its contents are immutable.</p>
<ul>
<li>当类及其内容是不可变的时，通过保留原始副本而不是创建新的副本来实现NSCopying。</li>
</ul>
</li>
<li><p>If a subclass inherits NSCopying from its superclass and declares additional instance variables, the subclass has to override copy(with:) to properly handle its own instance variables, invoking the superclass’s implementation first.</p>
<ul>
<li>如果一个子类继承其父类的NSCopying并声明额外的实例变量。子类必须重写copy(with:)方法来处理自身的实例变量，父类的copy(with:）方法会先被执行。</li>
</ul>
</li>
</ul>
<hr>
<p>Protocol<br>NSMutableCopying(Object-c)</p>
<blockquote>
<p>A protocol that mutable objects adopt to provide functional copies of themselves.</p>
</blockquote>
<p>可变对象采用的一种协议，用来提供拷贝自身元素的功能。</p>
<p>Overview</p>
<blockquote>
<p>The NSMutableCopying protocol declares a method for providing mutable copies of an object. Only classes that define an “immutable vs. mutable” distinction should adopt this protocol. Classes that don’t define such a distinction should adopt NSCopying instead.</p>
</blockquote>
<p>NSMutableCopying协议声明了一个方法，用于提供对象的可变副本。只有定义“不可变与可变”区别的类才应该采用此协议。没有定义这种区别的类应该采用NSCopying。</p>
<blockquote>
<p>NSMutableCopying declares one method, mutableCopyWithZone:, but mutable copying is commonly invoked with the convenience method mutableCopy. The mutableCopy method is defined for all NSObjects and simply invokes mutableCopyWithZone: with the default zone.</p>
</blockquote>
<p>NSMutableCopying定义了一个方法mutableCopyWithZone。但可变拷贝一般通过便利方法mutableCopy调用。mutableCopy方法被所有的NSObjects定义并通过默认zone直接调用mutableCopyWithZone。</p>
<blockquote>
<p>If a subclass inherits NSMutableCopying from its superclass and declares additional instance variables, the subclass has to override mutableCopyWithZone: to properly handle its own instance variables, invoking the superclass’s implementation first.</p>
</blockquote>
<p>如果子类通过父类继承NSMutableCopying协议，同时定义了额外的实例变量。子类必须复写mutableCopyWithZone方法来处理自身额外的实例变量，但会先调用父类的mutableCopyWithZone方法。</p>
<hr>
<h4 id="相关API："><a href="#相关API：" class="headerlink" title="相关API："></a>相关API：</h4><pre><code>- (id)copy;//执行成功返回不可变对象

- (id)mutableCopy;//执行成功返回可变对象
</code></pre><h4 id="从组合的方式理解深浅拷贝"><a href="#从组合的方式理解深浅拷贝" class="headerlink" title="从组合的方式理解深浅拷贝"></a>从组合的方式理解深浅拷贝</h4><p>指针拷贝：返回对象与被复制对象都指向同一个对象，返回对象拷贝的是被复制对象的指针。</p>
<p>内容拷贝：创建新的对象，并把被复制对象的内容复制。返回对象与被复制对象指向不同的对象，返回对象拷贝的是被复制对象的内容。</p>
<ol>
<li>浅复制：被复制对象每一层都是指针拷贝。<ol>
<li>仅当执行imutable对象执行copy方法时产生浅复制。</li>
</ol>
</li>
<li><p>深复制：被复制对象第一层是内容拷贝。</p>
<ol>
<li>执行mutableCopy总会产生深复制。</li>
<li>mutable对象执行拷贝总会产生深拷贝，不论copy或mutableCopy。</li>
<li>当对象属性中存在集合的时候，集合本身是深拷贝，但其元素执行的依然是浅拷贝。这个在某些开发场景中如果使用不当，会导致业务逻辑的不对。因为是指针拷贝，实际上是同一个对象。如果我们期待他们是不同的对象，期待他们之间的修改是互不影响的，那么久需要执行完全拷贝，简单的深拷贝是不满足的。所以，要实现集合属性的内容拷贝，需要对集合属性执行 initWithArray:copyItems: / initWithDictionary:copyItems:。copyItems入参YES。</li>
</ol>
</li>
<li><p>排列组合：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">object type</th>
<th style="text-align:left">invoke funtion</th>
<th style="text-align:left">copy type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">imutable object</td>
<td style="text-align:left">copy</td>
<td style="text-align:left">shallow copy</td>
</tr>
<tr>
<td style="text-align:left">imutable object</td>
<td style="text-align:left">mutableCopy</td>
<td style="text-align:left">deep copy</td>
</tr>
<tr>
<td style="text-align:left">mutable object</td>
<td style="text-align:left">copy</td>
<td style="text-align:left">deep copy</td>
</tr>
<tr>
<td style="text-align:left">mutable object</td>
<td style="text-align:left">mutableCopy</td>
<td style="text-align:left">deep copy</td>
</tr>
</tbody>
</table>
<p>我的理解是当执行拷贝使对象状态发生变化，即可变变为不可变或者不可变变为可变，必然是深拷贝。另外可变对象执行拷贝必然也是深拷贝。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可变对象拷贝深拷贝，状态变化深拷贝。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-22-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-22-leetcode.html" itemprop="url">算法-不同路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T00:00:00+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-22-leetcode.html" class="leancloud_visitors" data-flag-title="算法-不同路径">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  838
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="/personImg/不同路径.png" alt="CNAME配置.png"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure></p>
<p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure></p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>每个格子的路径数等于其上方的格子的路径数与其左方的路径数之和。dp公式为：dp(i,j) = dp(i - 1,j) + dp (j,i - 1)，其中( 0&lt;= i &lt;= m - 1, 0 &lt;= j &lt;= n -1 )。所以右下角的格子的的路径数为dp（i-1，j-1）。特殊情况处理，如果m == 1 或者 n == 1,那么路径只有一条。</p>
<h4 id="思路1：dp"><a href="#思路1：dp" class="headerlink" title="思路1：dp"></a>思路1：dp</h4><ol>
<li>0 指向格子的第一行。有时候又在纠结到底是用0作为第一行，还是用1作为第一行。下面的递归就是使用1代表第一行。</li>
<li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">   </span><br><span class="line"> if (m == 1 || n == 1) &#123;</span><br><span class="line">     return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> int dp[100][100];</span><br><span class="line"> //水平第一行每个格子只有一种组合</span><br><span class="line"> for (int i = 0 ; i &lt; m; ++ i) &#123;</span><br><span class="line">     dp[i][0] = 1;</span><br><span class="line"> &#125;</span><br><span class="line"> //垂直第一行每个格子只有一种组合</span><br><span class="line"> for (int i = 0 ; i &lt; n; ++ i) &#123;</span><br><span class="line">     dp[0][i] = 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //数组的第0行对应格子的第一行。第0行dp值已经初始化了，这里从第二行计算起</span><br><span class="line"> for (int i = 1; i &lt; m; ++ i) &#123;</span><br><span class="line">     for (int j = 1; j &lt; n; ++ j) &#123;</span><br><span class="line">         dp[i][j] = dp[i - 1][j] + dp[i][j -1];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //(m -1 , n - 1) 对应目标格子，返回其dp值。</span><br><span class="line"> return dp[m - 1][n - 1];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="思路2：使用递归"><a href="#思路2：使用递归" class="headerlink" title="思路2：使用递归"></a>思路2：使用递归</h4><ol>
<li>核心思路跟dp一样。只是使用递归的方式实现。 数组的下标1代表的第1行。这个可能会直观一点。但有时候更容易出现问题。后面还是统一使用0作为第一行处理。</li>
<li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   int subUniquePaths(int m,int n,int **dp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    if (dp[m][n] != 0) &#123;</span><br><span class="line">        printf(&quot;(%d,%d) dp:%d\n&quot;,m,n,dp[m][n]);</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;(%d,%d)\n&quot;,m,n);</span><br><span class="line">        if (m - 1 == 0 || n - 1 == 0) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            dp[m][n] = subUniquePaths(m - 1, n,dp) + subUniquePaths(m, n -1,dp);</span><br><span class="line">            return dp[m][n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    </span><br><span class="line">    int **dp;</span><br><span class="line">    int row = 101,column = 101;</span><br><span class="line">    dp = (int **)malloc(sizeof(int *) * row); // 分配所有行的首地址</span><br><span class="line">    for (int i = 0; i &lt; row; i ++) &#123; // 按行分配每一列</span><br><span class="line">        dp[i] = (int *)malloc(sizeof(int) * column);</span><br><span class="line">        memset(dp[i], 0, sizeof(sizeof(int) * column));</span><br><span class="line">    &#125;</span><br><span class="line">    return subUniquePaths(m, n, dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol>
<li>为了直观，在递归的时候使用下标1的行作为第一行，但这也导致了程序处理思维的混乱和不统一，虽然很难说明那种好。但程序中的数组既然是从0开始，那么还是统一采用0作为第一行处理。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-07-15-0leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-07-15-0leetcode.html" itemprop="url">算法-使用最小花费爬楼梯</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-15T00:00:00+08:00">
                2018-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-07-15-0leetcode.html" class="leancloud_visitors" data-flag-title="算法-使用最小花费爬楼梯">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,333
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="索引从0开始">i</a>。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: cost = [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<p>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>可以把每个阶梯当做一个节点，能走出消耗值小值得路径可能有几条。同时可能会存在一些节点你走错了无法走出最小值的路径。如何选择这些节点是个问题。这看起来有点像广度优先搜索，每一次选择都需要根据前面的两个节点和当前节点的消耗值来确定那个组合的消耗值最小从而确定当前节点的选择。但这其实是一个动态规划问题，后面节点的选择不受前面节点的选择的影响，但会根据前面节点选择的值来确定当前节点的选择（前后步骤的联系），为了保证消耗值最小，前提是每一次选择节点都要满足消耗值最小，那么当路径走完的时候总的消耗值就是最小。算法实现的时候记录每个节点的最小消耗总值，用于后面的节点选择。实际上只需要记录最近的两个节点的最小消耗总值即可。</p>
<h4 id="思路1：dp"><a href="#思路1：dp" class="headerlink" title="思路1：dp"></a>思路1：dp</h4><ol>
<li>dp特点：<ol>
<li>后面的步骤不受前面的步骤的影响，但会用到前面步骤的计算值。需保证前面的步骤选择正确性。</li>
<li>利用容器记录每个步骤的可用值，空间换时间。</li>
</ol>
</li>
<li>代码 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int min(int a, int b )</span><br><span class="line">&#123;</span><br><span class="line">    return a &lt; b ? a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int minCostClimbingStairs(int* cost, int costSize) &#123;</span><br><span class="line">   int *dp = (int *)malloc(sizeof(int) * (costSize + 1));</span><br><span class="line">   memset(dp, 0, sizeof(int) * (costSize + 1));</span><br><span class="line">   if (costSize == 2) &#123;</span><br><span class="line">       return min(cost[0],cost[1]);</span><br><span class="line">   &#125;</span><br><span class="line">   for (int i = 2; i &lt;= costSize; i ++) &#123;</span><br><span class="line">   //记录每个dp值</span><br><span class="line">       dp[i] = min(dp[i - 1] + cost[i - 1],dp[i-2] + cost[ i - 2]);</span><br><span class="line">   &#125;</span><br><span class="line">   return dp[costSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int minCostClimbingStairs(int* cost, int costSize) &#123;</span><br><span class="line">    int dpStep1 = 0,dpStep2 = 0,dpTemp = 0;</span><br><span class="line">    if (costSize == 2) &#123;</span><br><span class="line">        return min(cost[0],cost[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2; i &lt;= costSize; i ++) &#123;</span><br><span class="line">        </span><br><span class="line">        dpTemp = dpStep1;</span><br><span class="line">        //记录最近的第一个节点的dp值</span><br><span class="line">        dpStep1 = min(dpStep1 + cost[i - 1],dpStep2 + cost[i - 2]);</span><br><span class="line">        //记录最近的第二个节点dp值</span><br><span class="line">        dpStep2 = dpTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    return dpStep1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li>复杂度分析<ol>
<li>时间复杂度 O(n), n = strlen(s)，一层循环;</li>
<li>空间复杂度 优化后为O(1)，固定数量的变量。</li>
</ol>
</li>
</ol>
<h4 id="思路2：递归实现"><a href="#思路2：递归实现" class="headerlink" title="思路2：递归实现"></a>思路2：递归实现</h4><ol>
<li>关键步骤跟dp是一样的，只是逆向的方式实现。变成了最后一次爬梯是选择走一步还是走两步的问题，然后分别计算走一步的最小消耗值和走两步的最小消耗值。执行一个递归过程。计算过程中，发现走一步的很多dp值可以被走二步所用。通过存入一个数组指针存储已有步骤的dp值。这次很多dp值都会被二次利用，而不像dp只利用前面的两个dp值。</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int min(int a, int b )</span><br><span class="line">&#123;</span><br><span class="line">    return a &lt; b ? a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int subMinCostClimbingStairs(int* cost, int end,int *dp)</span><br><span class="line">&#123;</span><br><span class="line">    if (dp[end] != 0) &#123;</span><br><span class="line">        return dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">    if(end == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[end] = min(cost[0],cost[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (end == 1|| end == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[end] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">         //1步的值。</span><br><span class="line">        int a = subMinCostClimbingStairs(cost, end - 1,dp) + cost[end - 1];</span><br><span class="line">        //2步的值。这个步骤的执行已经是a有值得时候了，所以可以复用a计算过程中产生的dp值。</span><br><span class="line">        int b = subMinCostClimbingStairs(cost, end - 2,dp) + cost[end - 2];</span><br><span class="line">        //存储dp值</span><br><span class="line">        dp[end] = min(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[end];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int minCostClimbingStairs(int* cost, int costSize) &#123;</span><br><span class="line">    int *dp = (int *)malloc(sizeof(int) * (costSize + 1));</span><br><span class="line">    memset(dp, 0, sizeof(int) * (costSize + 1));</span><br><span class="line">    return subMinCostClimbingStairs(cost, costSize,dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ol>
<li>时间复杂度 大于O(n) 且小于 O(n^2)，定向比较下。</li>
<li>空间复杂度 O(1)，少量的固定的额外空间。</li>
</ol>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol>
<li>递归的执行过程还是比较抽象，调试也不方便。递归跟逆向思维联系比较大，从问题的最后一个步骤抽象，反过来递归直到达到退出条件再逐步出栈得出计算结果。而且在调试的过程中会出现内存爆炸的情况，这也是递归需要考虑的问题。可以通过复用计算的中间值减少计算量和提高效率。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-07-14-10leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-07-14-10leetcode.html" itemprop="url">算法-反转整数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-14T00:00:00+08:00">
                2018-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-07-14-10leetcode.html" class="leancloud_visitors" data-flag-title="算法-反转整数">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  542
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>给定一个 32 位有符号整数，将整数中的数字进行反转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"> </span><br><span class="line">示例 2:</span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p>
<p>注意:<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>1.从低位开始获取位数，每次存储的时候把原有值*10，低位插入到最后面。直到处理完毕。如果中途超出了数值范围则直接返回0。</p>
<ol start="2">
<li><p>判断是否超出了数值范围</p>
<ol>
<li>已知 INT_MAX = 2147483647 ,  INT_MIN = -2147483648.<br>假设当前已有计算值为rev,尚未处理完毕且当前获取的准备插入的数值为pop。<ol>
<li>如果输入值为正数，那么当 rev &gt; INT_MAX/10 或者rev/10 == INT_MAX &amp;&amp; pop&gt;7，代表超出范围。</li>
<li>如果输入值为负数，那么当 rev &lt; INT_MIN/10 或者rev/10 == INT_MIN &amp;&amp; pop &lt; -8,代表超出范围。</li>
</ol>
</li>
</ol>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x) &#123;</span><br><span class="line"> // int max = INT_MAX;//2147483647</span><br><span class="line"> // int min = INT_MIN;//-2147483648</span><br><span class="line"> int rev = 0;</span><br><span class="line"> </span><br><span class="line"> while (x != 0) &#123;</span><br><span class="line">     //获得最后一位</span><br><span class="line">     int pop = x % 10;</span><br><span class="line">     //把倒数第二位后移到第一位</span><br><span class="line">     x /= 10;</span><br><span class="line">     //判断溢出情况  结合max 和min 的值 就知道 为什么是 7 和 -8 了</span><br><span class="line">     if (rev &gt; INT_MAX / 10 || (rev/10 == INT_MAX &amp;&amp; pop &gt; 7)) &#123; return 0; &#125;</span><br><span class="line">     if (rev &lt; INT_MIN / 10|| (rev/10 == INT_MIN &amp;&amp; pop &lt; -8)) &#123;  return 0; &#125;</span><br><span class="line">     //*10整体后移一位 ，pop插入到第一位</span><br><span class="line">     rev = rev * 10 + pop;</span><br><span class="line"> &#125;</span><br><span class="line"> return rev;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li>复杂度分析<ol>
<li>时间复杂度 O(n), n为字符的长度</li>
<li>空间复杂度 O(1)，固定数量的变量。</li>
</ol>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>主要是数值范围判断的处理。也可以用一个long型来存储，最后的时候再跟INT_MAX判断。开始的想法是从高位开始获取，然后新数值先填充低位再填充高位。这个处理起来没有从低位开始获取的方便，因为新数值前移只需要乘以10即可，非常方便。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-07-07-10leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-07-07-10leetcode.html" itemprop="url">算法-最大子序和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T00:00:00+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-07-07-10leetcode.html" class="leancloud_visitors" data-flag-title="算法-最大子序和">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,350
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure></p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><h4 id="思路1：贪心算法"><a href="#思路1：贪心算法" class="headerlink" title="思路1：贪心算法"></a>思路1：贪心算法</h4><ol>
<li>连续子数组之和如果为负数，那么把它作为和的一部分反而减少了和的大小。所以当子数组之和为负数的时候进行舍弃，取下一个元素作为起点重新累加。但这样累加会存在一个问题，虽然知道起点，也知道终点，但过程中累加到哪一个元素的和为最大却不知道。只能通过每累加一个元素就计算一次和，这样就不会错过每个可能的最大值。</li>
<li>代码 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int greedMaxSubArray(int* nums, int numsSize)</span><br><span class="line">&#123;</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">    int thisMaxSum = INT_MIN;</span><br><span class="line">    for (int i = 0 ; i &lt; numsSize; i ++) &#123;</span><br><span class="line">    </span><br><span class="line">        //如何和小于0代码表示这整块都可以舍弃，因为不起到增大和的作用</span><br><span class="line">        if (thisMaxSum &lt;= 0) &#123;</span><br><span class="line">            thisMaxSum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            thisMaxSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(maxSum &lt; thisMaxSum)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSum = thisMaxSum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li>复杂度分析<ol>
<li>时间复杂度 O(n), n = strlen(s)，一层循环;</li>
<li>空间复杂度 O(1)，固定数量的变量。</li>
</ol>
</li>
</ol>
<h4 id="思路2：动态规划DP"><a href="#思路2：动态规划DP" class="headerlink" title="思路2：动态规划DP"></a>思路2：动态规划DP</h4><ol>
<li>运行到当前步骤获取到的可用和值为当前元素的值以及累加上当前元素所得的和中的最大值。获取的DP公式： maxSub(i) = getMaxSub(maxSub(i - 1) + nums[i],nums[i]);</li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//  maxSub(i) = getMaxSub(maxSub(i - 1) + nums[i],nums[i]);</span><br><span class="line">int dpMaxSubArray(int* nums, int numsSize)</span><br><span class="line">&#123;</span><br><span class="line">    int max = nums[0];</span><br><span class="line">    int sum = nums[0];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0 ; i &lt; numsSize; i ++) &#123;</span><br><span class="line">        int currentValue = nums[i];</span><br><span class="line">        if (sum + currentValue &lt; currentValue) &#123;</span><br><span class="line">            sum += currentValue;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            sum = currentValue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum&gt;max) &#123;</span><br><span class="line">            max = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ol>
<li>时间复杂度 O(n), n = strlen(s)，一层循环;</li>
<li>空间复杂度 O(1)，少量的固定的额外空间。</li>
</ol>
</li>
</ol>
<h4 id="思路3：分治递归"><a href="#思路3：分治递归" class="headerlink" title="思路3：分治递归"></a>思路3：分治递归</h4><ol>
<li>把数组分成左右两部分，那么对于这个范围，最大和可能出现在左边或者右边或者跨越两个左右部分。本轮中先给出分割点，从分割点向两边扩散遍历，获取跨越中心点最大的和值（只需要把左右部分的遍历最大值相加，有可能左边最大值为正，右边最大值为负，不用管只管相加，左边最大值会在分割后的左边某次递归中参与比较。递归有时候就是在一轮中考虑的情况变少了，有些情况是否在递归的过程中已被处理，或者说递归入参的改变就能计算出这些情况。）。方法的返回值为递归左部分、递归右部分、本轮跨越中心的最大和值三者的最大值。比较难理解的还是每一轮只计算跨越分割点的最大和值，随着范围的缩小递归起来就涵盖了所有的情况。</li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int max(int a ,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxSubArray(int* nums, int numsSize) &#123;</span><br><span class="line">    int maxSubLeft = 0;</span><br><span class="line">    int maxSUbRight = 0;</span><br><span class="line">    int maxLeft = INT_MIN;</span><br><span class="line">    int maxRight = INT_MIN;</span><br><span class="line">    </span><br><span class="line">    //推出递归条件</span><br><span class="line">    if (left == right) &#123;</span><br><span class="line">        return nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int center = (left + right) / 2 ;</span><br><span class="line">    int maxTempLeft = 0;</span><br><span class="line">    //计算当前的左相加最大值,右到左</span><br><span class="line">    for (int i = center; i &gt;= left; i --) &#123;</span><br><span class="line">        maxTempLeft += nums[i];</span><br><span class="line">        if (maxLeft &lt; maxTempLeft) &#123;</span><br><span class="line">            maxLeft = maxTempLeft;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (maxLeft == INT_MIN) &#123;</span><br><span class="line">        maxLeft = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //计算当maxTempRight   当前前右相加最大值，左到右</span><br><span class="line">    //每一个子数组都独自全部累加左右部分，那么久含括了所有的情况。</span><br><span class="line">    int  maxTempRight = 0;</span><br><span class="line">    for (int i = center + 1; i &lt;= right; i ++) &#123;</span><br><span class="line">        maxTempRight += nums[i];</span><br><span class="line">        if (maxRight &lt; maxTempRight) &#123;</span><br><span class="line">            maxRight = maxTempRight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (maxRight == INT_MIN) &#123;</span><br><span class="line">        maxRight = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    maxSubLeft = maxsubArrayRe(nums, left, center);</span><br><span class="line">    maxSUbRight = maxsubArrayRe(nums, center + 1,right);</span><br><span class="line">    </span><br><span class="line">    return max(max(maxSUbRight,maxSubLeft),maxLeft + maxRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ol>
<li>时间复杂度O(NlogN)。</li>
</ol>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol>
<li>贪心算法中，一边累加一边记录最大值，通过这样的方式而不会错过可能的最大值。我开始想的是如何确定起点和终点，想通过舍弃头尾部分获取中间部分的方式来解题，分析出舍弃的条件是累加值少于0，就是对中间部分为负增益。这个思路也许可行，但我没搞出来。而DP，就是要分析规律，关注于步骤与步骤之间的共性，得出dp方程，通过代码实现思路。分治方法中，注意的是中心向两边扩散才能正确的计算跨越左右两边之和。递归中必不可少的是，退出递归条件，上下层递归之间的联系交互是如何的（每一轮都计算出当前范围中跨越左右两边的最大值，而下一轮递归中他会计算出，左边的最大值和右边的最大值），是否涵盖是全部情况。如果采用二分法，因为是分割了范围，那么本轮处理中需要保证那些跨越切割范围的情况。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-07-07-01leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-07-07-01leetcode.html" itemprop="url">算法-Z字形变换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-07T00:00:00+08:00">
                2018-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/blog/" itemprop="url" rel="index">
                    <span itemprop="name">blog</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-07-07-01leetcode.html" class="leancloud_visitors" data-flag-title="算法-Z字形变换">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,228
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure></p>
<p>之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR”</p>
<p>实现一个将字符串进行指定行数变换的函数:</p>
<p>string convert(string s, int numRows);<br>示例 1:</p>
<p>输入: s = “PAYPALISHIRING”, numRows = 3<br>输出: “PAHNAPLSIIGYIR”<br>示例 2:</p>
<p>输入: s = “PAYPALISHIRING”, numRows = 4<br>输出: “PINALSIGYAHRPI”<br>解释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p>
<h4 id="思路1：按行排序"><a href="#思路1：按行排序" class="headerlink" title="思路1：按行排序"></a>思路1：按行排序</h4><ol>
<li>题目要求有两个，一个是字符是按Z字形排序，一个由上而下按行输出。</li>
<li>分析下Z字形的排序规律。z字形先是由上而下，到了底部再向上，每到底部或者顶部就会反弹，程序中使用bool变量lineUp记录方向。遍历字符的同时，使用一个二维数组int a[row][strlen(s)]来存储行与元素原始下标的关系。遍历完毕后，按行拼接字符串并输出。</li>
<li><p>元素的下标与输出后所在的行有这样的对应关系。</p>
<pre><code>#row #数字对应元素下标。
 0   0P      6I       12N
 1   1A   5L 7S   11I 13G
 2   2Y 4A   8H 10R
 3   3P      9I     
</code></pre></li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">char* convert(char* s, int numRows) &#123;</span><br><span class="line">if (numRows == 1) &#123;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool lineUp = true;</span><br><span class="line">int len = strlen(s);</span><br><span class="line">//记录字符的二维数组。其实可以使用int的二维数组，因为字符能自动转成asscii对应的int数字。</span><br><span class="line">char **pArr = (char**)malloc(sizeof(char*) * numRows);</span><br><span class="line"></span><br><span class="line">//这个数组是为了记录当前行最大下标，用于后面遍历。其实可以不用，在记录字符串的时候末尾添加&apos;\0&apos;用于判断就行。</span><br><span class="line">int *indexArr = (int*)malloc(sizeof(int) * numRows);</span><br><span class="line">memset(indexArr, -1, sizeof(int) * numRows);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; numRows; i++ ) &#123;</span><br><span class="line">//开始的时候设置长度为len 。在leetcode上执行报超出内存限制。分析后改为len /2 + 1,因为两行的时候最多为len / 2 + 1；超过三行字符被分散到其他行行，也不会超过len /2 + 1。修改后执行通过。</span><br><span class="line">    char *a = (char*)malloc(sizeof(char*) * (len / 2 + 1));</span><br><span class="line">    memset(a, &apos;#&apos;, sizeof(char*) * (len / 2  + 1));</span><br><span class="line">    pArr[i] = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int j = 0;</span><br><span class="line">for (int i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">    int currentIndex = indexArr[j] + 1;</span><br><span class="line">    indexArr[j] = currentIndex;</span><br><span class="line">    pArr[j][currentIndex] = s[i];</span><br><span class="line">    if (lineUp) &#123;</span><br><span class="line">        if (j == numRows - 1) &#123;</span><br><span class="line">            j --;</span><br><span class="line">            lineUp = false;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (j == 0) &#123;</span><br><span class="line">            j ++;</span><br><span class="line">            lineUp = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p = (char*)malloc(sizeof(char*) * len);</span><br><span class="line">memset(p, 0, sizeof(char*) * len);</span><br><span class="line">int jj = 0;</span><br><span class="line">for (int ii = 0; ii &lt; numRows ; ii ++)&#123;</span><br><span class="line">    char *temp = pArr[ii];</span><br><span class="line">    for (int k = 0; k &lt;= indexArr[ii]; k++) &#123;</span><br><span class="line">        p[jj++] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">free(pArr);</span><br><span class="line">free(indexArr);</span><br><span class="line"></span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li>复杂度分析<ol>
<li>时间复杂度 O(n), n = strlen(s);</li>
<li>空间复杂度 O(n)。</li>
</ol>
</li>
</ol>
<h4 id="思路2：按行访问"><a href="#思路2：按行访问" class="headerlink" title="思路2：按行访问"></a>思路2：按行访问</h4><ol>
<li>这个是对字符输入的方式分析后得出的数学规律。首尾两行成等比关系，中间的行除了等比的位置填充元素外，另外还需要在等比距离倒退一定长度offset的位置填充，offset = currentRow。</li>
<li><p>代码</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">char* convert(char* s, int numRows) &#123;</span><br><span class="line">int len = strlen(s);</span><br><span class="line">//特殊情况特殊处理</span><br><span class="line">if (len == 0 || numRows == 0 || numRows == 1 || numRows == len)</span><br><span class="line">&#123;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p = (char*)malloc(sizeof(char) * len);</span><br><span class="line">//等比间隔</span><br><span class="line">int cycleLen = 2 * numRows - 2;</span><br><span class="line">int pIndex = 0;</span><br><span class="line">for (int i = 0 ; i &lt; numRows; i ++) &#123;</span><br><span class="line">    for (int j = 0; j + i &lt; len ; j += cycleLen) &#123;</span><br><span class="line">        //获取等比位置的字符</span><br><span class="line">        p[pIndex ++] = s[i + j];</span><br><span class="line">        //获取中间行非等比位置的字符</span><br><span class="line">        if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp;  j + cycleLen - i &lt; len) &#123;</span><br><span class="line">            p[pIndex ++] = s[ j + cycleLen - i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
<li><p>复杂度分析</p>
<ol>
<li>时间复杂度 O(n), n = strlen(s);</li>
<li>空间复杂度 O(n)。如果返回字符不视为额外空间，那么空间复杂度为O(1)。</li>
</ol>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol>
<li>这道题开始也是用分析规律的方法去做，但举的例子少了点，写出来运行才发现规律是错的。后面也就没继续找数学规律。 为了避免下次犯错，找规律需要论证不少于3个例子。同时规律需要分情况讨论，例如该题的首尾两行作为一类，中间行作为一类。另外别想着用简单的规律就能处理全部问题，一般这类问题都是二级或者多级的，例如多种情况对应不同的规律，或者同一个规律要处理的多个问题。还有如果一类问题按一定方式呈现，一般会存在规律。</li>
<li>注意的地方：二维数组初始化问题；meset的使用；字符串、ASCII码、int之间的关系等。</li>
<li>部分代码可以写的更简洁，但为了更好的描述过程，暂时还是保持这个风格，有利于学习和理解。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/icon.jpg"
                alt="zengbailiang" />
            
              <p class="site-author-name" itemprop="name">zengbailiang</p>
              <p class="site-description motion-element" itemprop="description">知行合一</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a rel="external nofollow" href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zmubai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zengbailiang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">51.9k</span>
  
</div>


  <div class="powered-by">由 <a rel="external nofollow" class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("7VSaCuGNNUXrDp0aOK65w7PQ-gzGzoHsz", "l1D8p6eriduqG6aqx1f8H7ia");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
