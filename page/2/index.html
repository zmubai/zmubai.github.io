<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta name="google-site-verification" content="xdxP4Om7Pxp3OMC73kRMv2emRoA91RXOEPaKMivB_zg" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="liang&#39;s blog">
<meta property="og:url" content="https://zengbailiang.cn/page/2/index.html">
<meta property="og:site_name" content="liang&#39;s blog">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liang&#39;s blog">
<meta name="twitter:description" content="知行合一">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zengbailiang.cn/page/2/"/>





  <title> Hexo, NexT - liang's blog知行合一 </title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">liang's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-07-17回了一趟学校.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-07-17回了一趟学校.html" itemprop="url">回了一趟校园</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-14T00:00:00+08:00">
                2019-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/记事/" itemprop="url" rel="index">
                    <span itemprop="name">记事</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-07-17回了一趟学校.html" class="leancloud_visitors" data-flag-title="回了一趟校园">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,313
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="回了一趟学校"><a href="#回了一趟学校" class="headerlink" title="回了一趟学校"></a>回了一趟学校</h3><p>大概是五月份的时候回了趟学校。再次回去还是比较感慨，想去的地方很多，但时间缺有限，就选了几个比较有回忆又比较便捷的地方去走走。也许是因为大学时代值得回忆的事情太多了，又或者是怀念作为学生的时候的那份心情和青春，总之很难说清。但每每想到这些，总会非常感叹，有些事情，有些年纪只能经历一次，心态会伴随着年纪而变化，又或者其他的一些原因，总之过去的那个特定的阶段特定的事情和那份特定的心情，是后面阶段无法再重新获取的。这确实是个比较无奈的事情，但这应该是合理的，人生就应该要有不同的阶段。</p>
<h5 id="13路车"><a href="#13路车" class="headerlink" title="13路车"></a>13路车</h5><p>有些事情还是没变，但变化总是在不断的发生。熟悉的13路车还在，还是要从东区走过20分钟的上山路才到尧山校区，我很享受在车上的感受，特别是坐窗旁的位置，吹着风，看着窗外的风景。但13路好像已经都变成了空调车，窗都没了。</p>
<h5 id="尧山"><a href="#尧山" class="headerlink" title="尧山"></a>尧山</h5><p>再次上尧山， 还是爬着上。记得大一第一次爬好像是中秋节节日，那时候很多人，而再爬的当天的人很少，感觉比较冷清，可能是时间的问题吧。山上也有了不少变化，山顶走向盘山公路的路变了，中间被围起来私用了。下山的时候和朋友一起走盘山公路下山，我同样很喜欢尧山的盘山公路，有很长的一段泊油路，干净美丽。这里还是会见到小年轻，小情侣骑着小电瓶，游盘山公路。</p>
<h5 id="尧山校区"><a href="#尧山校区" class="headerlink" title="尧山校区"></a>尧山校区</h5><p>傍晚回到了尧山校区，最让我震惊的是，食堂不允许使用现金了，其实早在第一天逛东区的时候，就发现这个坑爹的问题了，比较失望，无法再尝一遍食堂的味道，但同时发现了一个事情，因为学校的数字校园毕业了依然可以用，而且还能通过支付宝充值，我尝试充了一块钱，还真可以，但我没把我的校园卡带过来，还有我也不知道我的校园卡是否还能用了，也许我的校园卡还没消磁，还有就是学校系统确实还支持，这让留给了我一些待挖掘的事情，下次我可要验证下这个问题，真够有意思的。回到话题，晚上和朋友只能去商业街吃饭了，比较随性，但同样让我震惊的是，之前的商业街那么热闹，咋这么冷清。后面了解到，学校领导做了某些限制，更规范了，但这里面可能存在很多利益问题吧，反正没了之前的热闹了。遥想当年，哪里还是很热闹，买西瓜，买菠萝，买奶茶，哎，一去不复还。大学那几年，最开始有男生宿舍那边的阳光商业街，有靠近女生宿舍的职工宿舍楼下的店铺。特别是教职工楼下的奶茶店之类的店铺，那时候那些地方就有一些特殊的气氛，仿佛有一种爱情的荷尔蒙，是谈情说爱的地方，也是经常见到情侣的地方，当然更多的是虐狗的地方了。可悲的是，大学四年，我被虐足四年，还乐此不疲。<br>如今，阳光商业街没了，有了新商业街，现在新商业街又被搞萧条，职工楼下的小店也都禁止了营业，另外又在原阳光商业街哪里搞了一个新阳光商业街。对比这些吃吃喝喝的，仿佛当年更气氛更好，但他们没有经历过当年，所以就算真的如我所想的那样，对于他们来说最丰富有趣的依然是他们现在所感受到的。</p>
<h5 id="花江"><a href="#花江" class="headerlink" title="花江"></a>花江</h5><p>还有的是，以前可以在学校旁的花江划竹筏，烧烤，现在由于建了新的教职工园区，在花江上搭了座桥，导致不能划竹筏了。那些年满是笑语的地方没了。另外那些烧烤场地，也无法烧烤了，看到这样，有点说不出味道。也许因为这些没有了，会失去一些趣味吧。不可否认可能是因为现在的娱乐方式变得跟以前不太一样了，才导致这些变化，但具体怎么样，就不太清楚了，毕竟现在已经是00后的大学时代了。最后，最后，让我不得不吐槽的是，学习的男女比例好像更均衡了，情侣比例好像更高了，虽然这是好事啊，但这让我失去了一种熟悉感。</p>
<p><img src="/personImg/guet1.jpeg" alt="guet1.jpeg"></p>
<p>这里承载了一生仅有的一次大学时光，也是我人生中的一段美好时光，怀念、感恩。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-07-14本地加密方案.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-07-14本地加密方案.html" itemprop="url">iOS 本地数据安全存储方案探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-14T00:00:00+08:00">
                2019-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-07-14本地加密方案.html" class="leancloud_visitors" data-flag-title="iOS 本地数据安全存储方案探索">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,063
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>一般app都支持本地记录登录状态，并支持离线的情况下加载用户数据，为了满足这样的场景，就需要把相关信息保存到本地。对于iOS持久化方面，无论使用userDefault、plist文件、归档、数据库等存储方式，都需要考虑一个问题，如何安全的存储数据？对于这个问题，可以对数据加密保存，至于选择哪种持久化方式，并不是那么重要。</p>
<h5 id="加密方案"><a href="#加密方案" class="headerlink" title="加密方案"></a>加密方案</h5><p>说到对数据进行加密，那么肯定是要有一套安全的加密方案才行。以下是一些方案例子：<br>A. 一些摘要算法或编码处理。<br>B. 使用特定的秘钥执行某种对称加密。<br>C. 使用特定的公私钥执行某种非对称加密。<br>D. 某种自定义加密算法。<br>对于A，这只是一种把明文转为非明文的一种方式。摘要算法不可逆，但数据无法还原，不符合需求。编码处理，可以反编码还原明文，实际上数据并没有变得更安全，也是不符合需求。但采用编码的方式，还是比直接使用明文要好那么一点点。<br>对于B.使用公开的对称算法进行加解密，只要保证秘钥的安全，是可行的。<br>对于C.同B，但相对于对称加密，非对称加密效率较低，所以在保证秘钥安全的前提下，选择B，而不是选择C。但C的安全系数会比B高。两者都已经满足数据破解的成本超过其获取的价值的要求。<br>对于D，自定义算法，就要具体分析了， 破解难度因算法本身设计有关，但这个一般都是比较有实力的公司才这么搞吧，但一般都安全性比较高。是最好的方案之一，但其存在一定设计成本和测试成本。</p>
<h5 id="从安全范围的角度去考虑"><a href="#从安全范围的角度去考虑" class="headerlink" title="从安全范围的角度去考虑"></a>从安全范围的角度去考虑</h5><p>到了这里，又面临了一个秘钥安全的问题，一般来说，我们可能会把秘钥硬编码到代码中，但我们的二进制文件存在一个字符串常量区，只要这个字符串在代码中被引用了，那么编译器就会把其写进字符串常量区。如果这样，稍微的分析下二进制文件，就可能把秘钥获取。所以秘钥硬编码是比较危险的。面对这个问题，可以通过把秘钥分拆成多个字符串，再通过某些处理生成真正的秘钥，来提高安全性。这里会存在一个更值得思考的问题，为了引出这个问题，先回归到方案的探索。</p>
<p>到目前为止讨论到的都是本地怎么安全保存数据，到如何安全保存秘钥，都是围绕着单体方案去考虑，而没有从整体上去考虑。从安全范围的角度去考虑，如果在每一个客户端都是同样的加密算法，同样的秘钥，那么只要其中一个被破解，整个大厦立马倒塌。</p>
<p>为此，可以给安卓和苹果分别分配不同的秘钥，这样就能把两个平台，这块的安全性隔离。既然有了这样的想法，那么前进一步，如果每个客户端都拥有不同的秘钥，并且是一种随机秘钥（随机安全性更高，当然可能伪随机，虽然伪随机实际上是通过算法来生成的，有规律，但其破解难度很大），那么就能把这块的安全性做到客户端隔离。</p>
<h5 id="最终选择的方案："><a href="#最终选择的方案：" class="headerlink" title="最终选择的方案："></a>最终选择的方案：</h5><p>使用AES对称加密算法；使用随机算法生成本地秘钥，秘钥中添加时效性信息，并保存到keyChain中。</p>
<p>优点：客户端隔离、对称加解密效率高，随机秘钥破解难度大。<br>缺点：由于客户端隔离，秘钥都不一样，数据无法统一分析，因此也影响了适用场景。</p>
<p>demo:<a href="https://github.com/zmubai/LocalEncryptDemo" target="_blank" rel="noopener">LocalEncryptDemo</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-07-14安全思考.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-07-14安全思考.html" itemprop="url">iOS 移动端 安全思考与总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-02T00:00:00+08:00">
                2019-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-07-14安全思考.html" class="leancloud_visitors" data-flag-title="iOS 移动端 安全思考与总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,577
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="iOS-移动端-安全思考"><a href="#iOS-移动端-安全思考" class="headerlink" title="iOS 移动端 安全思考"></a>iOS 移动端 安全思考</h3><p><img src="https://upload-images.jianshu.io/upload_images/1690665-9e69d9eb90759663.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="v2-510e2d2a1aae6e5ced9f1b142b33af0a_r (1).jpg"></p>
<p>这是一遍安全知识总结的博客，并涉及相关知识的延伸，以作知识备忘和总结。</p>
<ul>
<li>安全相关的几个方面：</li>
</ul>
<ol>
<li>敏感数据输入安全</li>
<li>外部调用，和对外数据安全</li>
<li>本地数据存储安全</li>
<li>网络数据传输安全</li>
<li>app代码安全</li>
</ol>
<h4 id="以下分别对每一点展开"><a href="#以下分别对每一点展开" class="headerlink" title="以下分别对每一点展开"></a>以下分别对每一点展开</h4><h3 id="1-敏感数据输入安全"><a href="#1-敏感数据输入安全" class="headerlink" title="1.敏感数据输入安全"></a>1.敏感数据输入安全</h3><ul>
<li><p>textField密码模式与自定义键盘</p>
<p>  敏感数据主要是指密码信息或者使用户的个人信息、交易信息等。当我们输入密码的时候一般会打开textField的密码输入模式，这时候是会强制使用系统键盘，并且密码输入后不可见。如果苹果对系统键盘没有做数据获取，那么这相对安全的，不存在数据泄漏。但这个代码不是开源的，所以也是不敢打包票的。所以我们常见的一些银行app会去实现私有键盘，同时会打乱数字字母的位置。这里面大概有两个考虑，一个是防止键盘数据监听，另一个是防止第三者通过观察用户输入手势猜测密码。</p>
<p>  然而iOS是苹果的系统，如果苹果硬要监控数据，那么怎么都是没办法避免的，除非不用iOS系统。但这个本来就与苹果的立场相悖的。所以一些app实现私有键盘，个人认为主要是防止第三者通过观察用户输入手势的手段，猜测出密码。另外自定义键盘每个按钮点击的时候不显示视觉变化。如果在点击的时候样式发生变化，同时手机被录屏了，那么视频中就能看到密码输入的具体字符和顺序，导致密码泄露。</p>
</li>
<li><p>第三方键盘完全访问</p>
<p>  另外使用第三方键盘，特别是在运行完全访问之后，存在安全风险。允许完全访问后，第三方键盘能把用户输入的数据发送到自家后台（就算开始不允许完全访问，后面再允许，之前的输入数据也会被上传。因为不允许完全访问的时候，第三方键盘能把输入数据保存到本地，当获取到完全访问的时候再把这部分数据上传）。收集这个数据能对键盘的输入体验进行优化，主要是自动更正功能和根据用户的习惯匹配出更高频率的词语。但风险是时刻存在的，这个需要用户对体验的优化与承受的风险之间做权衡。但保守策略，安全起见，最好还是不允许键盘的完全访问。link:<a href="https://spiim.com/blog/about-full-access.html" target="_blank" rel="noopener">iOS 8 第三方键盘“完全访问”的那些事</a></p>
</li>
<li><p>键盘缓存</p>
<p>  当用户使用系统键盘，并开启自动更正功能的时候，系统就会把键盘的输入记录到系统的一个特定路径的文件中（/private/var/mobile/Library/Keyboard/dynamic-text.dat），并且该文件是明文存储。所以获取到文件内容，并加以分析，就有可能获取到用户的密码信息等。但这里有一个前提，必须是越狱手机才能获取，因为存在沙盒机制，应用是无法访问到该目录的文件的。基于这一点，使用自定义键盘就可以避免被输入被缓存。<br>link:<a href="https://www.ctolib.com/docs-ios-security-defense-c-keyboard-cache.html" target="_blank" rel="noopener">键盘缓存与安全键盘</a>    </p>
</li>
<li><p>安全策略：</p>
<ol>
<li>输入密码设置textField的密码输入模式。</li>
<li>安全性更好的，实现私有键盘，每次打乱键值顺序，控件不实现点击效果。</li>
<li>不允许第三方键盘的完全访问。</li>
</ol>
</li>
</ul>
<h3 id="2-外部调用，和对外数据安全"><a href="#2-外部调用，和对外数据安全" class="headerlink" title="2. 外部调用，和对外数据安全"></a>2. 外部调用，和对外数据安全<br></h3><ol>
<li>外部调用是指，其他应用唤起app的行为。主要是通过scheme来唤起。通常app内部是有处理外部调用的逻辑的，并能根据scheme后面拼接的参数来跳转到不同的业务模块。那么这里就有可能存在逻辑漏洞，特别对于重要的涉及用户金钱或隐私的模块，需要有一套严谨的参数校验规则，避免漏洞发生。个人认为这种提供给外部的入口，都是app安全的一个隐患，所有必须要有一个严谨的权限校验规则。</li>
<li><p>对外数据，指通过各种途径能被外部获知的数据。这里主要是app退到后台显示的截图，因为实在不知道这个归类到哪里，就归类到对外数据。系统截图是系统为了提供用户体验的手段，但可能无意中泄漏了重要信息。故这里要进行处理，第一种可以禁止截图，那么推到后台把keyWindows隐藏，那么系统的截图就变成黑色；另外一种就是手动替换截图，一般会对截图进行模糊化。</p>
</li>
<li><p>安全策略</p>
<ol>
<li>外部发起调用，需要有一套完善的鉴权机制。</li>
<li>系统截图，需要手动替换。</li>
</ol>
</li>
</ol>
<h3 id="3-本地数据存储安全"><a href="#3-本地数据存储安全" class="headerlink" title="3. 本地数据存储安全"></a>3. 本地数据存储安全</h3><p>本地数据如果明文保存的话，是不安全的。虽然有沙盒机制的保护，但如果手机被越狱了，那么数据就暴露了。所以，重要信息需要进行加密保存。可以采用aes进行加密，base64编码后进行保存。这样就算数据被获取，也无法得到有用信息。由于这里使用aes加密，那么如何安全保存加密秘钥是一个重要的问题。因为如果秘钥被破解了，那么数据就被破解了。因为本地数据加解密都在本地进行，所以秘钥作用范围也仅限于本地数据。一般可以使用两种方式提供秘钥：第一种hardCode秘钥，第二种本地生成秘钥，再保存本地。下面对安全性方案进行讨论：</p>
<ol>
<li><p>hanrdCode秘钥：<br></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//形如：</span><br><span class="line">static NSString *aesPriKey = @&quot;xxx0xxx0xxx0xxx0xxx0&quot;;</span><br></pre></td></tr></table></figure>
<p> 这看起来好像没什么问题，但这种hardCode的方式，很容易被获取。获取方式：使用逆向技术对app进行砸壳（例如pp助手下载的app已经砸壳），并使用使用machOViewer<br> 查看APP的二进制文件，就能获取到字符串常量（前提是这个字符有被引用，否则编译器貌似会优化掉。但我们加密的秘钥怎么可能会不引用呢，测试的时候发现的现象，顺便记录下）。</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1690665-28e536782b2bf45e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果写入到文件中，然后在运行过程中通过读文件的方式获取秘钥，那么也是不安全的，秘钥不能直接保存到文件中，但难道要把秘钥加密保存到文件中，那么用于加密的秘钥怎么保证安全，这就变成了鸡生蛋蛋生鸡的问题了。可以尝试直接对秘钥加盐然后编码存储到文件中，这样只要加盐规则和编码规则足够复杂也是相对安全的。</p>
<ol start="2">
<li><p>本地生成秘钥<br> 由于这个秘钥保存的问题，个人在开发中使用的方案是，本地生成随机秘钥，并把秘钥保存到系统keychain中,同时可以设置秘钥的有效时间。这样设计有两个好处，一个生成随机秘钥，能保证每台手机的秘钥不一样，这样能缩窄影响范围，第二个是由于时效性的存在，当然这个时效性只能引用于用户登录信息等功能，但它增加了秘钥破解的难度。除非破解了代码逻辑并成功获取到keychain的秘钥，同时破解苹果的加密算法，才有可能破解整套策略，所以是相对安全的。在这个过程中，我们甚至可以对生成的秘钥加盐，但我认为这个貌似没必要，如果加盐是常量字符串，反而能从分析二进制文件常量字符中顺藤摸瓜找到相关的加密逻辑，留下多余线索。</p>
</li>
<li><p>安全策略：    </p>
<ol>
<li>不使用常量字符串定义秘钥。如果确实是固定的秘钥，那么要使用一套混淆规则混淆秘钥，使用的时候再对秘钥进行反混淆，例如 salt1 +  原始秘钥 + salt2 再两次base64生成新的字符串作为常量保存。使用的时候，base64Decode两次再获取中间的元素秘钥。规则应该多变的，不要全部一致，否则这个混淆就没有意义了。</li>
<li>本地秘钥随机生成（可以使用arc4random(),这里不要使用时间戳作为随机种子，因为时间戳是有规律的。但时间戳可以作为信息添加到秘钥中，作为有效时间的判断。）同时生成的秘钥以密码的形式保存到系统的keyChain中，这样苹果会对秘钥进行加密并保存到keyChain中。可采用aes128/192/256(秘钥长度分别为16/24/32byte,128/192/256bit) + base64编码的加密方案。</li>
</ol>
</li>
</ol>
<p><strong>aes的相关说明</strong></p>
<p>aes是一种分组密码算法。   以下摘录维基百科对分组密码的一些重要描述,包括分组密码的概念，还有算法的设计原则中两个重要因素扩散和扰乱。其中还谈到每一轮都使用不同的子秘钥，这样会大大增加区块之间的关联性，让破解难度变高，而几种加密模式中ecb电密码本模式并没有使用这种设计思想去实现加密，下面会谈到多种加密模式。</p>
<blockquote>
<p>维基百科</p>
<blockquote>
<p>在密码学中，分组加密（英语：Block cipher），又称分块加密或块密码，是一种对称密钥算法。它将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>迭代产生的密文在每一轮加密中使用不同的子密钥，而子密钥生成自原始密钥。</p>
<p>设计原则:<br><strong>扩散（diffusion）</strong>和<strong>扰乱（confusion）</strong>是影响密码安全的主要因素。扩散的目的是让明文中的单个数字影响密文中的多个数字，从而使明文的统计特征在密文中消失，相当于明文的统计结构被扩散。扰乱是指让密钥与密文的统计信息之间的关系变得复杂，从而增加通过统计方法进行攻击的难度。扰乱可以通过各种代换算法实现。</p>
</blockquote>
</blockquote>
<p><strong>分组密码工作模式</strong></p>
<p>分组密码工作模式，常用模式有五种：电子密码本ECB、密码块链接CBC、填充密码块链接PCBC、密文反馈CFB、输出反馈OFB、计数器模式CTR。另外还有相关的很重要的几个概念，分别是加密向量IV和块填充模式PADDING。维基百科概关于分组密码工作模式的概要说的很精辟。</p>
<blockquote>
<p>维基百科 -分组密码工作模式</p>
<blockquote>
<p>密码学中，分组（block）密码的工作模式（mode of operation）允许使用同一个分组密码密钥对多于一块的数据进行加密，并保证其安全性。分组密码自身只能加密长度等于密码分组长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适填充方式将数据扩展到匹配密码块大小的长度。一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全[1]。</p>
</blockquote>
</blockquote>
<p>对于AES来说，块的固定长度为128bit,秘钥长度为128/192/256bit（这个涉及到编码细节，例如不知道这个，就不知道秘钥的长度，可能导致编码错误）。由于块的长度固定为128，所以就存在最后一个块填充的问题，这涉及到块的填充模式PADDING,加密解密都需要用同样的的块填充模式去处理最后的块（涉及到编程细节，块填充模式的选择）。加密的时候是对明文切分成若干组，每组长度都等于128位。aes会对每一组进行多轮加密。其过程包括若干步骤，轮秘钥加、字节替换、行位移、列混合、轮秘钥加，并且根据秘钥的位数不同分别对应不同的轮数（位数/轮数）128/10，192/12,256/14。密码学的东西不太好啃，数学渣渣表示啃不动，需要比较好的数学基础才能比较畅顺的理解其加密过程的每个步骤，但我觉得十几步的加密过程和多轮的加密，应该是围绕扩散和扰乱两点出发，来提高算法的破解难度的。</p>
<p><strong>ECB模式与CBC模式</strong></p>
<p>挑选ECB和CBC模式分析，加深对分组密码工作模式的理解，直观对比两模式的差异，并简要说明下使用IV的原因。</p>
<p>ECB模式：<br>把明文划分为长度相等的块128bit,并对每个块独立加密，最后拼接成为完整的加密密文。<br>由于每个块都是使用同一个秘钥独立加密，块与块之间没有关联性，对于同样的明文块（不管其在整个块集合中那个位置）加密产生的密文都是一样的，因此更有规律性，不能很好隐藏数据。</p>
<p>CBC模式：<br>同样先划分块，加密的时候CBC每个明文块与前一个密文块进行异或后再进行加密。这样每个块都依赖其前面的块，内部是联动的，这样的话，存在明文系统的块，加密出来的结果也是不一样的，从这一点来看比ECB安全性更高。但这里存在一个问题，就是如果第一个块内容一样，那么对于共同的明文前缀加密出来的结果也是一样的，如果这样，反而变成了破解的一个入口。为了解决这种情况，这个时候上面提到的重要元素向量IV就派上用场了，第一个块加密加入向量的参与，主要确保每一个条消息独有的一个向量，那么就能保证密文的唯一性。缺点：由于块之间存在依赖导致其加密过程是串行的，并且消息必须被填充到块大小的整数倍。</p>
<p>aes的加密原理：aes支持三种秘钥长度分别是128/192/256位，对应字符串长度为16/24/32。加密的时候是对明文切分成若干组，每组长度都等于128位。aes会对每一组进行多轮加密。其过程包括若干步骤，轮秘钥加、字节替换、行位移、列混合、轮秘钥加，并且根据秘钥的位数不同分别对应不同的轮数（位数/轮数）128/10，192/12,256/14。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86" target="_blank" rel="noopener">维基百科-AES</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科-分组密码工作模式</a></p>
<p><strong>关于随机数</strong></p>
<blockquote>
<p>维基百科-随机数</p>
<blockquote>
<p>根据密码学原理，随机数的随机性检验可以分为三个标准：<br><strong>1.统计学伪随机性</strong>。统计学伪随机性指的是在给定的随机比特流样本中，1的数量大致等于0的数量，同理，“10”“01”“00”“11”四者数量大致相等。类似的标准被称为统计学随机性。满足这类要求的数字在人类“一眼看上去”是随机的。<br><strong>2.密码学安全伪随机性</strong>。其定义为，给定随机样本的一部分和随机算法，不能有效的演算出随机样本的剩余部分。<br><strong>3.真随机性</strong>。其定义为随机样本不可重现。实际上衹要给定边界条件，真随机数并不存在，可是如果产生一个真随机数样本的边界条件十分复杂且难以捕捉（比如计算机当地的本底辐射波动值），可以认为用这个方法演算出来了真随机数。但实际上，这也只是非常接近真随机数的伪随机数，一般认为，无论是本地辐射、物理噪音、抛硬币……等都是可被观察了解的，任何基于经典力学产生的随机数，都只是伪随机数。</p>
</blockquote>
</blockquote>
<p>随机数分类：<br></p>
<ol>
<li>伪随机数：满足第一个条件的随机数。<br></li>
<li>密码学安全的伪随机数：同时满足前两个条件的随机数。可以通过密码学安全伪随机数生成器计算得出。<br></li>
<li>真随机数：同时满足三个条件的随机数。</li>
</ol>
<p><strong>重点是</strong>：随机数在密码学中非常重要，保密通信中大量运用的会话密钥的生成即需要真随机数的参与。如果一个随机数生成算法是有缺陷的，那么会话密钥可以直接被推算出来。真正的随机数是使用物理现象产生的：比如掷钱币、骰子、转轮、使用电子组件的噪音、核裂变等等。这样的随机数生成器叫做物理性随机数生成器，它们的缺点是技术要求比较高。<br>在实际应用中往往使用伪随机数就足够了。这些数列是“似乎”随机的数，实际上它们是通过一个固定的、可以重复的计算方法产生的。它们不真正地随机，因为它们实际上是可以计算出来的，但是它们具有类似于随机数的统计特征。这样的生成器叫做伪随机数生成器。<br>在真正关键性的应用中，比如在密码学中，人们一般使用真正的随机数。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0" target="_blank" rel="noopener">维基百科-随机数</a></p>
<p><strong>关于加盐</strong></p>
<blockquote>
<p>维基百科-盐</p>
<blockquote>
<p>盐（Salt），在密码学中，是指在散列之前将散列内容（例如：密码）的任意固定位置插入特定的字符串。这个在散列中加入字符串的方式称为“加盐”。其作用是让加盐后的散列结果和没有加盐的结果不相同，在不同的应用情景中，这个处理可以增加额外的安全性。</p>
</blockquote>
</blockquote>
<p>作用：提高数据安全性， 加盐后再通过散列算法得出特征值，不能直接通过彩虹表暴力破解出原数据，在验证用户密码的场景下，极大的提高了安全性。但同时因为要校验用户密码，所以需要保存这个盐值。</p>
<p>以下为维基百科相关描述<br><br>通常情况下，当字段经过散列处理（如MD5），会生成一段散列值，而散列后的值一般是无法通过特定算法得到原始字段的。但是某些情况，比如一个大型的彩虹表，通过在表中搜索该MD5值，很有可能在极短的时间内找到该散列值对应的真实字段内容。<br>加盐后的散列值，可以极大的降低由于用户数据被盗而带来的密码泄漏风险，即使通过彩虹表寻找到了散列后的数值所对应的原始内容，但是由于经过了加盐，插入的字符串扰乱了真正的密码，使得获得真实密码的概率大大降低。</p>
<p>所以在某些业务场景下可以考虑使用加盐的方式提高数据安全性。</p>
<h3 id="4-网络数据传输安全"><a href="#4-网络数据传输安全" class="headerlink" title="4. 网络数据传输安全"></a>4. 网络数据传输安全</h3><p>移动数据通过网络传输主要是面临几个风险：1.窃听风险。2.篡改风险。3.冒充风险。<br>那么可以认为如果没有以上风险，传输就是安全的。s<br>在民用领域网络通信一般都是使用http，https，又或者使用socket的tcp udp通讯，另外还有一些私有协议（微信、qq）。对于敏感数据的传输，使用http是不安全的（除非先自己加密一遍再传输），而在不使用私有协议的前提下，为了保证安全性，一般会使用https。https依赖于第三方权威机构证书认证和非对称算法，能使clien和server相互确认身份，安全生成第三个随机数，并协商出用于对称加密的会话密秘钥，进行安全的对称加密传输（<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">https原理说明</a>），我认为安全生成了会话秘钥后，在没有秘钥的情况下无法解开密文的，这样就能有效防止了窃听风险，篡改风险和冒充风险。首先无法解密就能避免窃听和冒充，而篡改，或者你可以把内容换掉，但这会导致解密失败，就算解密成功也是没有意义的内容，无关紧要。</p>
<p>但在使用https的情况下，有几个点还是需要注意一下：</p>
<ol>
<li>https可以使用自签名证书，这种情况通过浏览器请求，地址栏开头一般会出现一个✘的图标，代表这个请求是不授信的，有些浏览器会提示风险并询问是否继续访问。但如果你在系统中添加了相关的根证书并设置信任，那么这个请求就会被认为是合法的。所以，往系统中添加证书需要慎重。</li>
<li>客户端编码的时候，要根据服务器的证书情况（权威认证证书，还是自签名证书）设置合理的证书校验规则。编码涉及的点：1.是否校验域名；2.是否校验有效期；3.具体的校验策略。如果是使用AFNetWorking,涉及到的编码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//配置请求Manager是创建安全策略对象</span><br><span class="line">//暂时忽略PinningMode的选择</span><br><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:xxxx];</span><br><span class="line"></span><br><span class="line">//是否校验域名，3.0版本默认为YES。</span><br><span class="line">securityPolicy.validatesDomainName=NO;</span><br><span class="line"></span><br><span class="line">//是否允许无效证书（包括不校验证书有效期）。假设你想通过设置这里，来跳过校验有效期的话，在AFSSLPinningModeNone和AFSSLPinningModePublicKey是有效的，但AFSSLPinningModeCertificate是无效的，AFSSLPinningModeCertificate是一定会去校验证书是否有效，然后再去验证证书链，这里还是存在一定的疑惑，或许我可以给作者提一个issue。</span><br><span class="line">securityPolicy.allowInvalidCertificates=NO;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>简述AFSecurityPolicy三种模式</strong></p>
<ol>
<li>AFSSLPinningModeNone<br>选择该模式，当设置allowInvalidCertificates为YES时，会去校验证书有效期，会使用系统内置的权威机构根证书去校验客户端证书是否合法。但如果allowInvalidCertificates设置为NO，不进行合法性校验校验，方法返回值直接返回YES）。</li>
<li>AFSSLPinningModePublicKey<br>读取内嵌所有cer（DER编码）文件，并提取全部publicKey,判断客户端证书的publicKey是否被包含。<br>3.AFSSLPinningModeCertificate<br>读取内嵌所有cer（DER编码）文件，并判断端客户端证书内容是否被包含，只要证书链中其中一个证书被包含即可。因为客户端证书是由其上级证书签发的，而其上级证书是由服务器证书直接或者间接签发的，重点是上级证书能校验下级证书的合法性，换句话说如果客户端的上级证书被包含了，那么就能确认客户端证书的合法性。为了提高代码效率可以直接包含客户端证书或者客户端证书的上级证书。</li>
</ol>
<p><strong>小结：三种安全策略</strong></p>
<ol>
<li>allowInvalidCertificates = YES ;+ AFSSLPinningModeNone; + validatesDomainName = YES（必须为YES，否则不安全；这样可以防止数据被篡改，但可以被抓包，数据还是会泄漏。）; </li>
<li>allowInvalidCertificates = NO；+ AFSSLPinningModePublicKey; + validatesDomainName = YES/NO（某些情况下，证书域名不匹配所有客户端请求，此时需要配置为NO）;</li>
<li>AFSSLPinningModeCertificatev；+ alidatesDomainName = YES/NO（同上）;</li>
</ol>
<p>下图为越狱版支付宝包内容展示，可见里面内嵌了pem编码格式的证书，包含了base64格式的公钥。<br><img src="https://upload-images.jianshu.io/upload_images/1690665-b7286c7a9af90258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//命令行查看证书内容：</span><br><span class="line">zmubaiMacBook:AlipayWallet.app zengbailiang$ cat opensdk_public.pem </span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCtDVxvZhDT6FNaBqZ/Js2h7G7j</span><br><span class="line">v88UjsRlv2qDHpobSqzqe/PAbfmHZNvOOlR07l9k8GJMUp4v4z+hTy4pjypmB1St</span><br><span class="line">nt5nulRHIbcUSQ3LsT3rETJGVsGBEkvIeZXHFRDK5UmeUO9IgiviwAthgvLnDM9S</span><br><span class="line">ZOa9QCTROfibnpYWVQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>
<p>参考链接：<br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a><br><a href="https://baike.baidu.com/item/X.509/2817050" target="_blank" rel="noopener">X.509公钥证书格式标准，对证书链的验证过程有很好的说明</a><br><a href="http://www.cocoachina.com/ios/20140916/9632.html" target="_blank" rel="noopener">AF证书校验部分源码说明</a></p>
<h3 id="5-app代码安全"><a href="#5-app代码安全" class="headerlink" title="5. app代码安全"></a>5. app代码安全</h3><p>这部分主要是涉及到开发期的代码混淆、加固技术。逆向加固方面的知识了解的比较少，也就不做什么记录了。但仍然需要记录下一些主要的点。</p>
<p>提高代码安全，增强逆向难道的一些手段</p>
<ol>
<li>类名、方法名、属性名混淆。（但混淆过度，可能导致审核被拒）</li>
<li>重要函数使用c（依然能被hood，使用fishhook等工具），内联静态函数安全性更高。</li>
<li>加密重要的字符串，避免砸壳后直接分析获取重要信息。（这方面有开源库）</li>
<li>使用加固工具，或第三方加固服务（UAObfuscatedString编译插件、爱加密、360加固等。）</li>
</ol>
<p>相关文章参考：<br><a href="https://www.jianshu.com/p/bff550b3ead4" target="_blank" rel="noopener">对 iOS app 进行安全加固</a></p>
<h4 id="总结：孙子兵法有言知己知彼，方可百战百胜。安全攻防就是这样的一个东西，要去了解哪些攻击破解手段，才能更好的实施应对手段。"><a href="#总结：孙子兵法有言知己知彼，方可百战百胜。安全攻防就是这样的一个东西，要去了解哪些攻击破解手段，才能更好的实施应对手段。" class="headerlink" title="总结：孙子兵法有言知己知彼，方可百战百胜。安全攻防就是这样的一个东西，要去了解哪些攻击破解手段，才能更好的实施应对手段。"></a>总结：孙子兵法有言知己知彼，方可百战百胜。安全攻防就是这样的一个东西，要去了解哪些攻击破解手段，才能更好的实施应对手段。</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-03-10sdimage设计分析.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-03-10sdimage设计分析.html" itemprop="url">SDWebImage设计思路分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T00:00:00+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-03-10sdimage设计分析.html" class="leancloud_visitors" data-flag-title="SDWebImage设计思路分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,151
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="一、库功能"><a href="#一、库功能" class="headerlink" title="一、库功能"></a>一、库功能</h5><p>主要提供了网络图片异步下载的功能。使ui展示大量网络图片的时候，能不堵塞主线程，保存界面流畅；同时，能有策略的异步下载图片，并正确的赋值到对应的控件上。sd库在异步下载的基础上，提供了磁盘缓存，提供了图片异步解压，尽可能的提高界面的体验。<br>官方地址:<a href="https://github.com/SDWebImage/SDWebImage" target="_blank" rel="noopener">https://github.com/SDWebImage/SDWebImage</a></p>
<h5 id="二、整体需求"><a href="#二、整体需求" class="headerlink" title="二、整体需求"></a>二、整体需求</h5><ul>
<li><p>需求：imageview 把url作为入参，发起图片异步下载并在下载完毕后回调显示。</p>
</li>
<li><p>功能细分</p>
<ol>
<li>图片完成下载后要正确的赋值给调用的控件，也即两者中要建立一个一对一的绑定关系。</li>
<li>图片异步下载的实现<ol>
<li>包括单个下载的请求组装，状态控制，回调处理，图片预解压等。</li>
<li>请求并发控制。</li>
</ol>
</li>
<li>图片缓存机制的实现<ol>
<li>磁盘读写io的安全控制。</li>
<li>磁盘管理的安全策略设计。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h5 id="三、-技术的实现"><a href="#三、-技术的实现" class="headerlink" title="三、 技术的实现"></a>三、 技术的实现</h5><ul>
<li>通过创建对应的id <sdwebimageoperation> operation,回调中对imageView赋值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span><br><span class="line">                  placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(nullable NSString *)operationKey</span><br><span class="line">             internalSetImageBlock:(nullable SDInternalSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(nullable NSDictionary&lt;NSString *, id&gt; *)context &#123;</span><br><span class="line">  SDWebImageManager *manager = [context objectForKey:SDWebImageExternalCustomManagerKey];</span><br><span class="line">        if (!manager) &#123;</span><br><span class="line">        ///通过单例创建全局的SDWebImageManager</span><br><span class="line">            manager = [SDWebImageManager sharedManager];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ///每一个imageView的setImage操作对应的生成一个实现了SDWebImageOperation协议的operation. SDWebImageOperation中有一个cannel方法，用于cannel下载行为。</span><br><span class="line"> id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">            __strong __typeof (wself) sself = wself;</span><br><span class="line">            if (!sself) &#123; return; &#125;</span><br><span class="line"></span><br><span class="line">///省略</span><br><span class="line">            </span><br><span class="line">            UIImage *targetImage = nil;</span><br><span class="line">            NSData *targetData = nil;</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set</span><br><span class="line">                targetImage = image;</span><br><span class="line">                targetData = data;</span><br><span class="line">            &#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">                // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set</span><br><span class="line">                targetImage = placeholder;</span><br><span class="line">                targetData = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dispatch_main_async_safe(^&#123;</span><br><span class="line">                if (group) &#123;</span><br><span class="line">                    dispatch_group_enter(group);</span><br><span class="line">                &#125;</span><br><span class="line">                ///进行赋值</span><br><span class="line">                [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:cacheType imageURL:imageURL];</span><br><span class="line">                if (group) &#123;</span><br><span class="line">                    // compatible code for FLAnimatedImage, because we assume completedBlock called after image was set. This will be removed in 5.x</span><br><span class="line">                    BOOL shouldUseGroup = [objc_getAssociatedObject(group, &amp;SDWebImageInternalSetImageGroupKey) boolValue];</span><br><span class="line">                    if (shouldUseGroup) &#123;</span><br><span class="line">                        dispatch_group_notify(group, dispatch_get_main_queue(), callCompletedBlockClojure);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        callCompletedBlockClojure();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    callCompletedBlockClojure();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</sdwebimageoperation></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">///这个方法内部包含缓存获取和发起下载的相关逻辑</span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                     options:(SDWebImageOptions)options</span><br><span class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    // Invoking this method without a completedBlock is pointless</span><br><span class="line">    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">    // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won&apos;t</span><br><span class="line">    // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span><br><span class="line">    if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    operation.manager = self;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        LOCK(self.failedURLsLock);</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">        UNLOCK(self.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url];</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations addObject:operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    ///根据规则生成缓存key</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">    SDImageCacheOptions cacheOptions = 0;</span><br><span class="line">    if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">    if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</span><br><span class="line">    if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line">    </span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line">    ///去获取缓存，并在内部根据option参数判断后续的缓存处理和下载行为</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key options:cacheOptions done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // Check whether we should download image from network</span><br><span class="line">        BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))</span><br><span class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</span><br><span class="line">            &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]);</span><br><span class="line">        if (shouldDownload) &#123;</span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">                // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">                [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // download if no image or requested to refresh anyway, and download allowed by delegate</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">            </span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                // force progressive off if image already cached but forced refreshing</span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle</span><br><span class="line">            __weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            ///发起下载，并保存downloadToken值，以便能找到对应的dowanLoadOperation，去执行cannel操作等。这个会在cannel操作方法中很直观的看到。</span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;</span><br><span class="line">                if (!strongSubOperation || strongSubOperation.isCancelled) &#123;</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125; else if (error) &#123;</span><br><span class="line">                    [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock error:error url:url];</span><br><span class="line">                    BOOL shouldBlockFailedURL;</span><br><span class="line">                    // Check whether we should block failed url</span><br><span class="line">                    if ([self.delegate respondsToSelector:@selector(imageManager:shouldBlockFailedURL:withError:)]) &#123;</span><br><span class="line">                        shouldBlockFailedURL = [self.delegate imageManager:self shouldBlockFailedURL:url withError:error];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotConnectToHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorNetworkConnectionLost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    if (shouldBlockFailedURL) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs addObject:url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs removeObject:url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line">                    </span><br><span class="line">                    // We&apos;ve done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.</span><br><span class="line">                    if (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</span><br><span class="line">                        downloadedImage = [self scaledImageForKey:key image:downloadedImage];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                    &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            @autoreleasepool &#123;</span><br><span class="line">                                UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line">                                </span><br><span class="line">                                if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                    BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                    NSData *cacheData;</span><br><span class="line">                                    // pass nil if the image was transformed, so we can recalculate the data from the image</span><br><span class="line">                                    if (self.cacheSerializer) &#123;</span><br><span class="line">                                        cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">                                    &#125; else &#123;</span><br><span class="line">                                        cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    [self.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                                &#125;</span><br><span class="line">                                </span><br><span class="line">                                [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            if (self.cacheSerializer) &#123;</span><br><span class="line">                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                                    @autoreleasepool &#123;</span><br><span class="line">                                        NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);</span><br><span class="line">                                        [self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    [self safelyRemoveOperationFromRunning:strongSubOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; else if (cachedImage) &#123;</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Image not in cache and download disallowed by delegate</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageOperation协议</span><br><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line">- (void)cancel;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">///SDWebImageCombinedOperation的实现</span><br><span class="line">@implementation SDWebImageCombinedOperation</span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.cancelled = YES;</span><br><span class="line">        if (self.cacheOperation) &#123;</span><br><span class="line">            [self.cacheOperation cancel];</span><br><span class="line">            self.cacheOperation = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        if (self.downloadToken) &#123;</span><br><span class="line">        ///根据downloadToke，对应的operation取消下载.[imageDownloader,是一个全局单例..sd里面单例模式用的很多]</span><br><span class="line">            [self.manager.imageDownloader cancel:self.downloadToken];</span><br><span class="line">        &#125;</span><br><span class="line">        [self.manager safelyRemoveOperationFromRunning:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///相关单列</span><br><span class="line">///SDWebImageManager 自身是一个单列的实现</span><br><span class="line">@implementation SDWebImageManager</span><br><span class="line">+ (nonnull instancetype)sharedManager &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">///其内部cache和downloader，分别是两个单例。</span><br><span class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</span><br><span class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    return [self initWithCache:cache downloader:downloader];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>下载流程<br>SDWebImageManager(单例) -&gt; SDWebImageCombinedOperation<sdwebimageoperation>-&gt; {SDImageCache(单例)-&gt;queryCache-&gt;if no -&gt;SDWebImageDownloader(单例)-&gt;downloadImage}</sdwebimageoperation></p>
</li>
<li><p>图片异步下载的实现（包括单个下载的请求组装，状态控制，回调处理，图片预解压等）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">///sd里面实现了一个SDWebImageDownloaderOperation的具体类。是命令模式的一种应用。</span><br><span class="line"></span><br><span class="line">///这里实现了二个协议，第一个协议实际上是包含了urlsession的两个系统协议。后面贴上。这里比较重要的是，如果你看SDWebImageDownloader的实现文件，你会发现，也实现了&lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;协议。</span><br><span class="line">////@interface SDWebImageDownloader () &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;，并在SDWebImageDownloader中统一把事情回调到SDWebImageDownloaderOperation类中。这样能使类的职责更清晰，图片解压后续等处理能封装到具体的SDWebImageDownloaderOperation类中，更合适而更内聚。</span><br><span class="line">例如</span><br><span class="line">===========</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123;</span><br><span class="line">    </span><br><span class="line">    // Identify the operation that runs this task and pass it the delegate method</span><br><span class="line">    NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = [self operationWithTask:task];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:task:didCompleteWithError:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session task:task didCompleteWithError:error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">===========</span><br><span class="line">@interface SDWebImageDownloaderOperation : NSOperation &lt;SDWebImageDownloaderOperationInterface, SDWebImageOperation&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The request used by the operation&apos;s task.</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) NSURLRequest *request;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The operation&apos;s task</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) NSURLSessionTask *dataTask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Was used to determine whether the URL connection should consult the credential storage for authenticating the connection.</span><br><span class="line"> *  @deprecated Not used for a couple of versions</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) BOOL shouldUseCredentialStorage __deprecated_msg(&quot;Property deprecated. Does nothing. Kept only for backwards compatibility&quot;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The credential used for authentication challenges in `-URLSession:task:didReceiveChallenge:completionHandler:`.</span><br><span class="line"> *</span><br><span class="line"> * This will be overridden by any shared credentials that exist for the username or password of the request URL, if present.</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong, nullable) NSURLCredential *credential;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The SDWebImageDownloaderOptions for the receiver.</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic, readonly) SDWebImageDownloaderOptions options;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The expected size of data.</span><br><span class="line"> */</span><br><span class="line">@property (assign, nonatomic) NSInteger expectedSize;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The response returned by the operation&apos;s task.</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, nullable) NSURLResponse *response;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Initializes a `SDWebImageDownloaderOperation` object</span><br><span class="line"> *</span><br><span class="line"> *  @see SDWebImageDownloaderOperation</span><br><span class="line"> *</span><br><span class="line"> *  @param request        the URL request</span><br><span class="line"> *  @param session        the URL session in which this operation will run</span><br><span class="line"> *  @param options        downloader options</span><br><span class="line"> *</span><br><span class="line"> *  @return the initialized instance</span><br><span class="line"> */</span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Adds handlers for progress and completion. Returns a tokent that can be passed to -cancel: to cancel this set of</span><br><span class="line"> *  callbacks.</span><br><span class="line"> *</span><br><span class="line"> *  @param progressBlock  the block executed when a new chunk of data arrives.</span><br><span class="line"> *                        @note the progress block is executed on a background queue</span><br><span class="line"> *  @param completedBlock the block executed when the download is done.</span><br><span class="line"> *                        @note the completed block is executed on the main queue for success. If errors are found, there is a chance the block will be executed on a background queue</span><br><span class="line"> *</span><br><span class="line"> *  @return the token to use to cancel this set of handlers</span><br><span class="line"> */</span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Cancels a set of callbacks. Once all callbacks are canceled, the operation is cancelled.</span><br><span class="line"> *</span><br><span class="line"> *  @param token the token representing a set of callbacks to cancel</span><br><span class="line"> *</span><br><span class="line"> *  @return YES if the operation was stopped because this was the last token to be canceled. NO otherwise.</span><br><span class="line"> */</span><br><span class="line"> ///取消操作</span><br><span class="line">- (BOOL)cancel:(nullable id)token;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageDownloaderOperationInterface继承了&lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;协议。</span><br><span class="line">@protocol SDWebImageDownloaderOperationInterface &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;</span><br><span class="line">@required</span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options;</span><br><span class="line"></span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">- (BOOL)shouldDecompressImages;</span><br><span class="line">- (void)setShouldDecompressImages:(BOOL)value;</span><br><span class="line"></span><br><span class="line">- (nullable NSURLCredential *)credential;</span><br><span class="line">- (void)setCredential:(nullable NSURLCredential *)value;</span><br><span class="line"></span><br><span class="line">- (BOOL)cancel:(nullable id)token;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">- (nullable NSURLSessionTask *)dataTask;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">图片解压部分，使用了面相协议的方式把多个类型的图片解压方法分散到各个具体类中。贴近于工厂模式，创建多个产品。并使用统一的一套接口，使调用者只面向抽象接口调用，不面向具体的类接口调用，利于具体类的切换。</span><br><span class="line">@protocol SDWebImageCoder &lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line">#pragma mark - Decoding</span><br><span class="line">- (BOOL)canDecodeFromData:(nullable NSData *)data;</span><br><span class="line">- (nullable UIImage *)decodedImageWithData:(nullable NSData *)data;</span><br><span class="line">- (nullable UIImage *)decompressedImageWithImage:(nullable UIImage *)image</span><br><span class="line">                                            data:(NSData * _Nullable * _Nonnull)data</span><br><span class="line">                                         options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict;</span><br><span class="line">#pragma mark - Encoding</span><br><span class="line">- (BOOL)canEncodeToFormat:(SDImageFormat)format;</span><br><span class="line">- (nullable NSData *)encodedDataWithImage:(nullable UIImage *)image format:(SDImageFormat)format;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">实现协议的具体类</span><br><span class="line">@interface SDWebImageGIFCoder : NSObject &lt;SDWebImageCoder&gt;</span><br><span class="line">@interface SDWebImageCodersManager : NSObject&lt;SDWebImageCoder&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>请求并发控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation class];</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</span><br><span class="line">        _downloadQueue = [NSOperationQueue new];</span><br><span class="line">        ///并发控制，利用了苹果封装的queue提供的功能</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">        _downloadQueue.name = @&quot;com.hackemist.SDWebImageDownloader&quot;;</span><br><span class="line">        _URLOperations = [NSMutableDictionary new];</span><br><span class="line">        SDHTTPHeadersMutableDictionary *headerDictionary = [SDHTTPHeadersMutableDictionary dictionary];</span><br><span class="line">        NSString *userAgent = nil;</span><br><span class="line">        ///组装userAgent头</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43</span><br><span class="line">        userAgent = [NSString stringWithFormat:@&quot;%@/%@ (%@; iOS %@; Scale/%0.2f)&quot;, [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@&quot;CFBundleShortVersionString&quot;] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];</span><br><span class="line">#elif SD_WATCH</span><br><span class="line">        // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43</span><br><span class="line">        userAgent = [NSString stringWithFormat:@&quot;%@/%@ (%@; watchOS %@; Scale/%0.2f)&quot;, [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@&quot;CFBundleShortVersionString&quot;] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[WKInterfaceDevice currentDevice] model], [[WKInterfaceDevice currentDevice] systemVersion], [[WKInterfaceDevice currentDevice] screenScale]];</span><br><span class="line">#elif SD_MAC</span><br><span class="line">        userAgent = [NSString stringWithFormat:@&quot;%@/%@ (Mac OS X %@)&quot;, [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@&quot;CFBundleShortVersionString&quot;] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[NSProcessInfo processInfo] operatingSystemVersionString]];</span><br><span class="line">#endif</span><br><span class="line">        if (userAgent) &#123;</span><br><span class="line">            if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) &#123;</span><br><span class="line">                NSMutableString *mutableUserAgent = [userAgent mutableCopy];</span><br><span class="line">                if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@&quot;Any-Latin; Latin-ASCII; [:^ASCII:] Remove&quot;, false)) &#123;</span><br><span class="line">                    userAgent = mutableUserAgent;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            headerDictionary[@&quot;User-Agent&quot;] = userAgent;</span><br><span class="line">        &#125;</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">        headerDictionary[@&quot;Accept&quot;] = @&quot;image/webp,image/*;q=0.8&quot;;</span><br><span class="line">#else</span><br><span class="line">        headerDictionary[@&quot;Accept&quot;] = @&quot;image/*;q=0.8&quot;;</span><br><span class="line">#endif</span><br><span class="line">        _HTTPHeaders = headerDictionary;</span><br><span class="line">        _operationsLock = dispatch_semaphore_create(1);</span><br><span class="line">        _headersLock = dispatch_semaphore_create(1);</span><br><span class="line">        _downloadTimeout = 15.0;</span><br><span class="line"></span><br><span class="line">        [self createNewSessionWithConfiguration:sessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片缓存机制的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line">        </span><br><span class="line">        // Create IO serial queue</span><br><span class="line">        ///串行队列,保证读写安全</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        </span><br><span class="line">        _config = [[SDImageCacheConfig alloc] init];</span><br><span class="line">        </span><br><span class="line">        // Init the memory cache</span><br><span class="line">        ///内存缓存管理</span><br><span class="line">        _memCache = [[SDMemoryCache alloc] initWithConfig:_config];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        // Init the disk cache</span><br><span class="line">        if (directory != nil) &#123;</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            self.fileManager = [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        #if SD_UIKIT</span><br><span class="line">        // Subscribe to app events</span><br><span class="line">        ////deleteOldFiles 与 backgroundDeleteOldFiles是内存和磁盘安全管理策略的执行方法</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(deleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationWillTerminateNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line"></span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(backgroundDeleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>磁盘管理的安全策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">- (void)deleteOldFiles &#123;</span><br><span class="line">    [self deleteOldFilesWithCompletionBlock:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line"></span><br><span class="line">        // Compute content date key to be used for tests</span><br><span class="line">        NSURLResourceKey cacheContentDateKey = NSURLContentModificationDateKey;</span><br><span class="line">        switch (self.config.diskCacheExpireType) &#123;</span><br><span class="line">            case SDImageCacheConfigExpireTypeAccessDate:</span><br><span class="line">                cacheContentDateKey = NSURLContentAccessDateKey;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case SDImageCacheConfigExpireTypeModificationDate:</span><br><span class="line">                cacheContentDateKey = NSURLContentModificationDateKey;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, cacheContentDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">        // This enumerator prefetches useful properties for our cache files.</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line"></span><br><span class="line">        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge];</span><br><span class="line">        NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary];</span><br><span class="line">        NSUInteger currentCacheSize = 0;</span><br><span class="line"></span><br><span class="line">        // Enumerate all of the files in the cache directory.  This loop has two purposes:</span><br><span class="line">        //</span><br><span class="line">        //  1. Removing files that are older than the expiration date.</span><br><span class="line">        //  2. Storing file attributes for the size-based cleanup pass.</span><br><span class="line">        NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSError *error;</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</span><br><span class="line"></span><br><span class="line">            // Skip directories and errors.</span><br><span class="line">            if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Remove files that are older than the expiration date;</span><br><span class="line">            NSDate *modifiedDate = resourceValues[cacheContentDateKey];</span><br><span class="line">            if ([[modifiedDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Store a reference to this file and account for its total size.</span><br><span class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">            cacheFiles[fileURL] = resourceValues;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">            [self.fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If our remaining disk cache exceeds a configured maximum size, perform a second</span><br><span class="line">        // size-based cleanup pass.  We delete the oldest files first.</span><br><span class="line">        if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123;</span><br><span class="line">            // Target half of our maximum cache size for this cleanup pass.</span><br><span class="line">            const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2;</span><br><span class="line"></span><br><span class="line">            // Sort the remaining cache files by their last modification time or last access time (oldest first).</span><br><span class="line">            NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</span><br><span class="line">                                                                     usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">                                                                         return [obj1[cacheContentDateKey] compare:obj2[cacheContentDateKey]];</span><br><span class="line">                                                                     &#125;];</span><br><span class="line"></span><br><span class="line">            // Delete files until we fall below our desired cache size.</span><br><span class="line">            for (NSURL *fileURL in sortedFiles) &#123;</span><br><span class="line">                if ([self.fileManager removeItemAtURL:fileURL error:nil]) &#123;</span><br><span class="line">                    NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line"></span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他线程安全的处理，锁的应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">#define UNLOCK(lock) dispatch_semaphore_signal(lock);</span><br><span class="line">///多线程中读写安全，通过锁保证，主要是数组和字典的读写操作安全；并包含其操作的整个代码段都要通过加锁保证其原子性。</span><br><span class="line">例子</span><br><span class="line">  LOCK(self.weakCacheLock);</span><br><span class="line">        // Do the real copy of the key and only let NSMapTable manage the key&apos;s lifetime</span><br><span class="line">        // Fixes issue #2507 https://github.com/SDWebImage/SDWebImage/issues/2507</span><br><span class="line">        [self.weakCache setObject:obj forKey:[[key mutableCopy] copy]];</span><br><span class="line">        UNLOCK(self.weakCacheLock);</span><br><span class="line">=====</span><br><span class="line">  LOCK(self.headersLock);</span><br><span class="line">    if (value) &#123;</span><br><span class="line">        self.HTTPHeaders[field] = value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.HTTPHeaders removeObjectForKey:field];</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(self.headersLock);</span><br><span class="line">    </span><br><span class="line">======</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    NSMutableArray&lt;id&gt; *callbacks = [[self.callbackBlocks valueForKey:key] mutableCopy];</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">///外观模式(通过face层去调用，内部调用更高级的子系统接口。)</span><br><span class="line">提供多个外部接口，内部通过调用一个更高级的子接口来现实。</span><br><span class="line">@interface UIImageView (WebCache)</span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url NS_REFINED_FOR_SWIFT;</span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder NS_REFINED_FOR_SWIFT;</span><br><span class="line">          </span><br><span class="line">=======</span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url &#123;</span><br><span class="line">///多级调用</span><br><span class="line">    [self sd_setImageWithURL:url placeholderImage:nil options:0 progress:nil completed:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder &#123;</span><br><span class="line">    [self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="四、使用的设计模式"><a href="#四、使用的设计模式" class="headerlink" title="四、使用的设计模式"></a>四、使用的设计模式</h5><p>单例模式、命令模式、工厂模式、外观模式</p>
<h5 id="五、利用语言特性的相关技巧"><a href="#五、利用语言特性的相关技巧" class="headerlink" title="五、利用语言特性的相关技巧"></a>五、利用语言特性的相关技巧</h5><ul>
<li>runtime关联对象</li>
<li>信号量作为锁的使用</li>
</ul>
<h5 id="六、SDWebImage官方类图"><a href="#六、SDWebImage官方类图" class="headerlink" title="六、SDWebImage官方类图"></a>六、SDWebImage官方类图</h5><p><img src="/personImg/SDWebImageClassDiagram.png" alt="SDWebImageClassDiagram.png"></p>
<h5 id="七、SDWebImage官方时序图"><a href="#七、SDWebImage官方时序图" class="headerlink" title="七、SDWebImage官方时序图"></a>七、SDWebImage官方时序图</h5><p><img src="/personImg/SDWebImageSequenceDiagram.png" alt="SDWebImageSequenceDiagram.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2019-01-01-2018总结泛篇.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019-01-01-2018总结泛篇.html" itemprop="url">2018年终总结泛篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-01T00:00:00+08:00">
                2019-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019-01-01-2018总结泛篇.html" class="leancloud_visitors" data-flag-title="2018年终总结泛篇">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,883
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="2018年的不足"><a href="#2018年的不足" class="headerlink" title="2018年的不足"></a>2018年的不足</h3><p>2018年对自己而言是比较失意的一年，但也未尝没有收获。尽力而为，果上随缘可以概况了这一年的总基调。虽然内心如此想，但尽力真的很难，个人的劣根性，懒惰、目光不够长远，低估自己等等不足，为这一年带来了很多挫折。</p>
<p>就各个不足回顾下：</p>
<ol>
<li><p>懒惰：也不知道是不是懒惰，就是如果让你来啃教科书，或者让你去看部电影,或者睡懒觉，那个舒服，其他人的选择尚不清楚，但我想有一部分人会选择舒服的方式去消磨掉时间，就这样舒服成为了懒惰的一大原因。另外一个是，即使深知如此，依然很难摆脱这个劣根性，很难，就算你有一定的目标，但这种长远的考虑，在短期内没有收获，意志就会被慢慢消磨。查阅网上资料，发现实坚持真的不容易，也有一些通过奖励的方式去辅助等等。总之，这方面，自己做的很差，一定程度上的原因有贪图安逸、目标不够坚定、缺乏长期规划、实际可行的执行方案等。</p>
</li>
<li><p>目光短浅：虽然我试图想象，我把这些要做的事情全部做完，会变成怎么样，是否与自己的初衷相符，或者是否达到自己目标的预期，等等。但未来是很不明显的，当所掌握的信息极其的有限，很有可能会在这极其有限的信息中做出不那么正确的判断，在基于这样的判断下预期很难想象。这样就导致，中途可能会变换目标，或者使本来执行的事情搁置或放弃。另外目标短浅，就当前比较突出的是缺乏短期计划、中期计划、长期计划。</p>
</li>
<li><p>低估自己：如果没有上面两大缺点，或者上面两大缺点没有那么大，可能就不会过分的低估自己。这里面实际是存在些矛盾。客观来说，一些看似遥不可及的东西，也许通过一些努力，慢慢靠近也并非所想的难以靠近，通常来说这些东西本来就是需要努力去获取的，而差距和鸿沟需要努力去一步一步填补的。一个一直努力的人，和一个吊儿郎当的人差距是很大的，即使两个人的资质相差不大。当你有想法的时候，却发现能力不够，是悔恨浪费的时光，还是坦然面对过去，努力迎接未来?就算此刻努力，却有更多的患得患失，因为最好的时机已经错过，你没有在最该走这条路的时候走好，是挣扎还是要放弃呢？如果一些你本来能做到的事情，到最后却没法做到，一定会很悔恨与不甘吧。过去低估自己，现在是否还要低估自己？2018年对自我的认识依然不够，性格上依然有很大的问题，导致一些判断和考虑错误。其实这里并不是低估自己，而是人的潜力是很大的，忽略这一点，就如低估自己一样。</p>
</li>
</ol>
<h3 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h3><p>失败后的失落会让你面对现实，也许是这样的经历比较锻炼心智，让人变得成熟，大概是类似吃一堑长一智。经历过才印象深刻，才把这回事当成一回事。所以从这一点看，老人家说的很多是良言善语，只是我们的经历不够，难以深刻体会，依然要继续走弯路，直到吃了苦，才真正的明白个中的意思。这个也许是个生物特征的东西，很难改变，调整思维或者更早去经历，都是对的。但我更多的是那种把回事不当回事的人，所以啊，吃了不少暗亏。而这个收获就是经历后、体会过之后，思想的改变。在这个阶段，总之对比以前的自己，我更喜欢现在的自己。因此我对自己说过，经历过生活的洗礼后，要变得越来越喜欢自己。这个也是作为检测自己的一个标准。</p>
<h3 id="2019目标："><a href="#2019目标：" class="headerlink" title="2019目标："></a>2019目标：</h3><ol>
<li>定好学习目标与计划，持续提高。</li>
<li>改善懒惰。</li>
<li>目光放长远点，职业/生活/理财等。</li>
<li>对自己的认识，依然要不断改善，要努力积极向上。</li>
</ol>
<h5 id="比较重要的几点记录下来："><a href="#比较重要的几点记录下来：" class="headerlink" title="比较重要的几点记录下来："></a>比较重要的几点记录下来：</h5><ol>
<li><p>对于比较重要的事情，一定要考虑周全，查询一切可以查询的资料，把一件事情当做打仗来看，分清双方形势，考虑冒进/稳妥/更稳妥的三套以上的方案，同时要分清楚自己的情况与事件的关系。来自外界的意见要以主观为主加以分析，思前想后，分清主次，稳妥为主，否则可能会出现捡了芝麻丢了西瓜，甚至竹篮打水一场空的尴尬境地。</p>
</li>
<li><p>一直以来，都有不少与人争论的场合，通常对于一个问题，不同的人可能会有不同的意见，达成共识有时候并不是一件容易的事情。2019非原则问题，尽量避免争论。当然要继续保持包容和开放的心去接纳不同的意见。尊重事实，而不是奉承。这里其实有一个值得深思的问题，导致辩论的一大原因可能不是因为坚持自己的意见，甚至不是因为还是觉得自己的意见正确。而是来自人性的一部分，也许跟性格也是相关的。如果被别人纠正，意味着自己的不对，意味者局部性的不如人，也许是个性中的好强，这样内心就会难受，所以会出于这种理由要继续辩解并固执己见。这不过是一个个人的看法，实际上如何，原因应该很多样化，但如果自己本身去探究下为何会这样，大概多少能理解别人为何如此了。至少我要做到以事实为准，以更合理的为准，包容与接纳，减少争论。</p>
</li>
<li><p>君子之交淡如水，给与各自恰当的距离与空间，让大家都保持一种舒适的状态，这个是要往后学习与实践的。</p>
</li>
<li><p>情商需要提高，结合场景多思考合适的回答，形成思维回路，加强矛盾场景的锻炼。</p>
</li>
<li><p>提高专注度，做自己的事情，外界信息，要为自己所用，而不是要被外界影响。</p>
</li>
<li><p>今日事今日毕。改善拖延症，要做的事就是一个队列，如果拖，有些事就变得不了了之了，所有要改善拖延症。</p>
</li>
<li><p>踏实向上，加强时间管理，缄默慎言。</p>
</li>
</ol>
<h4 id="修心养性方面："><a href="#修心养性方面：" class="headerlink" title="修心养性方面："></a>修心养性方面：</h4><ol>
<li>可以的话2019要去多出去看看风景，留下多点关于旅途的回忆。</li>
<li>要学会照顾自己，品味生活。</li>
</ol>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>以上感觉总结的很泛，但也是一些心里话，记录下来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018_08_05_iosSaftThread.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018_08_05_iosSaftThread.html" itemprop="url">iOS 多线程安全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-05T00:00:00+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018_08_05_iosSaftThread.html" class="leancloud_visitors" data-flag-title="iOS 多线程安全">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,091
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程安全的概念"><a href="#线程安全的概念" class="headerlink" title="线程安全的概念"></a>线程安全的概念</h3><p>如果在多线程的场景下，运行一段程序，不会出现预料之外的结果。可以认为这段程序是线程安全的。</p>
<h3 id="导致线程不安全的原因"><a href="#导致线程不安全的原因" class="headerlink" title="导致线程不安全的原因"></a>导致线程不安全的原因</h3><p>当多线程访问同一个代码段的时候，共享变量的信息可以被各个访问它的线程所修改，以致于某个线程执行完代码块后出现期望之外的结果，甚至使线程崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__block int i = 0;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">        for (int j= 0 ; j &lt; 1000; j++) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot; a thread: %d&quot;,i);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        for (int j= 0 ; j &lt; 1000; j++) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;b thread: %d&quot;,i);</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>其中一种结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-08-05 15:30:10.299750+0800 safeThreadTest[16566:2770764]  a thread: 1055</span><br><span class="line">2018-08-05 15:30:10.299750+0800 safeThreadTest[16566:2770766] b thread: 1965</span><br></pre></td></tr></table></figure></p>
<p>与期待的1000 和2000 不一致。</p>
<h3 id="避免线程不安全"><a href="#避免线程不安全" class="headerlink" title="避免线程不安全"></a>避免线程不安全</h3><p>避免线程不安全的关键是在原子操作，对需要原子操作的代码片段，通过加锁保证其线程安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__block int i = 0;</span><br><span class="line">NSLock *lock = [NSLock new];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    [lock lock];</span><br><span class="line">    for (int j= 0 ; j &lt; 1000; j++) &#123;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot; a thread: %d&quot;,i);</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    [lock lock];</span><br><span class="line">    for (int j= 0 ; j &lt; 1000; j++) &#123;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;b thread: %d&quot;,i);</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>稳定的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-08-05 15:34:46.495629+0800 safeThreadTest[16758:2774646]  a thread: 1000</span><br><span class="line">2018-08-05 15:34:46.495806+0800 safeThreadTest[16758:2774644] b thread: 2000</span><br></pre></td></tr></table></figure></p>
<h3 id="iOS中的atomic与nonatomic"><a href="#iOS中的atomic与nonatomic" class="headerlink" title="iOS中的atomic与nonatomic"></a>iOS中的atomic与nonatomic</h3><p>使用atomic定义的属性，系统为其默认生成的setter和getter方法是加锁的，setter操作与getter操作是互斥的原子操作。而使用nonatomic定义的属性，系统为其默认生产的setter和getter是不加锁的，两者的操作不互斥，同时也不具备原子性。</p>
<p>由于nonatomic是不加锁的，所以性能是比atomic高。而我们在开发过程中一般也是使用该属性。因为atomic只能保证属性的读写原子操作，并不能保证线程安全，在多线程编程中依然要根据代码的具体功能划分原子操作的范围，通过加锁来保证线程安全。除非原子操作范围就是这个属性的读与写，否则是没有必要定义成atomic，因为线程安全已经通过外层加锁处理。</p>
<p>系统是通过地址总线寻址，数据总线存取数据的。而且数据总线只有一个，其访问内存是串行操作。假定数据总线宽度为64位，数据长度超过64位，那么数据总线就必须多次访问内存。如果数据长度少于数据总线宽度，读写总是串行的，也即是其操作是原子的。int、bool、float、double等操作总是原子操作，同时在定义时无需指定atomic，避免系统增加不必要的加锁操作。而不定长度的数据类型，就有必要根据实际情况定义atomic或nonatomic。</p>
<h3 id="iOS中锁的使用"><a href="#iOS中锁的使用" class="headerlink" title="iOS中锁的使用"></a>iOS中锁的使用</h3><table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">性能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">OSSPinLock</td>
<td style="text-align:left">自旋锁</td>
<td style="text-align:left">高</td>
</tr>
<tr>
<td style="text-align:left">dispatch_semaphore_t</td>
<td style="text-align:left">信号量</td>
<td style="text-align:left">高</td>
</tr>
<tr>
<td style="text-align:left">pthread_mutex</td>
<td style="text-align:left">linux提供的互斥锁</td>
<td style="text-align:left">高</td>
</tr>
<tr>
<td style="text-align:left">NSLock</td>
<td style="text-align:left">OC提供的互斥锁</td>
<td style="text-align:left">一般</td>
</tr>
<tr>
<td style="text-align:left">pthread_mutex(recursive)</td>
<td style="text-align:left">linux提供的互斥锁</td>
<td style="text-align:left">一般</td>
</tr>
<tr>
<td style="text-align:left">NSCondition</td>
<td style="text-align:left">作为锁和线程检查器，有wait/signal方法</td>
<td style="text-align:left">一般</td>
</tr>
<tr>
<td style="text-align:left">NSRecursiveLock</td>
<td style="text-align:left">递归锁</td>
<td style="text-align:left">一般</td>
</tr>
<tr>
<td style="text-align:left">NSConditionLock</td>
<td style="text-align:left">条件锁，内部包含一个NSCondition对象</td>
<td style="text-align:left">低</td>
</tr>
<tr>
<td style="text-align:left">@synchronized</td>
<td style="text-align:left">互斥锁</td>
<td style="text-align:left">低</td>
</tr>
</tbody>
</table>
<p>加锁性能不能代表具体程序运行锁的性能。加锁快可能跟锁的实现简单，费时少有关。但使用中锁的性能跟线程等待采用的方式是休眠还是忙等有关。自旋锁由于优先级反转的问题已经不能使用，iOS10有替代版本。常规开发使用简单的NSLock、@synchronized等已经能满足大部分需求，性能要求高再考虑使用信号量等。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上线程安全、锁做简单的总结和理解。如果在开发中，还是要尽量避免多线程设计，搞不好出现死锁，也不好调试。程序的稳定安全比程序的性能更重要。要在确保程序的稳定和线程安全的情况下，再去提高程序的性能。</p>
<p>参考：<br><br><a href="http://mrpeak.cn/blog/ios-thread-safety/" target="_blank" rel="noopener">iOS多线程到底不安全在哪里？</a><br><br><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018_08_04_processAndThread.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018_08_04_processAndThread.html" itemprop="url">进程与线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-04T00:00:00+08:00">
                2018-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机基础/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018_08_04_processAndThread.html" class="leancloud_visitors" data-flag-title="进程与线程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,933
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ol>
<li>定义：是一个程序及其数据在处理机上执行时所发生的活动。</li>
<li>程序与进程的区别：程序是一组有序指令的集合，是静态的。而进程是动态的，由创建而产生，由调度而执行，由撤销而消亡。进程具有并发性，可并发执行。进程具备独立性，是接受资源和接受调度的基本单位（是资源分配的最小单位，而调度的最小单位是线程）。进程具有异步性，即按各自独立和不可预知的速度向前推进。<h5 id="进程的三种基本状态："><a href="#进程的三种基本状态：" class="headerlink" title="进程的三种基本状态："></a>进程的三种基本状态：</h5></li>
<li>就绪：已获取除cpu执行权以外的所有资源，只要获得cpu执行权，便可立即执行。就绪线程通常放到一个就绪队列中。</li>
<li>执行：获取cpu执行权，处于执行状态中。</li>
<li>阻塞：当进程执行被打断时，处理器会发起调度，把执行权给予其他就绪进程，而当前进程进入阻塞状态。阻塞状态的进程，会被放进系统的阻塞队列中，等待被唤醒。导致阻塞的几种情况。<ol>
<li>向系统请求共享资源失败。</li>
<li>等待某种操作完成。发起IO-》阻塞-》需等IO任务执行完成-》中断处理程序唤醒-》就绪</li>
<li>等待新任务到达。</li>
</ol>
</li>
</ol>
<p>进程的挂起与唤醒：当系统资源不足的时候，会去挂起就绪或堵塞进程，把它们放入外存以释放内存资源。同时执行挂起原语suspend能主动挂起进程。就绪进程挂起变为静态就绪状态，阻塞进程挂起变为静态阻塞状态，执行中的进程被挂起进入静态就绪状态。当静态就绪状态被激活，加载到内存中，就恢复到活动就绪状态。静态阻塞被激活醒就变为活动阻塞。</p>
<p>状态转换如下图：</p>
<p><img src="/personImg/进程状态转换.png" alt="进程状态转换.png"></p>
<p>阻塞与唤醒过程：</p>
<p><img src="/personImg/进程阻塞唤醒过程.png" alt="进程阻塞唤醒过程.png"></p>
<p>挂起与激活过程：</p>
<p><img src="/personImg/进程挂起激活过程.png" alt="进程挂起激活过程.png"></p>
<h4 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h4><h5 id="pcb的作用"><a href="#pcb的作用" class="headerlink" title="pcb的作用"></a>pcb的作用</h5><ol>
<li>作为进程实体的一部分，记录了操作系统所需的，用于描述进程当前情况及管理进程运行的全部信息，是操作系统中最中最重要的记录型数据结构。</li>
<li>能实现间断性运行方式，能保存运行的上下文，用于下次执行。</li>
<li>提供进程管理所需的信息。记录了程序和数据在内存或外存中的地址指针。</li>
<li>提供进程调度所需的信息，进程优先级、所处状态等。</li>
<li>实现与其他进程同步与通信。如果使用信号量，进程中必须都设置相应的用于同步的信号量。关于通信，pcb中有用于实现进程通信的区域或通信队列指针等。</li>
</ol>
<h5 id="pcb中的信息"><a href="#pcb中的信息" class="headerlink" title="pcb中的信息"></a>pcb中的信息</h5><ol>
<li>进程唯一标识符，外部标识符（用户调用）和内部标识符（系统调用）。</li>
<li>处理机状态，也称处理机上下文。主要由处理机的各种寄存器中的内容组成的。寄存器类型包括：1.通用寄存器，用于暂存信息。2.指令计数器，存放下一条指令的地址。3.程序状态字PSW，包含状态信息（条件码、执行方式、中断屏蔽标志）。4.用户栈指针，指向的栈中，存放调用参数和调用地址。</li>
</ol>
<p>当进程被切换时，处理机信息都必须保存在pcb中，当再次运行的时候，能从原状态恢复。同时，如果进程频繁切换，带来的时空开销是很大的。</p>
<h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>临界资源：一次只允许一个进程使用的资源。例如一些硬件资源，打印机、磁带机等。进程间应采用互斥方式，实现对这种资源的共享。</p>
<p>临界区：访问公共资源的代码片段。</p>
<p>原则：</p>
<ol>
<li>空闲让进：无程序处于临界区时，代表临界资源空闲，允许请求进入的进程访问。</li>
<li>忙则等待：如果临界资源被访问中，请求访问必须等待，实现互斥。</li>
<li>有限等待：保证在有限时间内能进入自己的临界区，避免死等。</li>
<li>让权等待：当进程无法进入临界区时，释放处理机，避免陷入忙等。此原则应该是在有限等待无法实现的情况下执行。</li>
</ol>
<p>信号量机制</p>
<p>wait(s),signal(s)基本操作，属于原子操作，执行过程不可中断。当s = 1的时候可以实现互斥同步功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;</span><br><span class="line">    ...</span><br><span class="line">    wait(mutex);    </span><br><span class="line">    //临界区</span><br><span class="line">    signal(mutex);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>通过wait，signal能保证临界区同时只能允许一个进程进入。当临界区繁忙时，其他行程访问临界区，执行wait操作会失败，同时进程会进入阻塞。</p>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ol>
<li>管道系统pipe,接收发送通过共享文件（pipe文件）的方式进行通信。</li>
<li>消息传递系统，send(receiver,message),receive(sender,message)</li>
<li>客户机-服务器系统，通过socket套接字</li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁：如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p>
<p>进程饥饿：进程一直获取不到资源。</p>
<p>可抢占资源：能被其他线程抢占的资源。该类资源的抢占不会导致死锁的产生。如处理机、内存空间等。</p>
<p>不可抢占资源：一旦被分配了，不能强行回收，只能等线程释放。如打印机、刻录机等。</p>
<p>死锁产生的几种情况：</p>
<ol>
<li>竞争不可抢占资源，导致互相等待对方释放资源。双方都必须拥有对方要访问的资源。不能通过调整代码顺序解决。</li>
<li>竞争可消耗资源（中断信号、系统通知等）。循环等待消息的接受，才执行消息的发送，导致死锁。能通过调整代码的执行顺序解决。大家都想获取到消息资源，而等待的消息资源，只有其他人能发出。由于循环等待，导致消息无法发出。属于可消耗资源的竞争。</li>
<li>程序的推进顺序非法。该情况不属于资源使用，但导致死锁也就是出现互相等待的局面或则循环等待的局面。</li>
</ol>
<p>死锁产生的条件：</p>
<ol>
<li>互斥条件：分配的资源，同一时间只能被一个进程访问，直到其释放。</li>
<li>请求和保存条件：请求新的资源，同时保存自己已拥有的某个资源不释放,这个不释放的资源就是别人要获取的资源。</li>
<li>不可抢占条件：访问的资源不可被抢占。这样就无法通过抢占的方式解决阻塞。</li>
<li>循环等待条件：这是出现死锁的一个结果，由于前面的几个条件的同时存在才有可能出现这个循环等待的结果，如果这个结果出现，那么意味着出现死锁。</li>
</ol>
<p>死锁的处理方法：</p>
<ol>
<li>预防死锁：通过某些限制条件破坏死锁的四个条件，防止死锁的产生。属于事先预防。</li>
<li>避免死锁：在系统资源动态分配的过程中，通过某种方式，防止进程进入不安全区域，避免死锁的发生。输入事先预防。</li>
<li>检测与解除死锁：使用某些方式检测死锁的产生并解除死锁。可通过撤销进程，终止进程等方式，释放资源。</li>
</ol>
<hr>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>20世纪60年代OS系统引入进程解决程序并发问题，80年代提出比进程更小的单位线程。90年代出现多核处理机，线程能更好的发挥处理机的性能。线程是为了提高并发性以及进行相互之间合作而创建的。而现在进程更多的是作为线程的容器，程序的并发执行通过线程来实现。</p>
<p>进程与线程的比较：<br>1.调度角度： 进程过重，是独立运行的基本单位，进程每次调度都需要切换上下文，时空开销大。而线程切换仅仅需要保持和设置少量的寄存器内容，切换代价远低于进程。</p>
<ol start="2">
<li>资源角度：作为资源调度的基本单位，进程拥有独立资源。而线程本身不拥有系统资源，其仅有一点必不可少的能保证独立运行的资源（TCB、程序计数器、保留局部变量、状态参数、返回地址等一组寄存器和堆栈）。</li>
<li>独立性角度：进程间相对独立，出了通过少量的全局变量实现共享。线程资源允许别的线程共享，同一进程的所有线程共享同一个内存地址空间和进程资源。</li>
<li>稳定性：进程之间除了共享全局变量外，不允许其他进程访问。而线程因为共享同一个进程的内存地址空间和资源，甚至其线程堆栈都能被其他线程读取和清楚。多进程比多线程稳定，但协同能力多线程更强。</li>
</ol>
<h4 id="线程控制块TCB"><a href="#线程控制块TCB" class="headerlink" title="线程控制块TCB"></a>线程控制块TCB</h4><p>包含信息：</p>
<ol>
<li>线程标识符</li>
<li>线程运行状态（就绪、阻塞、执行）</li>
<li>优先级</li>
<li>堆栈指针（调用过程的局部变量和返回地址）</li>
<li>线程专有存储区，用于保存切换时的线程上下文和一些统计信息。</li>
<li>信号屏蔽，对某些信号加以屏蔽。</li>
<li>一组寄存器，程序计数器寄存器PC、通用寄存器。<ol>
<li>程序计数器寄存器，用于存储下一条程序指令地址。</li>
<li>通用寄存器，用于存送和暂存数据，也可参与算术逻辑运算并保存结果。</li>
</ol>
</li>
<li>两个指向堆栈的指针，执行自己堆栈的指针和指向核心栈的指针。前者是当线程运行在用户态时使用自己的堆栈来保存局部变量和函数返回地址，后者是线程运行在核心态的时候使用系统核心栈。</li>
</ol>
<h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><h5 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h5><p>创建、阻塞、撤销和切换都在内核空间实现。</p>
<p>优点：</p>
<ol>
<li>对多处理器系统来说，内核能调度同一进程中的多个线程实现真正意义的并发执行。</li>
<li>当进程中的一个线程阻塞了，能调度进程中的其他线程执行，甚至能调度其他进程中的线程执行，前提是这个线程必须是核心态。</li>
<li>内核线程具有很小的数据结构和堆栈，切换开销小。</li>
</ol>
<p>缺点：<br>用户如果要切换进程中的线程，需要把线程从用户态切换到核心态，因为线程调度由内核控制，系统开销较大。</p>
<h5 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h5><p>在用户空间中实现。用户级线程的一切操作对内核都是透明的。但是这种线程就不能实现真正意义的并发，系统调度以进程为单位。如果A进程实现了1个用户级线程，而B进程实现了100个用户级线程，那么A中线程获得的执行时间是B中线程的100倍。而内核支持线程，以线程为调度单位。</p>
<h5 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h5><ol>
<li>一对多。用户线程映射到一个核心线程。如果核心线程阻塞了，就无法正常工作。</li>
<li>一对一。核心线程的数据与用户线程的数量一样，一一映射。发送阻塞能调度其他线程，但每个用户线程就对应一个核心线程，导致系统开销大，需要全局限制线程的数量。</li>
<li>多对多。存在多个核心线程用于映射用户线程，避免了系统开销过大，也避免了阻塞导致不能正常工作的问题。集合了1和2的优点。</li>
</ol>
<h5 id="内核支持线程的实现"><a href="#内核支持线程的实现" class="headerlink" title="内核支持线程的实现"></a>内核支持线程的实现</h5><p>创建进程的时候，分配一个PTDA(per task data area),其中包含若干线程控制块TCB空间。当一个新内核线程被创建时，系统会分配TCB和相关资源。线程销毁时资源被回收，但也可以先不回收，等候新的线程被创建时服用其TCB。</p>
<h5 id="用户级线程的实现"><a href="#用户级线程的实现" class="headerlink" title="用户级线程的实现"></a>用户级线程的实现</h5><p>在用户空间实现的，线程运行在运行时系统上（runtime system）。线程切换时不需要切换到核心态，切换速度快。申请资源需要通过runtime system间接申请。</p>
<p>内核控制线程：又称lwp（light weight process）。lwp可通过系统调用来获得内核提供的服务，当用户级线程连接到lwp上，就能具有内核支持线程的所有属性（调度方式，按线程调度）。lwp是用户线程与内核线程沟通得桥梁，同时起到用户线程与内核线程的隔离作用。用户线程可能很多，为了节省系统开销，不能设置过多的lwp，通过多路复用的方式实现lwp线程池，如果没有可用lwp那么用户线程进入等待。lwp阻塞可用去连接别的lwp，就算lwp全部阻塞也不妨碍线程执行任务，但不能访问内核了。</p>
<h5 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h5><p>当优先级高的线程访问临界资源，而这个临界资源被优先级低的线程占用。此时就会发生优先级倒置。如果此时存在三个优先级a,b,c,c 为低优先级且占用临界资源，a为高优先级需要访问临界资源，b为中优先级不需要访问临界资源。当a去访问资源的时候，发现无法访问，因为被c占用了，同时又存在b线程，b优先级比c高，系统调度去执行b，b执行完毕后，才有可能执行c，c释放临界资源后a才有可能执行。但如果存在多个如b2,b3,b4，那么a线程执行的时刻就会被大大延长。且a的执行被延长的时间不可预知和无法限定。</p>
<p>解决方案1：如果线程正在访问临界资源，设定为不可被抢占，这样其就能更快的退出临界区。但如果这样，当线程访问临界区时，调度对他是失效的。就算有很多优先级比他高的不需要访问临界资源的线程都没机会执行。如果其临界区很长，那么必然是不能接受和不合理的。</p>
<p>解决方案2：当高优先级线程因为访问临界资源被阻塞时，拥有临界资源的低优先级的线程继承高优先级线程的优先级，直到其退出临界区。这样既能不影响系统的正常调度，比他们更高的优先级的线程依然能执行，同时能避免介于他们中间的优先级的线程插入执行。</p>
<p>相比两个方案，方案二更优。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018_07_29_Memory.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018_07_29_Memory.html" itemprop="url">谈谈计算机内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-29T00:00:00+08:00">
                2018-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机基础/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018_07_29_Memory.html" class="leancloud_visitors" data-flag-title="谈谈计算机内存">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,316
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="内存的访问"><a href="#内存的访问" class="headerlink" title="内存的访问"></a>内存的访问</h4><ol>
<li>通过地址总线将地址送到内存，然后数据总线会把数据送到微处理器供给cpu使用。</li>
<li>32位总线可寻找范围为[0,2^32 - 1]相当于[0,4294967296]，即4GB。</li>
</ol>
<h4 id="物理地址到虚拟地址"><a href="#物理地址到虚拟地址" class="headerlink" title="物理地址到虚拟地址"></a>物理地址到虚拟地址</h4><p>早期计算机是使用物理地址的，但是使用物理地址会存在以下几个问题：</p>
<ol>
<li><p>地址空间不隔离</p>
<p> 所有的程序都是使用物理地址访问，程序所使用的内存空间是不隔离的。程序可以被其他程序访问，对恶意访问或修改没有防护措施。程序的稳定性难以保证。</p>
</li>
<li><p>内存使用效率低</p>
<p> 直接使用物理地址，必须是连续的。如果剩余的物理内存无法满足程序的空间分配，那么就需要把当前运行的某些程序写入磁盘，释放内存空间以供给需要运行的程序。当写入磁盘的程序被唤醒，系统会以同样的策略给该程序分配内存，内存条件满足后把程序读入内存。这里面存在很多的磁盘读写操作，导致内存使用效率低。原因1，使用物理地址，必须是连续的，不能充分的利用内存碎片，颗粒很大。原因2，磁盘读写的操作比较耗时，内存分配必须等待该操作的完成，这样相当于把内存使用的效率变低了。</p>
</li>
<li><p>程序运行地址不确定</p>
<p> 系统给程序分配的空间不固定与程序编写时固定地址的数据访问和指令跳转产生冲突。这个冲突增加了编程难度。</p>
</li>
</ol>
<h4 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h4><p>为了解决使用物理地址存的问题，加入中间层，通过使用虚拟地址的方式访问程序。然后通过地址映射转换成成物理地址。由于每个程序只能访问自己的虚拟地址，只要妥善的控制这个映射关系，确保程序间的地址不重叠，就能实现程序间的内存地址相互隔离。</p>
<p>三、内存的存储管理方式</p>
<ol>
<li><p>分段存储管理方式</p>
<ul>
<li><p>地址的整块映射。物理地址分配也是连续的。</p>
</li>
<li><p>解决了地址空间不隔离、程序运行地址不确定的问题。但由于是连续地址，分配空间不足的情况下，需要对某些程序进行磁盘写入以释放空间，导致内存使用效率低的问题。</p>
</li>
</ul>
</li>
<li><p>分页存储管理方式</p>
<ul>
<li><p>解决了内存使用效率低的问题。对于每个程序来说，在某个时间段内，只会频繁的用到某部分数据。那么可以把那些不常用的数据存储于磁盘中并释放内存空间。通过分页的存储方式实现更细粒度的控制。内存的分页需要硬件支持，同时在硬件支持的基础上通过系统选择使用的方式。例如硬件支持4k和8k每页，系统选择4k。但是在运行过程中是不能切换分页方式的，也即是说，任意时刻分页方式都是确定的。目前几乎所有pc系统都使用4k大小的页。</p>
</li>
<li><p>内存共享：通过两个程序中的某些地址指向同一个物理页的方式实现。</p>
</li>
<li><p>写入磁盘的数据唤醒：当程序通过虚拟地址对写入磁盘的数据发起调用的时候，内存中并不存在并会发出页错误（pageFault），然后系统接管线程并把磁盘中的页数据读入内存，并恢复正常访问。</p>
</li>
<li><p>页的部分映射表会存储在一个叫TLB(Translation Look Aside Buffer)的寄存器，以提高内存的使用效率。因为把所有的映射表存储在内存中，cpu读取的时候需要两次访问内存。第一次访问页表，第二次才访问目标内存。这样会使访问效率变低。如果通过TLB保存常用的映射表，读取寄存器获取物理地址，能大大提高内存使用效率。TLB的容量有效，如果表满了会淘汰最老的不使用的页映射条目，这里应该有某类的淘汰算法来实现。</p>
</li>
<li><p>一般来说，只有当内存不足的时候才会把数据读入磁盘，也即是虚拟内存。</p>
</li>
</ul>
</li>
<li><p>段页存储管理方式</p>
<ul>
<li><p>分页和分段两种方式的结合，同时具备两者的优点。是应用最广泛的存储管理方式。</p>
</li>
<li><p>物理地址与虚拟地址直接的转换时通过硬件实现的。但几乎都是通过MMU（Memory Management Unit）这样的硬件实现的。MMU一般集成于cpu内部。</p>
</li>
</ul>
</li>
</ol>
<h4 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h4><ol>
<li>内核空间。<ul>
<li>内存的部分空间分配给内核使用，这部分空间程序是无法访问的。例如，内存总量为4G，分配1~2G作内核使用。</li>
</ul>
</li>
<li><p>栈</p>
<ul>
<li>栈的作用：用于维护函数调用的上下文，离开栈函数的调用就无法执行。</li>
<li><p>栈的地址增长方向：跟cpu和os的实现方式有关，Linux是向下增长的，但在程序中显示的都是虚拟地址，不能用于判断其增长方向。</p>
<p>内存分布图：</p>
<p><img src="/personImg/linux程序内存分布.png" alt="内存分布.png"></p>
<p>栈保存了函数调用所需要维护的信息：</p>
</li>
</ul>
<ol>
<li>函数返回地址和参数</li>
<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。</li>
<li>保存上下文：包括函数调用前后要保持不变的寄存器。</li>
<li>i386中使用ebp和esp两个寄存器来为函数活动记录划分范围。esp始终指向栈的顶部，也即当前函数活动记录的顶部。而ebp则会指向函数的栈帧底部。<br>当一个新的函数调用时压栈过程大概如下：<ul>
<li>它的参数会先压栈(push params)</li>
<li>然后对其函数执行函数调用（call func），并把返回值地址填入栈。</li>
<li>保存之前的函数ebp，push ebp。</li>
<li>设置当前函数的栈帧底部mov esp, ebp。当前位置的栈顶esp就是当前函数的栈帧底部ebp。<br>-然后执行新的栈帧，当栈帧执行完之后会用ret 返回参数。此时通过读取ebp的值，ebp就能返回到之前函数的栈帧底部，同时esp划过函数参数恢复到之前函数的栈顶。</li>
</ul>
</li>
<li><p>另外还有一个eip寄存器，记录cpu下一次执行指令的地址。</p>
<p><img src="/personImg/stackframe-cdecl.png" alt="stackframe-cdecl.png"></p>
</li>
</ol>
</li>
<li><p>堆</p>
<ol>
<li>堆的作用：用来容纳应用程序动态分配内存。</li>
<li>堆内存的分配可以通过程序控制（malloc()），当内存不足的时候会交由系统分配（brk（）、mmap()）。</li>
<li><p>堆分配算法：</p>
<ul>
<li><p>空闲链表</p>
<p>  每个节点为包含起始地址和空闲大小。查找空闲空间的时候，通过遍历空闲链表查找合适空间。返回地址和大小，用于内存分配和释放。<br>  存在缺点：链表被破坏，或者返回数据被破坏，那么会导致程序错误、甚至整个堆无法工作。因为空闲链表只记录空闲的数据，而不是全堆信息。如果大小字段错误，确实会导致整个堆无法工作，因为这种情况是无法判断出来的，无法估量整个堆的内存使用情况。</p>
</li>
<li><p>位图</p>
<p>  把空闲内存划分为多个块，使用2个字节存储。假设每个块大小为x。堆空间大小为Y,那么数组的元素个数为y/x。每个块的地址也能通过公式计算出。那么我们返回数据的时候，会把第一个元素标记为头块（返回头快和后面跟随的块个数），后面的元素标记为主体块。那么块是有3种状态，空闲/头/主体，用用2bit表示。</p>
<p>  优点：1. 只要分配块的大小适中，那么cache命中率会很高，速度快。2. 稳定性好，避免用户越界读写破败位图，作简单备份。即使部分数据受到破坏，也不会导致整个堆无法工作。因为位图是记录了整个堆的内存使用情况，就算部分数据受到破坏，使用保守策略不使用破坏的部分，而不会导致整个堆不可用。</p>
<p>  缺点：1. 容易产生碎片。2. 块的大小太小，会导致cache命中率变低。可使用多级位图解决。</p>
</li>
<li><p>对象池</p>
<p>  某些场合被分配的对象大小为固定的几个值。那么就按照这个大小分配块。可用位图或空闲链表实现。</p>
</li>
</ul>
<p>而实际中，堆分配算法往往是采用多种算法复合而成的。</p>
</li>
</ol>
</li>
</ol>
<hr>
<p>ps：部分图片来源于网络，如有侵权，请联系马上删除。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018_07_24_ios.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018_07_24_ios.html" itemprop="url">iOS 深复制与浅复制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-24T00:00:00+08:00">
                2018-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018_07_24_ios.html" class="leancloud_visitors" data-flag-title="iOS 深复制与浅复制">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,284
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="官方文档翻译"><a href="#官方文档翻译" class="headerlink" title="官方文档翻译"></a>官方文档翻译</h3><p>Protocol<br>NSCopying(swift)</p>
<p>A protocol that objects adopt to provide functional copies of themselves.<br>对象采用的一种协议，用来提供拷贝自身元素的功能。</p>
<p>Overview</p>
<blockquote>
<p>The exact meaning of “copy” can vary from class to class, but a copy must be a functionally independent object with values identical to the original at the time the copy was made. A copy produced with NSCopying is implicitly retained by the sender, who is responsible for releasing it.</p>
</blockquote>
<p>拷贝的确切意义会因类而异，但拷贝的必须是一个功能独立的对象并且其值在复制时跟 元素对象的值一样。通过NSCopying生成的副本会被发送者隐式持有，发送者负责其释放。</p>
<blockquote>
<p>NSCopying declares one method, copy(with:), but copying is commonly invoked with the convenience method copy(). The copy() method is defined for all objects inheriting from NSObject and simply invokes copy(with:) with the default zone.</p>
</blockquote>
<p>NSCopying声明一个方法copy(with:)，但拷贝通常被便利方法copy()调用。copy()方法被所的继承NSObject的对象定义，并通过默认zone直接调用copy(with:)。</p>
<blockquote>
<p>Your options for implementing this protocol are as follows:</p>
</blockquote>
<p>您实现本协议的选项如下:</p>
<ul>
<li><p>Implement NSCopying using alloc and init… in classes that don’t inherit copy(with:).</p>
<ul>
<li>在不继承copy(with:)的类中，使用alloc和init方法。</li>
</ul>
</li>
<li><p>Implement NSCopying by invoking the superclass’s copy(with:) when NSCopying behavior is inherited. If the superclass implementation might use the NSCopyObject function, make explicit assignments to pointer instance variables for retained objects.</p>
<ul>
<li>当NSCopying行为被继承时，通过调用父类的copy(with:)实现NSCopying。如果父类实现可能使用NSCopyObject方法，显式分配指针实例变量来持有对象。</li>
</ul>
</li>
<li><p>Implement NSCopying by retaining the original instead of creating a new copy when the class and its contents are immutable.</p>
<ul>
<li>当类及其内容是不可变的时，通过保留原始副本而不是创建新的副本来实现NSCopying。</li>
</ul>
</li>
<li><p>If a subclass inherits NSCopying from its superclass and declares additional instance variables, the subclass has to override copy(with:) to properly handle its own instance variables, invoking the superclass’s implementation first.</p>
<ul>
<li>如果一个子类继承其父类的NSCopying并声明额外的实例变量。子类必须重写copy(with:)方法来处理自身的实例变量，父类的copy(with:）方法会先被执行。</li>
</ul>
</li>
</ul>
<hr>
<p>Protocol<br>NSMutableCopying(Object-c)</p>
<blockquote>
<p>A protocol that mutable objects adopt to provide functional copies of themselves.</p>
</blockquote>
<p>可变对象采用的一种协议，用来提供拷贝自身元素的功能。</p>
<p>Overview</p>
<blockquote>
<p>The NSMutableCopying protocol declares a method for providing mutable copies of an object. Only classes that define an “immutable vs. mutable” distinction should adopt this protocol. Classes that don’t define such a distinction should adopt NSCopying instead.</p>
</blockquote>
<p>NSMutableCopying协议声明了一个方法，用于提供对象的可变副本。只有定义“不可变与可变”区别的类才应该采用此协议。没有定义这种区别的类应该采用NSCopying。</p>
<blockquote>
<p>NSMutableCopying declares one method, mutableCopyWithZone:, but mutable copying is commonly invoked with the convenience method mutableCopy. The mutableCopy method is defined for all NSObjects and simply invokes mutableCopyWithZone: with the default zone.</p>
</blockquote>
<p>NSMutableCopying定义了一个方法mutableCopyWithZone。但可变拷贝一般通过便利方法mutableCopy调用。mutableCopy方法被所有的NSObjects定义并通过默认zone直接调用mutableCopyWithZone。</p>
<blockquote>
<p>If a subclass inherits NSMutableCopying from its superclass and declares additional instance variables, the subclass has to override mutableCopyWithZone: to properly handle its own instance variables, invoking the superclass’s implementation first.</p>
</blockquote>
<p>如果子类通过父类继承NSMutableCopying协议，同时定义了额外的实例变量。子类必须复写mutableCopyWithZone方法来处理自身额外的实例变量，但会先调用父类的mutableCopyWithZone方法。</p>
<hr>
<h4 id="相关API："><a href="#相关API：" class="headerlink" title="相关API："></a>相关API：</h4><pre><code>- (id)copy;//执行成功返回不可变对象

- (id)mutableCopy;//执行成功返回可变对象
</code></pre><h4 id="从组合的方式理解深浅拷贝"><a href="#从组合的方式理解深浅拷贝" class="headerlink" title="从组合的方式理解深浅拷贝"></a>从组合的方式理解深浅拷贝</h4><p>指针拷贝：返回对象与被复制对象都指向同一个对象，返回对象拷贝的是被复制对象的指针。</p>
<p>内容拷贝：创建新的对象，并把被复制对象的内容复制。返回对象与被复制对象指向不同的对象，返回对象拷贝的是被复制对象的内容。</p>
<ol>
<li>浅复制：被复制对象每一层都是指针拷贝。<ol>
<li>仅当执行imutable对象执行copy方法时产生浅复制。</li>
</ol>
</li>
<li><p>深复制：被复制对象第一层是内容拷贝。</p>
<ol>
<li>执行mutableCopy总会产生深复制。</li>
<li>mutable对象执行拷贝总会产生深拷贝，不论copy或mutableCopy。</li>
<li>当对象属性中存在集合的时候，集合本身是深拷贝，但其元素执行的依然是浅拷贝。这个在某些开发场景中如果使用不当，会导致业务逻辑的不对。因为是指针拷贝，实际上是同一个对象。如果我们期待他们是不同的对象，期待他们之间的修改是互不影响的，那么久需要执行完全拷贝，简单的深拷贝是不满足的。所以，要实现集合属性的内容拷贝，需要对集合属性执行 initWithArray:copyItems: / initWithDictionary:copyItems:。copyItems入参YES。</li>
</ol>
</li>
<li><p>排列组合：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">object type</th>
<th style="text-align:left">invoke funtion</th>
<th style="text-align:left">copy type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">imutable object</td>
<td style="text-align:left">copy</td>
<td style="text-align:left">shallow copy</td>
</tr>
<tr>
<td style="text-align:left">imutable object</td>
<td style="text-align:left">mutableCopy</td>
<td style="text-align:left">deep copy</td>
</tr>
<tr>
<td style="text-align:left">mutable object</td>
<td style="text-align:left">copy</td>
<td style="text-align:left">deep copy</td>
</tr>
<tr>
<td style="text-align:left">mutable object</td>
<td style="text-align:left">mutableCopy</td>
<td style="text-align:left">deep copy</td>
</tr>
</tbody>
</table>
<p>我的理解是当执行拷贝使对象状态发生变化，即可变变为不可变或者不可变变为可变，必然是深拷贝。另外可变对象执行拷贝必然也是深拷贝。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可变对象拷贝深拷贝，状态变化深拷贝。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-22-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liang's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-22-leetcode.html" itemprop="url">算法-不同路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T00:00:00+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-22-leetcode.html" class="leancloud_visitors" data-flag-title="算法-不同路径">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  838
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="/personImg/不同路径.png" alt="CNAME配置.png"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure></p>
<p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure></p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>每个格子的路径数等于其上方的格子的路径数与其左方的路径数之和。dp公式为：dp(i,j) = dp(i - 1,j) + dp (j,i - 1)，其中( 0&lt;= i &lt;= m - 1, 0 &lt;= j &lt;= n -1 )。所以右下角的格子的的路径数为dp（i-1，j-1）。特殊情况处理，如果m == 1 或者 n == 1,那么路径只有一条。</p>
<h4 id="思路1：dp"><a href="#思路1：dp" class="headerlink" title="思路1：dp"></a>思路1：dp</h4><ol>
<li>0 指向格子的第一行。有时候又在纠结到底是用0作为第一行，还是用1作为第一行。下面的递归就是使用1代表第一行。</li>
<li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">   </span><br><span class="line"> if (m == 1 || n == 1) &#123;</span><br><span class="line">     return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> int dp[100][100];</span><br><span class="line"> //水平第一行每个格子只有一种组合</span><br><span class="line"> for (int i = 0 ; i &lt; m; ++ i) &#123;</span><br><span class="line">     dp[i][0] = 1;</span><br><span class="line"> &#125;</span><br><span class="line"> //垂直第一行每个格子只有一种组合</span><br><span class="line"> for (int i = 0 ; i &lt; n; ++ i) &#123;</span><br><span class="line">     dp[0][i] = 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //数组的第0行对应格子的第一行。第0行dp值已经初始化了，这里从第二行计算起</span><br><span class="line"> for (int i = 1; i &lt; m; ++ i) &#123;</span><br><span class="line">     for (int j = 1; j &lt; n; ++ j) &#123;</span><br><span class="line">         dp[i][j] = dp[i - 1][j] + dp[i][j -1];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //(m -1 , n - 1) 对应目标格子，返回其dp值。</span><br><span class="line"> return dp[m - 1][n - 1];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="思路2：使用递归"><a href="#思路2：使用递归" class="headerlink" title="思路2：使用递归"></a>思路2：使用递归</h4><ol>
<li>核心思路跟dp一样。只是使用递归的方式实现。 数组的下标1代表的第1行。这个可能会直观一点。但有时候更容易出现问题。后面还是统一使用0作为第一行处理。</li>
<li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   int subUniquePaths(int m,int n,int **dp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    if (dp[m][n] != 0) &#123;</span><br><span class="line">        printf(&quot;(%d,%d) dp:%d\n&quot;,m,n,dp[m][n]);</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;(%d,%d)\n&quot;,m,n);</span><br><span class="line">        if (m - 1 == 0 || n - 1 == 0) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            dp[m][n] = subUniquePaths(m - 1, n,dp) + subUniquePaths(m, n -1,dp);</span><br><span class="line">            return dp[m][n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    </span><br><span class="line">    int **dp;</span><br><span class="line">    int row = 101,column = 101;</span><br><span class="line">    dp = (int **)malloc(sizeof(int *) * row); // 分配所有行的首地址</span><br><span class="line">    for (int i = 0; i &lt; row; i ++) &#123; // 按行分配每一列</span><br><span class="line">        dp[i] = (int *)malloc(sizeof(int) * column);</span><br><span class="line">        memset(dp[i], 0, sizeof(sizeof(int) * column));</span><br><span class="line">    &#125;</span><br><span class="line">    return subUniquePaths(m, n, dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol>
<li>为了直观，在递归的时候使用下标1的行作为第一行，但这也导致了程序处理思维的混乱和不统一，虽然很难说明那种好。但程序中的数组既然是从0开始，那么还是统一采用0作为第一行处理。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/icon.jpg"
                alt="zengbailiang" />
            
              <p class="site-author-name" itemprop="name">zengbailiang</p>
              <p class="site-description motion-element" itemprop="description">知行合一</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a rel="external nofollow" href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zmubai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zengbailiang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">54.5k</span>
  
</div>


  <div class="powered-by">由 <a rel="external nofollow" class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("7VSaCuGNNUXrDp0aOK65w7PQ-gzGzoHsz", "l1D8p6eriduqG6aqx1f8H7ia");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
