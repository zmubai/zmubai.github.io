<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta name="google-site-verification" content="xdxP4Om7Pxp3OMC73kRMv2emRoA91RXOEPaKMivB_zg" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="知行合一">
<meta property="og:type" content="website">
<meta property="og:title" content="沐白的个人博客">
<meta property="og:url" content="https://zengbailiang.cn/page/2/index.html">
<meta property="og:site_name" content="沐白的个人博客">
<meta property="og:description" content="知行合一">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="沐白的个人博客">
<meta name="twitter:description" content="知行合一">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zengbailiang.cn/page/2/"/>





  <title> Hexo, NexT - 沐白的个人博客知行合一 </title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沐白的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-22-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-22-leetcode.html" itemprop="url">算法-不同路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-22T00:00:00+08:00">
                2018-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-22-leetcode.html" class="leancloud_visitors" data-flag-title="算法-不同路径">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  838
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="/personImg/不同路径.png" alt="CNAME配置.png"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure></p>
<p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure></p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>每个格子的路径数等于其上方的格子的路径数与其左方的路径数之和。dp公式为：dp(i,j) = dp(i - 1,j) + dp (j,i - 1)，其中( 0&lt;= i &lt;= m - 1, 0 &lt;= j &lt;= n -1 )。所以右下角的格子的的路径数为dp（i-1，j-1）。特殊情况处理，如果m == 1 或者 n == 1,那么路径只有一条。</p>
<h4 id="思路1：dp"><a href="#思路1：dp" class="headerlink" title="思路1：dp"></a>思路1：dp</h4><ol>
<li>0 指向格子的第一行。有时候又在纠结到底是用0作为第一行，还是用1作为第一行。下面的递归就是使用1代表第一行。</li>
<li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">   </span><br><span class="line"> if (m == 1 || n == 1) &#123;</span><br><span class="line">     return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> int dp[100][100];</span><br><span class="line"> //水平第一行每个格子只有一种组合</span><br><span class="line"> for (int i = 0 ; i &lt; m; ++ i) &#123;</span><br><span class="line">     dp[i][0] = 1;</span><br><span class="line"> &#125;</span><br><span class="line"> //垂直第一行每个格子只有一种组合</span><br><span class="line"> for (int i = 0 ; i &lt; n; ++ i) &#123;</span><br><span class="line">     dp[0][i] = 1;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //数组的第0行对应格子的第一行。第0行dp值已经初始化了，这里从第二行计算起</span><br><span class="line"> for (int i = 1; i &lt; m; ++ i) &#123;</span><br><span class="line">     for (int j = 1; j &lt; n; ++ j) &#123;</span><br><span class="line">         dp[i][j] = dp[i - 1][j] + dp[i][j -1];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //(m -1 , n - 1) 对应目标格子，返回其dp值。</span><br><span class="line"> return dp[m - 1][n - 1];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="思路2：使用递归"><a href="#思路2：使用递归" class="headerlink" title="思路2：使用递归"></a>思路2：使用递归</h4><ol>
<li>核心思路跟dp一样。只是使用递归的方式实现。 数组的下标1代表的第1行。这个可能会直观一点。但有时候更容易出现问题。后面还是统一使用0作为第一行处理。</li>
<li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   int subUniquePaths(int m,int n,int **dp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    if (dp[m][n] != 0) &#123;</span><br><span class="line">        printf(&quot;(%d,%d) dp:%d\n&quot;,m,n,dp[m][n]);</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;(%d,%d)\n&quot;,m,n);</span><br><span class="line">        if (m - 1 == 0 || n - 1 == 0) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            dp[m][n] = subUniquePaths(m - 1, n,dp) + subUniquePaths(m, n -1,dp);</span><br><span class="line">            return dp[m][n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    </span><br><span class="line">    int **dp;</span><br><span class="line">    int row = 101,column = 101;</span><br><span class="line">    dp = (int **)malloc(sizeof(int *) * row); // 分配所有行的首地址</span><br><span class="line">    for (int i = 0; i &lt; row; i ++) &#123; // 按行分配每一列</span><br><span class="line">        dp[i] = (int *)malloc(sizeof(int) * column);</span><br><span class="line">        memset(dp[i], 0, sizeof(sizeof(int) * column));</span><br><span class="line">    &#125;</span><br><span class="line">    return subUniquePaths(m, n, dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol>
<li>为了直观，在递归的时候使用下标1的行作为第一行，但这也导致了程序处理思维的混乱和不统一，虽然很难说明那种好。但程序中的数组既然是从0开始，那么还是统一采用0作为第一行处理。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-07-15-0leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-07-15-0leetcode.html" itemprop="url">算法-使用最小花费爬楼梯</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-15T00:00:00+08:00">
                2018-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-07-15-0leetcode.html" class="leancloud_visitors" data-flag-title="算法-使用最小花费爬楼梯">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,333
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="索引从0开始">i</a>。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: cost = [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<p>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>可以把每个阶梯当做一个节点，能走出消耗值小值得路径可能有几条。同时可能会存在一些节点你走错了无法走出最小值的路径。如何选择这些节点是个问题。这看起来有点像广度优先搜索，每一次选择都需要根据前面的两个节点和当前节点的消耗值来确定那个组合的消耗值最小从而确定当前节点的选择。但这其实是一个动态规划问题，后面节点的选择不受前面节点的选择的影响，但会根据前面节点选择的值来确定当前节点的选择（前后步骤的联系），为了保证消耗值最小，前提是每一次选择节点都要满足消耗值最小，那么当路径走完的时候总的消耗值就是最小。算法实现的时候记录每个节点的最小消耗总值，用于后面的节点选择。实际上只需要记录最近的两个节点的最小消耗总值即可。</p>
<h4 id="思路1：dp"><a href="#思路1：dp" class="headerlink" title="思路1：dp"></a>思路1：dp</h4><ol>
<li>dp特点：<ol>
<li>后面的步骤不受前面的步骤的影响，但会用到前面步骤的计算值。需保证前面的步骤选择正确性。</li>
<li>利用容器记录每个步骤的可用值，空间换时间。</li>
</ol>
</li>
<li>代码 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int min(int a, int b )</span><br><span class="line">&#123;</span><br><span class="line">    return a &lt; b ? a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int minCostClimbingStairs(int* cost, int costSize) &#123;</span><br><span class="line">   int *dp = (int *)malloc(sizeof(int) * (costSize + 1));</span><br><span class="line">   memset(dp, 0, sizeof(int) * (costSize + 1));</span><br><span class="line">   if (costSize == 2) &#123;</span><br><span class="line">       return min(cost[0],cost[1]);</span><br><span class="line">   &#125;</span><br><span class="line">   for (int i = 2; i &lt;= costSize; i ++) &#123;</span><br><span class="line">   //记录每个dp值</span><br><span class="line">       dp[i] = min(dp[i - 1] + cost[i - 1],dp[i-2] + cost[ i - 2]);</span><br><span class="line">   &#125;</span><br><span class="line">   return dp[costSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int minCostClimbingStairs(int* cost, int costSize) &#123;</span><br><span class="line">    int dpStep1 = 0,dpStep2 = 0,dpTemp = 0;</span><br><span class="line">    if (costSize == 2) &#123;</span><br><span class="line">        return min(cost[0],cost[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2; i &lt;= costSize; i ++) &#123;</span><br><span class="line">        </span><br><span class="line">        dpTemp = dpStep1;</span><br><span class="line">        //记录最近的第一个节点的dp值</span><br><span class="line">        dpStep1 = min(dpStep1 + cost[i - 1],dpStep2 + cost[i - 2]);</span><br><span class="line">        //记录最近的第二个节点dp值</span><br><span class="line">        dpStep2 = dpTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    return dpStep1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li>复杂度分析<ol>
<li>时间复杂度 O(n), n = strlen(s)，一层循环;</li>
<li>空间复杂度 优化后为O(1)，固定数量的变量。</li>
</ol>
</li>
</ol>
<h4 id="思路2：递归实现"><a href="#思路2：递归实现" class="headerlink" title="思路2：递归实现"></a>思路2：递归实现</h4><ol>
<li>关键步骤跟dp是一样的，只是逆向的方式实现。变成了最后一次爬梯是选择走一步还是走两步的问题，然后分别计算走一步的最小消耗值和走两步的最小消耗值。执行一个递归过程。计算过程中，发现走一步的很多dp值可以被走二步所用。通过存入一个数组指针存储已有步骤的dp值。这次很多dp值都会被二次利用，而不像dp只利用前面的两个dp值。</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int min(int a, int b )</span><br><span class="line">&#123;</span><br><span class="line">    return a &lt; b ? a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int subMinCostClimbingStairs(int* cost, int end,int *dp)</span><br><span class="line">&#123;</span><br><span class="line">    if (dp[end] != 0) &#123;</span><br><span class="line">        return dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">    if(end == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[end] = min(cost[0],cost[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (end == 1|| end == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[end] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">         //1步的值。</span><br><span class="line">        int a = subMinCostClimbingStairs(cost, end - 1,dp) + cost[end - 1];</span><br><span class="line">        //2步的值。这个步骤的执行已经是a有值得时候了，所以可以复用a计算过程中产生的dp值。</span><br><span class="line">        int b = subMinCostClimbingStairs(cost, end - 2,dp) + cost[end - 2];</span><br><span class="line">        //存储dp值</span><br><span class="line">        dp[end] = min(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[end];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int minCostClimbingStairs(int* cost, int costSize) &#123;</span><br><span class="line">    int *dp = (int *)malloc(sizeof(int) * (costSize + 1));</span><br><span class="line">    memset(dp, 0, sizeof(int) * (costSize + 1));</span><br><span class="line">    return subMinCostClimbingStairs(cost, costSize,dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ol>
<li>时间复杂度 大于O(n) 且小于 O(n^2)，定向比较下。</li>
<li>空间复杂度 O(1)，少量的固定的额外空间。</li>
</ol>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol>
<li>递归的执行过程还是比较抽象，调试也不方便。递归跟逆向思维联系比较大，从问题的最后一个步骤抽象，反过来递归直到达到退出条件再逐步出栈得出计算结果。而且在调试的过程中会出现内存爆炸的情况，这也是递归需要考虑的问题。可以通过复用计算的中间值减少计算量和提高效率。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-07-14-10leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-07-14-10leetcode.html" itemprop="url">算法-反转整数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-14T00:00:00+08:00">
                2018-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-07-14-10leetcode.html" class="leancloud_visitors" data-flag-title="算法-反转整数">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  542
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>给定一个 32 位有符号整数，将整数中的数字进行反转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"> </span><br><span class="line">示例 2:</span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p>
<p>注意:<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>1.从低位开始获取位数，每次存储的时候把原有值*10，低位插入到最后面。直到处理完毕。如果中途超出了数值范围则直接返回0。</p>
<ol start="2">
<li><p>判断是否超出了数值范围</p>
<ol>
<li>已知 INT_MAX = 2147483647 ,  INT_MIN = -2147483648.<br>假设当前已有计算值为rev,尚未处理完毕且当前获取的准备插入的数值为pop。<ol>
<li>如果输入值为正数，那么当 rev &gt; INT_MAX/10 或者rev/10 == INT_MAX &amp;&amp; pop&gt;7，代表超出范围。</li>
<li>如果输入值为负数，那么当 rev &lt; INT_MIN/10 或者rev/10 == INT_MIN &amp;&amp; pop &lt; -8,代表超出范围。</li>
</ol>
</li>
</ol>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x) &#123;</span><br><span class="line"> // int max = INT_MAX;//2147483647</span><br><span class="line"> // int min = INT_MIN;//-2147483648</span><br><span class="line"> int rev = 0;</span><br><span class="line"> </span><br><span class="line"> while (x != 0) &#123;</span><br><span class="line">     //获得最后一位</span><br><span class="line">     int pop = x % 10;</span><br><span class="line">     //把倒数第二位后移到第一位</span><br><span class="line">     x /= 10;</span><br><span class="line">     //判断溢出情况  结合max 和min 的值 就知道 为什么是 7 和 -8 了</span><br><span class="line">     if (rev &gt; INT_MAX / 10 || (rev/10 == INT_MAX &amp;&amp; pop &gt; 7)) &#123; return 0; &#125;</span><br><span class="line">     if (rev &lt; INT_MIN / 10|| (rev/10 == INT_MIN &amp;&amp; pop &lt; -8)) &#123;  return 0; &#125;</span><br><span class="line">     //*10整体后移一位 ，pop插入到第一位</span><br><span class="line">     rev = rev * 10 + pop;</span><br><span class="line"> &#125;</span><br><span class="line"> return rev;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li>复杂度分析<ol>
<li>时间复杂度 O(n), n为字符的长度</li>
<li>空间复杂度 O(1)，固定数量的变量。</li>
</ol>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>主要是数值范围判断的处理。也可以用一个long型来存储，最后的时候再跟INT_MAX判断。开始的想法是从高位开始获取，然后新数值先填充低位再填充高位。这个处理起来没有从低位开始获取的方便，因为新数值前移只需要乘以10即可，非常方便。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-07-07-10leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-07-07-10leetcode.html" itemprop="url">算法-最大子序和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T00:00:00+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-07-07-10leetcode.html" class="leancloud_visitors" data-flag-title="算法-最大子序和">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,350
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure></p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><h4 id="思路1：贪心算法"><a href="#思路1：贪心算法" class="headerlink" title="思路1：贪心算法"></a>思路1：贪心算法</h4><ol>
<li>连续子数组之和如果为负数，那么把它作为和的一部分反而减少了和的大小。所以当子数组之和为负数的时候进行舍弃，取下一个元素作为起点重新累加。但这样累加会存在一个问题，虽然知道起点，也知道终点，但过程中累加到哪一个元素的和为最大却不知道。只能通过每累加一个元素就计算一次和，这样就不会错过每个可能的最大值。</li>
<li>代码 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int greedMaxSubArray(int* nums, int numsSize)</span><br><span class="line">&#123;</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">    int thisMaxSum = INT_MIN;</span><br><span class="line">    for (int i = 0 ; i &lt; numsSize; i ++) &#123;</span><br><span class="line">    </span><br><span class="line">        //如何和小于0代码表示这整块都可以舍弃，因为不起到增大和的作用</span><br><span class="line">        if (thisMaxSum &lt;= 0) &#123;</span><br><span class="line">            thisMaxSum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            thisMaxSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(maxSum &lt; thisMaxSum)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSum = thisMaxSum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li>复杂度分析<ol>
<li>时间复杂度 O(n), n = strlen(s)，一层循环;</li>
<li>空间复杂度 O(1)，固定数量的变量。</li>
</ol>
</li>
</ol>
<h4 id="思路2：动态规划DP"><a href="#思路2：动态规划DP" class="headerlink" title="思路2：动态规划DP"></a>思路2：动态规划DP</h4><ol>
<li>运行到当前步骤获取到的可用和值为当前元素的值以及累加上当前元素所得的和中的最大值。获取的DP公式： maxSub(i) = getMaxSub(maxSub(i - 1) + nums[i],nums[i]);</li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//  maxSub(i) = getMaxSub(maxSub(i - 1) + nums[i],nums[i]);</span><br><span class="line">int dpMaxSubArray(int* nums, int numsSize)</span><br><span class="line">&#123;</span><br><span class="line">    int max = nums[0];</span><br><span class="line">    int sum = nums[0];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0 ; i &lt; numsSize; i ++) &#123;</span><br><span class="line">        int currentValue = nums[i];</span><br><span class="line">        if (sum + currentValue &lt; currentValue) &#123;</span><br><span class="line">            sum += currentValue;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            sum = currentValue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum&gt;max) &#123;</span><br><span class="line">            max = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ol>
<li>时间复杂度 O(n), n = strlen(s)，一层循环;</li>
<li>空间复杂度 O(1)，少量的固定的额外空间。</li>
</ol>
</li>
</ol>
<h4 id="思路3：分治递归"><a href="#思路3：分治递归" class="headerlink" title="思路3：分治递归"></a>思路3：分治递归</h4><ol>
<li>把数组分成左右两部分，那么对于这个范围，最大和可能出现在左边或者右边或者跨越两个左右部分。本轮中先给出分割点，从分割点向两边扩散遍历，获取跨越中心点最大的和值（只需要把左右部分的遍历最大值相加，有可能左边最大值为正，右边最大值为负，不用管只管相加，左边最大值会在分割后的左边某次递归中参与比较。递归有时候就是在一轮中考虑的情况变少了，有些情况是否在递归的过程中已被处理，或者说递归入参的改变就能计算出这些情况。）。方法的返回值为递归左部分、递归右部分、本轮跨越中心的最大和值三者的最大值。比较难理解的还是每一轮只计算跨越分割点的最大和值，随着范围的缩小递归起来就涵盖了所有的情况。</li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int max(int a ,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxSubArray(int* nums, int numsSize) &#123;</span><br><span class="line">    int maxSubLeft = 0;</span><br><span class="line">    int maxSUbRight = 0;</span><br><span class="line">    int maxLeft = INT_MIN;</span><br><span class="line">    int maxRight = INT_MIN;</span><br><span class="line">    </span><br><span class="line">    //推出递归条件</span><br><span class="line">    if (left == right) &#123;</span><br><span class="line">        return nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int center = (left + right) / 2 ;</span><br><span class="line">    int maxTempLeft = 0;</span><br><span class="line">    //计算当前的左相加最大值,右到左</span><br><span class="line">    for (int i = center; i &gt;= left; i --) &#123;</span><br><span class="line">        maxTempLeft += nums[i];</span><br><span class="line">        if (maxLeft &lt; maxTempLeft) &#123;</span><br><span class="line">            maxLeft = maxTempLeft;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (maxLeft == INT_MIN) &#123;</span><br><span class="line">        maxLeft = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //计算当maxTempRight   当前前右相加最大值，左到右</span><br><span class="line">    //每一个子数组都独自全部累加左右部分，那么久含括了所有的情况。</span><br><span class="line">    int  maxTempRight = 0;</span><br><span class="line">    for (int i = center + 1; i &lt;= right; i ++) &#123;</span><br><span class="line">        maxTempRight += nums[i];</span><br><span class="line">        if (maxRight &lt; maxTempRight) &#123;</span><br><span class="line">            maxRight = maxTempRight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (maxRight == INT_MIN) &#123;</span><br><span class="line">        maxRight = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    maxSubLeft = maxsubArrayRe(nums, left, center);</span><br><span class="line">    maxSUbRight = maxsubArrayRe(nums, center + 1,right);</span><br><span class="line">    </span><br><span class="line">    return max(max(maxSUbRight,maxSubLeft),maxLeft + maxRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ol>
<li>时间复杂度O(NlogN)。</li>
</ol>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol>
<li>贪心算法中，一边累加一边记录最大值，通过这样的方式而不会错过可能的最大值。我开始想的是如何确定起点和终点，想通过舍弃头尾部分获取中间部分的方式来解题，分析出舍弃的条件是累加值少于0，就是对中间部分为负增益。这个思路也许可行，但我没搞出来。而DP，就是要分析规律，关注于步骤与步骤之间的共性，得出dp方程，通过代码实现思路。分治方法中，注意的是中心向两边扩散才能正确的计算跨越左右两边之和。递归中必不可少的是，退出递归条件，上下层递归之间的联系交互是如何的（每一轮都计算出当前范围中跨越左右两边的最大值，而下一轮递归中他会计算出，左边的最大值和右边的最大值），是否涵盖是全部情况。如果采用二分法，因为是分割了范围，那么本轮处理中需要保证那些跨越切割范围的情况。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-07-07-07-01leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-07-07-07-01leetcode.html" itemprop="url">算法-Z字形变换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-07T00:00:00+08:00">
                2018-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/blog/" itemprop="url" rel="index">
                    <span itemprop="name">blog</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-07-07-07-01leetcode.html" class="leancloud_visitors" data-flag-title="算法-Z字形变换">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,228
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure></p>
<p>之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR”</p>
<p>实现一个将字符串进行指定行数变换的函数:</p>
<p>string convert(string s, int numRows);<br>示例 1:</p>
<p>输入: s = “PAYPALISHIRING”, numRows = 3<br>输出: “PAHNAPLSIIGYIR”<br>示例 2:</p>
<p>输入: s = “PAYPALISHIRING”, numRows = 4<br>输出: “PINALSIGYAHRPI”<br>解释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p>
<h4 id="思路1：按行排序"><a href="#思路1：按行排序" class="headerlink" title="思路1：按行排序"></a>思路1：按行排序</h4><ol>
<li>题目要求有两个，一个是字符是按Z字形排序，一个由上而下按行输出。</li>
<li>分析下Z字形的排序规律。z字形先是由上而下，到了底部再向上，每到底部或者顶部就会反弹，程序中使用bool变量lineUp记录方向。遍历字符的同时，使用一个二维数组int a[row][strlen(s)]来存储行与元素原始下标的关系。遍历完毕后，按行拼接字符串并输出。</li>
<li><p>元素的下标与输出后所在的行有这样的对应关系。</p>
<pre><code>#row #数字对应元素下标。
 0   0P      6I       12N
 1   1A   5L 7S   11I 13G
 2   2Y 4A   8H 10R
 3   3P      9I     
</code></pre></li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">char* convert(char* s, int numRows) &#123;</span><br><span class="line">if (numRows == 1) &#123;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool lineUp = true;</span><br><span class="line">int len = strlen(s);</span><br><span class="line">//记录字符的二维数组。其实可以使用int的二维数组，因为字符能自动转成asscii对应的int数字。</span><br><span class="line">char **pArr = (char**)malloc(sizeof(char*) * numRows);</span><br><span class="line"></span><br><span class="line">//这个数组是为了记录当前行最大下标，用于后面遍历。其实可以不用，在记录字符串的时候末尾添加&apos;\0&apos;用于判断就行。</span><br><span class="line">int *indexArr = (int*)malloc(sizeof(int) * numRows);</span><br><span class="line">memset(indexArr, -1, sizeof(int) * numRows);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; numRows; i++ ) &#123;</span><br><span class="line">//开始的时候设置长度为len 。在leetcode上执行报超出内存限制。分析后改为len /2 + 1,因为两行的时候最多为len / 2 + 1；超过三行字符被分散到其他行行，也不会超过len /2 + 1。修改后执行通过。</span><br><span class="line">    char *a = (char*)malloc(sizeof(char*) * (len / 2 + 1));</span><br><span class="line">    memset(a, &apos;#&apos;, sizeof(char*) * (len / 2  + 1));</span><br><span class="line">    pArr[i] = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int j = 0;</span><br><span class="line">for (int i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">    int currentIndex = indexArr[j] + 1;</span><br><span class="line">    indexArr[j] = currentIndex;</span><br><span class="line">    pArr[j][currentIndex] = s[i];</span><br><span class="line">    if (lineUp) &#123;</span><br><span class="line">        if (j == numRows - 1) &#123;</span><br><span class="line">            j --;</span><br><span class="line">            lineUp = false;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (j == 0) &#123;</span><br><span class="line">            j ++;</span><br><span class="line">            lineUp = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p = (char*)malloc(sizeof(char*) * len);</span><br><span class="line">memset(p, 0, sizeof(char*) * len);</span><br><span class="line">int jj = 0;</span><br><span class="line">for (int ii = 0; ii &lt; numRows ; ii ++)&#123;</span><br><span class="line">    char *temp = pArr[ii];</span><br><span class="line">    for (int k = 0; k &lt;= indexArr[ii]; k++) &#123;</span><br><span class="line">        p[jj++] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">free(pArr);</span><br><span class="line">free(indexArr);</span><br><span class="line"></span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li>复杂度分析<ol>
<li>时间复杂度 O(n), n = strlen(s);</li>
<li>空间复杂度 O(n)。</li>
</ol>
</li>
</ol>
<h4 id="思路2：按行访问"><a href="#思路2：按行访问" class="headerlink" title="思路2：按行访问"></a>思路2：按行访问</h4><ol>
<li>这个是对字符输入的方式分析后得出的数学规律。首尾两行成等比关系，中间的行除了等比的位置填充元素外，另外还需要在等比距离倒退一定长度offset的位置填充，offset = currentRow。</li>
<li><p>代码</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">char* convert(char* s, int numRows) &#123;</span><br><span class="line">int len = strlen(s);</span><br><span class="line">//特殊情况特殊处理</span><br><span class="line">if (len == 0 || numRows == 0 || numRows == 1 || numRows == len)</span><br><span class="line">&#123;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *p = (char*)malloc(sizeof(char) * len);</span><br><span class="line">//等比间隔</span><br><span class="line">int cycleLen = 2 * numRows - 2;</span><br><span class="line">int pIndex = 0;</span><br><span class="line">for (int i = 0 ; i &lt; numRows; i ++) &#123;</span><br><span class="line">    for (int j = 0; j + i &lt; len ; j += cycleLen) &#123;</span><br><span class="line">        //获取等比位置的字符</span><br><span class="line">        p[pIndex ++] = s[i + j];</span><br><span class="line">        //获取中间行非等比位置的字符</span><br><span class="line">        if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp;  j + cycleLen - i &lt; len) &#123;</span><br><span class="line">            p[pIndex ++] = s[ j + cycleLen - i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
<li><p>复杂度分析</p>
<ol>
<li>时间复杂度 O(n), n = strlen(s);</li>
<li>空间复杂度 O(n)。如果返回字符不视为额外空间，那么空间复杂度为O(1)。</li>
</ol>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol>
<li>这道题开始也是用分析规律的方法去做，但举的例子少了点，写出来运行才发现规律是错的。后面也就没继续找数学规律。 为了避免下次犯错，找规律需要论证不少于3个例子。同时规律需要分情况讨论，例如该题的首尾两行作为一类，中间行作为一类。另外别想着用简单的规律就能处理全部问题，一般这类问题都是二级或者多级的，例如多种情况对应不同的规律，或者同一个规律要处理的多个问题。还有如果一类问题按一定方式呈现，一般会存在规律。</li>
<li>注意的地方：二维数组初始化问题；meset的使用；字符串、ASCII码、int之间的关系等。</li>
<li>部分代码可以写的更简洁，但为了更好的描述过程，暂时还是保持这个风格，有利于学习和理解。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-06-07-01-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-06-07-01-leetcode.html" itemprop="url">算法-两最长回文子串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-01T00:00:00+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-06-07-01-leetcode.html" class="leancloud_visitors" data-flag-title="算法-两最长回文子串">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  828
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot;也是一个有效答案。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>暴力法。2层循环嵌套，遍历所有子串。在判断子串是否为回文并对比保存最大的起止下标。通过前后同时截取字符串对比的方式来判断子串是否为回文。如果相等，就向两边靠拢，直对比的下标相等并且值也相等位置。如果不相等，子串非回文。</li>
<li>中心扩展算法。回文字符串有一个特点，就是左右对称。如果是奇数长度的回文字符串，中间的字符作为对称点，如aba中的a。如果是偶数长度的回文字符串，会以中间两个字符作为对称点,如abba中的bb。那么比较的时候，找到中心点，两边扩展对比就可以了。直到打破对称，通过暂存的历史最长回文子串的起止坐标比对当前长度，如果当前子串的长度较大，更新起止坐标。由于存在奇偶两种长度，对应的中心点不一样，但两种模式都可能产生回问子串，所有匹配的时候两种模式都要进行匹配，并取同一个中心点的两种模式中长度更长的更新起止坐标，这个是编码时需要处理的细节问题。</li>
</ol>
<h4 id="编码细节问题"><a href="#编码细节问题" class="headerlink" title="编码细节问题"></a>编码细节问题</h4><p>1.为了获取最后的子串，需要通过暂存起止坐标startIndex、endIndex。<br>2.默认奇数匹配方式，通过判断当前元素与其后面的元素是否相等来决定是否满足偶数匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">char* longestPalindrome(char* s) &#123;</span><br><span class="line"></span><br><span class="line">    int startIndex = 0 ;</span><br><span class="line">    int endIndex = 0;</span><br><span class="line"></span><br><span class="line">    int len = strlen(s);</span><br><span class="line">    for (int i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">        int frontIndex = i ;</span><br><span class="line">        int nextIndex = i;</span><br><span class="line"></span><br><span class="line">        bool evenSerech = true;</span><br><span class="line">        //满足偶数匹配方式</span><br><span class="line">        if (s[i] == s[nextIndex + 1]) &#123;</span><br><span class="line">            evenSerech = true;</span><br><span class="line">        &#125;</span><br><span class="line">        while (frontIndex &gt; -1 &amp;&amp; nextIndex &lt; len &amp;&amp; s[frontIndex] == s[nextIndex]) &#123;</span><br><span class="line">            frontIndex --;</span><br><span class="line">            nextIndex ++;</span><br><span class="line">        &#125;</span><br><span class="line">        int current = --nextIndex  + 1 - ++frontIndex ;</span><br><span class="line">        if (current &gt; (endIndex + 1 - startIndex)) &#123;</span><br><span class="line">            startIndex = frontIndex;</span><br><span class="line">            endIndex = nextIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (evenSerech) &#123;</span><br><span class="line">            frontIndex = i ;</span><br><span class="line">            nextIndex = i + 1;</span><br><span class="line">            while (frontIndex &gt; -1 &amp;&amp; nextIndex &lt; len &amp;&amp; s[frontIndex] == s[nextIndex]) &#123;</span><br><span class="line">                frontIndex --;</span><br><span class="line">                nextIndex ++;</span><br><span class="line">            &#125;</span><br><span class="line">            int current = --nextIndex  + 1 -  ++frontIndex ;</span><br><span class="line">            if (current &gt; (endIndex + 1 - startIndex)) &#123;</span><br><span class="line">                startIndex = frontIndex;</span><br><span class="line">                endIndex = nextIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    char *p = (char*)malloc(sizeof(char*) * (endIndex + 1 - startIndex));</span><br><span class="line">    int j = 0;</span><br><span class="line">    for (int i = startIndex; i &lt;= endIndex; i ++) &#123;</span><br><span class="line">        p[j ++] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：需要认真的分析回文的特点，回文串分偶数长度与奇数长度两种情况（认真审题并分析题目所求,不能忽略了一些必要的点，这一点很重要，卡时间比较多的是想通过修改起止指针的位置来适配偶数的模式，发现怎么都不能同时适配奇偶两种情况，如果是两类情况不能简单的统一处理的话，要变回单独处理）。另外这题能反转字符串取相同子串的方法（有坑）、动态规划和Manacher 算法来处理，后面再学习学习。</p>
<p>待完善L(‘ω’)┘三└(‘ω’)｣….</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-06-30-01-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-06-30-01-leetcode.html" itemprop="url">算法-两个排序数组的中位数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-30T00:00:00+08:00">
                2018-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-06-30-01-leetcode.html" class="leancloud_visitors" data-flag-title="算法-两个排序数组的中位数">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,750
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>两个排序数组的中位数</p>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。</p>
<p>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">中位数是 2.0</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ol>
<li>中位数下标 （假设数组为arr，长度为len，下标范围[0 ,len - 1]）<ol>
<li>如果len % 2 = 1 （为奇数），那么中位数的值为arr[mindIndex = len /2] 。</li>
<li>如果len % 2 - 0 (为偶数)，那么中位数的值为(arr[len/2]+arr[len/2 - 1])/2.0的值的和的平均值。</li>
</ol>
</li>
<li>思路一：最简单的思路把两个有序数组合并成一个有序的数组，再通过规则1.获取中位数的值。优化：结合题目要求，只需要获取中位数的值，并不需要真的要把两个数组排序成一个有序数组。那么通过两数组间隔读取，下标后移，直到累加到位置为为len/2即可获取到结果。这里如何更快地把找到len/2的位置是效率的关键。</li>
<li>思路二：假定数组A、B、长度分别为Alen、Blen。那么排序后的新数组为C、Clen。Clen = (Alen + Blen + 1）/ 2。因为A和B都是有序的，如果C是由A和B的一部分元素组成的。那么可以想象，C必然是A左边一定长度为ALefPairLen和B的左边一定长度为BLeftPairLen的两部分组成.ALefPairLen和BLeftPairLen是联动关系，ALefPairLen + BLeftPairLen =  (Alen + Blen + 1）/ 2,一增一减，一减一增，总长度是固定的。然后为了获得中位数，只需要获取其中一个数组的用于合并那部分的末尾Index，或者index + 1 （index + 1 = LefPairLen） ；这就变成了一个查找指定下标的问题了。</li>
</ol>
<h4 id="继续思路二（切换到程序中的变量，便于理解）"><a href="#继续思路二（切换到程序中的变量，便于理解）" class="headerlink" title="继续思路二（切换到程序中的变量，便于理解）"></a>继续思路二（切换到程序中的变量，便于理解）</h4><ol>
<li><p>定义：<br>假定，A数组的用于合并的长度为i，，那么最后一个元素的下标为i-1，i为用于合并的最后一个元素的下一个元素的下标。B的数组的长度j = (Alen + Blen + 1）/ 2 - i,那么B数组的最后一个元素的下标为j-1，j为用于合并的最后一个元素的下一个元素的下标。</p>
</li>
<li><p>结束条件：<br>要获取合法的i值，需要满足 A[i -1 ] &lt;= B[j] &amp;&amp; A[j] &gt;= B[j -1]；<br>如果leftPairA的最后一个元素少于leftPairB在原数组中最后一个元素的下一个元素，那么leftPairA是符合要求的。反过来B数组也一样。要达到在leftPairA和leftPairB右边的元素都比这两部分大，不然就需要继续调整。</p>
</li>
<li><p>特殊情况：代码注释中记录。</p>
</li>
<li>数的获取：<br>因为取长度的时候为halfLen = (Alen + Blen + 1）/ 2。如果总长度为奇数，最后一位就是中位fmax(a[i-1],B[j-1])。如果总长度为偶数，需要取处于中间的两个数，最后一位(fmax(a[i-1],B[j-1])为左边的一个，右边一个为halfLen之外的fmin(A[i],B[j]))。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) &#123;</span><br><span class="line">    int* A = nums1;</span><br><span class="line">    int* B = nums2;</span><br><span class="line">    int m = nums1Size;</span><br><span class="line">    int n = nums2Size;</span><br><span class="line">    </span><br><span class="line">    if (m &gt; n ) &#123;</span><br><span class="line">        int* tmp = A;</span><br><span class="line">        A = B;</span><br><span class="line">        B = tmp;</span><br><span class="line">        int k = m;</span><br><span class="line">        m = n;</span><br><span class="line">        n = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int iMin = 0;</span><br><span class="line">    int iMax = m;</span><br><span class="line">    //halfLen 偶数等于实际的一半，奇数等于向上取整</span><br><span class="line">    int halfLen = (m + n + 1) / 2 ;</span><br><span class="line">    </span><br><span class="line">    while (iMin &lt;= iMax) &#123;</span><br><span class="line">        //偶数index[i-1 , i ],奇数[i]</span><br><span class="line">        int i = (iMin + iMax) /2;</span><br><span class="line">        //长度之外的第一个元素</span><br><span class="line">        int j = halfLen - i;</span><br><span class="line">        if (i &lt; iMax &amp;&amp; A[i] &lt; B[j - 1] )</span><br><span class="line">        &#123;</span><br><span class="line">            //太小了，下限提高</span><br><span class="line">            iMin = iMin + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ( i &gt; iMin &amp;&amp; A[i- 1] &gt; B[j]) &#123;</span><br><span class="line">            //太大了,上限降低</span><br><span class="line">            iMax = iMax - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            //满足需求 (A[i - 1] &lt; B[j] &amp;&amp; A[i] &gt; B[j - 1]) || i == 0 || j == 0 || i == m || j == n</span><br><span class="line">            int leftMax = 0;</span><br><span class="line">            //m &gt; n</span><br><span class="line">            if (i == 0) &#123;</span><br><span class="line">                //在A被选中的长度为0</span><br><span class="line">                leftMax = B[j - 1];</span><br><span class="line">            &#125;else if (j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //在B中被选中的长度为0</span><br><span class="line">                leftMax = A[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //i = m;代表A数组都被选中</span><br><span class="line">                //j = n;代表整个B数组都被选中</span><br><span class="line">                //包含 j == n || i == m 的情况</span><br><span class="line">                leftMax = fmax(A[i - 1], B[j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if ((m + n) % 2 == 1) &#123;</span><br><span class="line">                return leftMax;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            int rightMin = 0;</span><br><span class="line">            if (i == m)</span><br><span class="line">            &#123;</span><br><span class="line">                //A全部被选中。那么总长度为偶数时，中位数为中间两数的平均值，选中的最后一个数为leftMax，rightMin为hanlflen之外的第一个数B[j]；</span><br><span class="line">                rightMin = B[j];</span><br><span class="line">            &#125;else if (j == n)</span><br><span class="line">            &#123;</span><br><span class="line">                //B全部被选中。那么总长度为偶数时，中位数为中间两数的平均值，选中的最后一个数为leftMax，rightMin为hanlflen之外的第一个数A[j]；</span><br><span class="line">                rightMin = A[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //包含j == 0 || i == 0 的情况</span><br><span class="line">                rightMin = fmin(A[i], B[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return (leftMax + rightMin) / 2.0 ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//另外一种效率不错的解法</span><br><span class="line">double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) &#123;</span><br><span class="line">    int* A = nums1;</span><br><span class="line">    int* B = nums2;</span><br><span class="line">    int m = nums1Size;</span><br><span class="line">    int n = nums2Size;</span><br><span class="line">    </span><br><span class="line">    if (m &lt; n ) &#123;</span><br><span class="line">        int* tmp = A;</span><br><span class="line">        A = B;</span><br><span class="line">        B = tmp;</span><br><span class="line">        int k = m;</span><br><span class="line">        m = n;</span><br><span class="line">        n = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int iMin = 0;</span><br><span class="line">    int iMax = m;</span><br><span class="line">    int halfLen = (m + n + 1) / 2 ;</span><br><span class="line">    </span><br><span class="line">    while (iMin &lt;= iMax) &#123;</span><br><span class="line">        //偶数index[i-1 , i ],奇数[i]</span><br><span class="line">        int i = (iMin + iMax) /2;</span><br><span class="line">        //长度之外的第一个元素</span><br><span class="line">        int j = halfLen - i;</span><br><span class="line">        if ( A[i- 1] &gt; B[j] &amp;&amp; i &gt; iMin ) &#123;</span><br><span class="line">            //太大了,上限降低</span><br><span class="line">            iMax = iMax - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (A[i] &lt; B[j - 1] &amp;&amp; i &lt; iMax)</span><br><span class="line">        &#123;</span><br><span class="line">            //太小了，下限提高</span><br><span class="line">            iMin = iMin + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            //满足需求 A[i - 1] &lt; B[j] &amp;&amp; A[i] &gt; B[j - 1]</span><br><span class="line">            int leftMax = 0;</span><br><span class="line">            //m &gt; n</span><br><span class="line">            if (i == 0) &#123;</span><br><span class="line">                //在A中无法找到符合的数值</span><br><span class="line">                leftMax = B[j - 1];</span><br><span class="line">            &#125;else if (j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //在B中无法找到符合的数值</span><br><span class="line">                leftMax = A[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //包含 j == n || i == m 的情况</span><br><span class="line">                leftMax = fmax(A[i - 1], B[j - 1]);</span><br><span class="line">                if ((m + n) % 2 == 1) &#123;</span><br><span class="line">                    return leftMax;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            int rightMin = 0;</span><br><span class="line">             if (i == m)</span><br><span class="line">            &#123;</span><br><span class="line">                rightMin = B[j];</span><br><span class="line">            &#125;else if (j == n)</span><br><span class="line">            &#123;</span><br><span class="line">                rightMin = A[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //包含j == 0 || i == 0 的情况</span><br><span class="line">                rightMin = fmin(A[i], B[j]);</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">            return (leftMax + rightMin) / 2.0 ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结:这道理题要处理的细节比较多。切割长度halfLen = (m + n + 1) / 2，最后一位是哪一位，是刚好是中位数呢，还是中位数左移一位，还是右移一位呢。这个会影响到后面的中位数下标取值。还要搞懂每个临界条件代表的意义。总的来说如果每一句代码都是必须的，那么必然要做到对代码的含义了然于心，才能保证程序的正确性。对的思路+对的编码 = 对的答案。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-06-28-01-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-06-28-01-leetcode.html" itemprop="url">算法-两数相加</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T00:00:00+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-06-28-01-leetcode.html" class="leancloud_visitors" data-flag-title="算法-两数相加">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  357
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>/*<br> 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。<br> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p> 示例：<br> 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br> 输出：7 -&gt; 0 -&gt; 8<br> 原因：342 + 465 = 807</p>
<p> */</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    struct ListNode* l3 = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">    struct ListNode* n1 = l1;</span><br><span class="line">    struct ListNode* n2 = l2;</span><br><span class="line">    struct ListNode* n3 = l3;</span><br><span class="line">    int carry = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        int c1 = 0;</span><br><span class="line">        int c2 = 0;</span><br><span class="line">        if (n1 != NULL) &#123;</span><br><span class="line">            c1 = n1-&gt;val;</span><br><span class="line">            n1 = n1 -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n2 != NULL) &#123;</span><br><span class="line">            c2 = n2-&gt;val;</span><br><span class="line">            n2 = n2 -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = c1 + c2 + carry;</span><br><span class="line">        carry = sum /10;</span><br><span class="line">        int currentValue = sum % 10;</span><br><span class="line">        n3-&gt;val = currentValue;</span><br><span class="line">        //考虑进位有值得情况需要进入下一个循环</span><br><span class="line">        if(n1 != NULL || n2 != NULL || carry)</span><br><span class="line">        &#123;</span><br><span class="line">            struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));</span><br><span class="line">            n3-&gt;next = newNode;</span><br><span class="line">            n3 = n3 -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">        //最后一个节点为NULL</span><br><span class="line">            n3 -&gt;next = NULL;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    return l3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：面向过程的思路。<br>注意的几个问题：</p>
<ol>
<li>进位问题，低位相加得出进位值提供给高位计算。</li>
<li>最后一轮相加的时候可能会产生进位，这个时候需要进入下一轮循环，计算下一位的值。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-06-28-02-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-06-28-02-leetcode.html" itemprop="url">算法-无重复字符的最长子串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T00:00:00+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-06-28-02-leetcode.html" class="leancloud_visitors" data-flag-title="算法-无重复字符的最长子串">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  718
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p>
<p>示例：<br>给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。</p>
<p>给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。</p>
<p>给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列  而不是子串。</p>
</blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ol>
<li>从字符串第一个元素起，从左到右获取子串。</li>
<li>每前进一个字符(下标为j)，就在当前子串中查找是否存在与当前字符重复的字符，如果存在(重复字符的下标为i)，那么能确定一个包含不重复字符的子串，其长度为j - i 对比已存储的最大长度并把两者的最大值存储。</li>
<li>现在下一个子串的起点为当前重复的字符下标j.重复执行2、3操作，直到最后一个字符。</li>
</ol>
<p>其实这是滑动窗口的思路。左闭右开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLongestSubstring(char* s) &#123;</span><br><span class="line">    int len = strlen(s);</span><br><span class="line">    //长度为0 的情况的处理</span><br><span class="line">    if(len == 0) return 0;</span><br><span class="line">    int max = 1;</span><br><span class="line">    int statrIndex = 0;</span><br><span class="line">    for (int i = 1; i &lt; len; i ++) &#123;</span><br><span class="line">        char subStr = s[i];</span><br><span class="line">        for(int j = statrIndex; j &lt;i; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            char ssubStr = s[j];</span><br><span class="line">            //如果找到重复字符串</span><br><span class="line">            if (subStr == ssubStr ) &#123;</span><br><span class="line">                if (max &lt; i  - statrIndex) &#123;</span><br><span class="line">                    max = i  - statrIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                statrIndex = j + 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //长度没添加一位，更新最大值</span><br><span class="line">        if (max &lt; i + 1 - statrIndex) &#123;</span><br><span class="line">            max = i + 1 - statrIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//每个字符都有唯一字符串ASCII的作为唯一标识，这是个技巧性问题。最多256个</span><br><span class="line">int lengthOfLongestSubstring(char* s) &#123;</span><br><span class="line">    //算法：用book标记出现过的字符的index，用max标记最大长度，用start标记当前不重复开始的index，用num表示当前不重复的个数</span><br><span class="line">    //遍历数组，若book[]大于start，说明遇到相同元素，则从其相同处重新计算长度和起始位置</span><br><span class="line">    if(NULL == s)</span><br><span class="line">        return NULL;</span><br><span class="line">    int len=strlen(s);</span><br><span class="line">    int book[255]=&#123;0&#125;;</span><br><span class="line">    //memset(book,0xff,255*sizeof(int));//将book初始化为-1</span><br><span class="line">    if (0==len)</span><br><span class="line">        return 0;</span><br><span class="line">    int start=0,max=0;//max_start=0;</span><br><span class="line">    int num=0;</span><br><span class="line">    for (int i=0;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(book[s[i]]==0 || book[s[i]]&lt;start+1)</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            if(num&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                //max_start=start;</span><br><span class="line">                max=num;</span><br><span class="line">            &#125;</span><br><span class="line">            book[s[i]]=i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            start=book[s[i]];</span><br><span class="line">            num=i-start+1;</span><br><span class="line">            book[s[i]]=i+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//写得好屌啊</span><br><span class="line">int lengthOfLongestSubstring(char* s) &#123;</span><br><span class="line">    int len=0;</span><br><span class="line">    char *end=s,*temp;</span><br><span class="line">    char* addressTable[128]=&#123;NULL&#125;;</span><br><span class="line">    while(*end)&#123;</span><br><span class="line">        temp = addressTable[*end];</span><br><span class="line">        addressTable[*end]=end;</span><br><span class="line">        if(temp&gt;=s)&#123;</span><br><span class="line">        len=end-s&gt;len?end-s:len;</span><br><span class="line">        s = temp+1;</span><br><span class="line">        &#125;end++;</span><br><span class="line">    &#125;</span><br><span class="line">    len=end-s&gt;len?end-s:len;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：这里又存在查找问题，可以考虑使用哈希Map提高效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zengbailiang.cn/2018-06-27-01-leetcode.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zengbailiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沐白的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018-06-27-01-leetcode.html" itemprop="url">算法-两数之和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-27T00:00:00+08:00">
                2018-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018-06-27-01-leetcode.html" class="leancloud_visitors" data-flag-title="算法-两数之和">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  668
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p>
</blockquote>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<pre><code>示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="line"> */</span><br><span class="line"> //面向过程的解法；这是最直接的思路。</span><br><span class="line">int* twoSum(int* nums, int numsSize, int target) &#123;</span><br><span class="line">    int *a=(int *)malloc(2*sizeof(int));</span><br><span class="line">    //外层index从0开始遍历</span><br><span class="line">    int index = 0;</span><br><span class="line">    while (index &lt; numsSize - 1) &#123;</span><br><span class="line">    //内层从外层当前下标index的下一个元素开始遍历即i= index + 1</span><br><span class="line">        int i = index + 1;</span><br><span class="line">        while (i &lt; numsSize) &#123;</span><br><span class="line">        //判断两个元素之和是否等于target,如果相等，保存值并返回。</span><br><span class="line">            if (*(nums + i) + *(nums + index) == target) &#123;</span><br><span class="line">                *(a + 0)= index;</span><br><span class="line">                *(a + 1) = i;</span><br><span class="line">                return a;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        index ++;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//思路升级</span><br><span class="line">//c++ 哈希map  空间换时间</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int,int&gt; valueMap;</span><br><span class="line">        for (int i = 0 ; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            int searchValue = target - nums[i];</span><br><span class="line">            map&lt;int,int&gt;::iterator it ;</span><br><span class="line">            //通过value查找是否存在，该操作时间复杂度为O(1);</span><br><span class="line">            it = valueMap.find(searchValue);</span><br><span class="line">            if (it != valueMap.end()) &#123;</span><br><span class="line">                vector&lt;int&gt; collect;</span><br><span class="line">                collect.push_back(valueMap[searchValue]);</span><br><span class="line">                collect.push_back(i);</span><br><span class="line">                return collect;</span><br><span class="line">            &#125;</span><br><span class="line">            valueMap.insert(pair&lt;int, int&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; collect;</span><br><span class="line">        return collect; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>小结：</p>
<ol>
<li>该题难度不大，直接使用面向过程的方法就能求解。</li>
<li>该问题步骤分解中，因为已知和以及其中一个加数求另外一个加数，转换到程序中就是一个查找的问题-&gt;一个已知集合查找特定值得问题.</li>
</ol>
<p>一个已知集合查找特定值得问题，会直接导致两种思路：</p>
<ol>
<li>遍历查找-&gt;优化遍历方法</li>
<li>空间换时间-&gt;哈希查找(这里会产生一种数据结构，它会把一个数值和数值的索引存储【起到存储的作用】，并能快速通过索引查找到对应的数值。另外由于不存在相同索引，所以可以【存储同一索引最后状态的值】,这个性质可以对某类问题做优化，例如最长不重复字符子串问题，通过值替换能保存相同字符的最后位置j(当前位置)，假设被替换前的值为i ，那么当前子串长度len = j - i )。</li>
</ol>
<p>思维路线：<br>-&gt;常规思路是否可解；<br>-&gt;是否存查找问题-&gt;是否可以使用空间换时间(哈希查找，备忘录等)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/icon.jpg"
                alt="zengbailiang" />
            
              <p class="site-author-name" itemprop="name">zengbailiang</p>
              <p class="site-description motion-element" itemprop="description">知行合一</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a rel="external nofollow" href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zmubai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zengbailiang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">47.3k</span>
  
</div>


  <div class="powered-by">由 <a rel="external nofollow" class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("7VSaCuGNNUXrDp0aOK65w7PQ-gzGzoHsz", "l1D8p6eriduqG6aqx1f8H7ia");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
